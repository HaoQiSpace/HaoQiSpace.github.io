<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue 学习之旅</title>
    <url>/Vue-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue 是什么，相信我不用多说了吧，大家都知道，它是当前的主流前端框架，也是我最喜欢的前端框架。当你打开 <a href="https://cn.vuejs.org/">Vue官网</a> 你就会看到 <code>渐进式 JavaScript 框架</code> 字样，什么意思呢？我的理解是：你觉的 vue 的哪些东西可以实现你的需求，你就用哪个，而不需要一次性的去接受它的全部功能特性，这样一方面你的学习成本慢慢降低下来了，实际达到的效果也有了，这样你也会更觉得有成就感。</p>
<p>认识到了主页面的几个醒目的字样后，那就一起点击起步按钮，开始进入 Vue 的学习吧<del>~</del></p>
<h3 id="初识-Vue"><a href="#初识-Vue" class="headerlink" title="初识 Vue"></a>初识 Vue</h3><p>在正式学习 Vue 之前，我们以经典的 Hello World 来对比下传统的开发模式与 Vue 开发模式，直观的对 Vue 进行一个认识。</p>
<blockquote>
<p>传统开发模式</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200912202443.PNG"></p>
<blockquote>
<p>Vue 开发模式</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200912202509.PNG"></p>
<p>通过上面的对比，我们会发现 Vue 的开发模式，几乎是不需要去操作 DOM 的，关注的更多的是数据的处理，是不是很棒！！！</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。简单的说就是，和我们平时写的 HTML 一样，遵循规范的浏览器和 HTML 解析器解析。</p>
<blockquote>
<p>插值表达式（插值文本）</p>
</blockquote>
<p>说明：“Mustache”语法 (双大括号) 的文本插值</p>
<p>形式：JavaScript 表达式均支持</p>
<p>注意：Vue 中只有在标签的内容中才用插值语法</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200913174627.png"></p>
<blockquote>
<p>自带指令</p>
</blockquote>
<p>说明：本质就是自定义属性</p>
<ul>
<li><p><strong>v-cloak</strong></p>
<p>作用：防止页面加载时出现闪烁问题和网络过慢时显示插值表达式问题</p>
<p>原理：在数据渲染完场之后，v-cloak 属性会被自动去除，v-cloak 一旦移除也就是没有这个属性了 ，属性选择器就选择不到该标签，也就是对应的标签会变为可见</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、通过属性选择器，选择到带有属性 v-cloak 的标签，让他隐藏</span></span><br><span class="line"><span class="comment"> * 2、让带有插值语法的添加 v-cloak 属性</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">&lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">  [v-cloak] &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;div v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123; </span><br><span class="line">     el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: <span class="string">&#x27;Hello Vue&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>v-text</strong></p>
<p>作用：用于将数据填充到标签中，作用与插值表达式类似，但是没有闪动问题，如果数据中有 HTML 标签会一并输出</p>
<p>注意：此处为单向绑定，数据对象上的值改变，插值会发生变化，但是当插值发生变化并不会影响数据对象的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p v-text=<span class="string">&quot;msg&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt; &#123;&#123; msg &#125;&#125; &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      msg: <span class="string">&#x27;Hello Vue.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>v-html</strong></p>
<p>作用：用法和 v-text 相似 ，但是它可以将 HTML 片段填充到标签中</p>
<p>注意：可能有安全问题,，一般只在可信任内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上</p>
<p>区别：<code>v-text</code> 输出的是<strong>纯文本</strong>，浏览器不会对其再进行 html 解析，但 <code>v-html</code> 会将其当 <code>html 标签解析后输出</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;!-- 输出: html 标签在渲染的时候被解析 --&gt;</span><br><span class="line">  &lt;p v-html=<span class="string">&quot;html&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">  &lt;!-- 输出: <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>通过双括号绑定<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> --&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;!-- 输出: <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>html 标签在渲染的时候被源码输出<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> --&gt;</span><br><span class="line">　&lt;p v-text=<span class="string">&quot;text&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">　el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">　data: &#123;</span><br><span class="line">　　message: <span class="string">&quot;&lt;span&gt;通过双括号绑定&lt;/span&gt;&quot;</span>,</span><br><span class="line">　　html: <span class="string">&quot;&lt;span&gt;html 标签在渲染的时候被解析&lt;/span&gt;&quot;</span>,</span><br><span class="line">　　text: <span class="string">&quot;&lt;span&gt;html 标签在渲染的时候被源码输出&lt;/span&gt;&quot;</span>,</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>v-pre</strong></p>
<p>作用：显示原始信息，跳过这个元素和它的子元素的编译过程</p>
<p>技巧：<strong>一些静态的内容不需要编译加这个指令可以加快渲染</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span v-pre&gt;&#123;&#123; <span class="built_in">this</span> will not be compiled &#125;&#125;&lt;/span&gt;    </span><br><span class="line">&lt;!-- 显示的是&#123;&#123; <span class="built_in">this</span> will not be compiled &#125;&#125; --&gt;</span><br><span class="line">&lt;span v-pre&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;  </span><br><span class="line">&lt;!-- 即使 data 里面定义了 msg 这里仍然显示的是 &#123;&#123; msg &#125;&#125; --&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      msg: <span class="string">&#x27;Hello Vue.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>v-once</strong></p>
<p>作用：执行一次性的插值【当数据改变时，插值处的内容不会继续更新】</p>
<p>应用：如果显示的信息后续不需要再修改，可以使用 v-once，这样可以提高性能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 data 里面定义了 msg，后期我们修改了，仍然显示的是第一次 data 里面存储的数据即: Hello Vue.js  --&gt;</span><br><span class="line">&lt;span v-once&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: <span class="string">&#x27;Hello Vue.js&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>双向数据绑定:  v-model</strong></p>
<p>当<code>数据</code>发生变化的时候，<code>视图</code>也会跟着同步变化</p>
<p>当<code>视图</code>发生变化的时候，<code>数据</code>也会跟着同步变化</p>
<p><strong>注意：</strong>限制在 <code>form 表单</code> 和 <code>components 组件</code> 中使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: <span class="string">&#x27;Hello Vue.js&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>v-on</strong></p>
<p>作用：用来绑定事件</p>
<p>简写：<code>v-on:click</code>  简写为 <code>@click</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200913180943.png"></p>
</li>
<li><p><strong>v-bind</strong></p>
<p>作用：响应地更新 HTML 属性</p>
<p>简写：<code>v-bind:href</code> 可以缩写为 <code>:href</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 绑定一个属性 --&gt;</span><br><span class="line">&lt;img v-bind:src=<span class="string">&quot;imageSrc&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;img :src=<span class="string">&quot;imageSrc&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>绑定对象</strong></p>
<p>我们可以给 <code>v-bind:class</code>  一个对象，比如：<strong>样式的动态切换</strong></p>
<p>注意：<strong>v-bind:class 指令可以与普通的 class（对象） 特性共存</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTML 最终渲染为 &lt;ul class=&quot;box textColor textSize&quot;&gt;&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * 	- textColor，textSize 对应的渲染到页面上的 CSS 类名</span></span><br><span class="line"><span class="comment"> *  - isColor，isSize 对应 vue data 中的数据，如果为 true，则对应的类名渲染到页面上</span></span><br><span class="line"><span class="comment"> *  - 当 isColor 和 isSize 变化时，class 列表将相应的更新</span></span><br><span class="line"><span class="comment"> *  - 例如，将 isSize 改成 false，class 列表将变为 &lt;ul class=&quot;box textColor&quot;&gt;&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box &#123;</span><br><span class="line">        border:1px dashed #f0f;</span><br><span class="line">    &#125;</span><br><span class="line">    .textColor &#123;</span><br><span class="line">        color:#f00;</span><br><span class="line">        background-color:#eef;</span><br><span class="line">    &#125;</span><br><span class="line">    .textSize &#123;</span><br><span class="line">        font-size:<span class="number">30</span>px;</span><br><span class="line">        font-weight:bold;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;box&quot;</span> v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&#123; textColor: isColor, textSize: isSize &#125;&quot;</span>&gt;</span><br><span class="line">  &lt;li&gt;学习 Vue &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;学习 Node &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;学习 React &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;div v-bind:style=<span class="string">&quot;&#123; color: activeColor, fontSize: activeSize &#125;&quot;</span>&gt;对象语法&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;sript&gt;</span><br><span class="line"><span class="keyword">var</span> vm= <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;.box&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        isColor:<span class="literal">true</span>,</span><br><span class="line">        isSize:<span class="literal">true</span>,</span><br><span class="line">    	activeColor:<span class="string">&quot;red&quot;</span>,</span><br><span class="line">        activeSize:<span class="string">&quot;25px&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/sript&gt;</span><br></pre></td></tr></table></figure>

<p><strong>绑定数组</strong></p>
<p>v-bind 中支持绑定一个<code>数组</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * v-bind 中支持绑定一个数组，数组中 classA 和 classB 对应为 data 中的数据</span></span><br><span class="line"><span class="comment"> * 	- 这里的 classA 对应 data 中的 classA</span></span><br><span class="line"><span class="comment"> *  - 这里的 classB 对应 data 中的 classB</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        border:1px dashed #f0f;</span><br><span class="line">    &#125;</span><br><span class="line">    .textColor&#123;</span><br><span class="line">        color:#f00;</span><br><span class="line">        background-color:#eef;</span><br><span class="line">    &#125;</span><br><span class="line">    .textSize&#123;</span><br><span class="line">        font-size:<span class="number">30</span>px;</span><br><span class="line">        font-weight:bold;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;box&quot;</span> :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[classA, classB]&quot;</span>&gt;</span><br><span class="line">    &lt;li&gt;学习Vue&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;学习Node&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;学习React&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> vm= <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;.box&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        classA: <span class="string">&#x27;textColor&#x27;</span>,</span><br><span class="line">        classB: <span class="string">&#x27;textSize&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>绑定对象</strong> 和 <strong>绑定数组</strong> 的区别</p>
<p><strong>绑定对象的时候：对象的属性对应的是 要渲染的类名，对象的属性值对应的是 data 中的数据</strong></p>
<p><strong>绑定数组的时候：数组里面存的是 data 中的数据</strong></p>
<p><strong>三个灵活细节点</strong></p>
<p>绑定对象和绑定数组可以结合使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;[activeClass, errorClass, &#123;test: isTest&#125;]&#x27;</span>&gt;测试样式&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>类样式数组的简化操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;arrClasses&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * data 中定义绑定的这个属性和值</span></span><br><span class="line"><span class="comment"> * 后续改变绑定的 类样式，通过相应的 api 和相应的处理逻辑处理 data 中的这个数据即可</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">arrClasses: [<span class="string">&#x27;active&#x27;</span>,<span class="string">&#x27;error&#x27;</span>]</span><br><span class="line"><span class="comment">// 同理，类对象简化处理</span></span><br><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;objClasses&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="comment">// data 中</span></span><br><span class="line">objClasses: &#123; <span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">error</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>

<p>默认的类样式处理：给个默认类样式即可，默认的会被保留，而不会被覆盖，如 base</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;base&quot;</span> v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;objClasses&#x27;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>绑定 Style</strong></p>
<p>绑定 style 的用法和上述类似</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">&quot;styleObject&quot;</span>&gt;绑定样式对象&lt;/div&gt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&lt;!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) --&gt;</span></span><br><span class="line"><span class="string">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize,background:&#x27;</span>red<span class="string">&#x27; &#125;&quot;&gt;内联样式&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!-- 组语法可以将多个样式对象应用到同一个元素 --&gt;</span></span><br><span class="line"><span class="string">&lt;div v-bind:style=&quot;[styleObj1, styleObj2]&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  new Vue(&#123;</span></span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      styleObject: &#123;</span><br><span class="line">        color: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">        fontSize: <span class="string">&#x27;30px&#x27;</span>,</span><br><span class="line">        background:<span class="string">&#x27;red&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      activeColor: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">   		fontSize: <span class="string">&quot;30px&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      styleObj1: &#123;</span><br><span class="line">        color: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      styleObj2: &#123;</span><br><span class="line">        fontSize: <span class="string">&#x27;30px&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分支结构指令</strong></p>
<p><strong>v-if</strong> — <strong>v-else</strong> — <strong>v-else-if</strong> — <strong>v-show</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">if</span>=<span class="string">&#x27;score&gt;=90&#x27;</span>&gt;优秀&lt;/div&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&#x27;score&lt;90&amp;&amp;score&gt;=80&#x27;</span>&gt;良好&lt;/div&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&#x27;score&lt;80&amp;&amp;score&gt;60&#x27;</span>&gt;一般&lt;/div&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">else</span>&gt;比较差&lt;/div&gt;</span><br><span class="line">    &lt;div v-show=<span class="string">&#x27;flag&#x27;</span>&gt;测试v-show&lt;/div&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">&#x27;handle&#x27;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        score: <span class="number">10</span>,</span><br><span class="line">        flag: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handle: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.flag = !<span class="built_in">this</span>.flag;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>v-if</strong> 的应用场景：1、条件判断；2、控制元素的显示隐藏</p>
<p><strong>v-show</strong> 的应用场景：主要是控制元素的显示隐藏</p>
<p><code>两者的区别</code></p>
<p><strong>v-show 本质：就是标签 display 设置为 none，控制隐藏 。v-show 只编译一次，后面其实就是控制 css，而 v-if 不停的销毁和创建节点，故 v-show 性能更好一点，所以当需要频繁的切换组件、节点或者控制元素的显示的隐藏的时候，优先选用 v-show</strong>。</p>
<p><strong>v-if 是动态的向 DOM 树内添加或者删除 DOM 元素，v-if 切换有一个局部编译 / 卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件</strong></p>
</li>
<li><p><strong>分支循环结构</strong></p>
<p><strong>v-for — key</strong>：用于循环的数组里面的值可以是对象，也可以是普通元素  </p>
<p>key 的作用：<strong>为了高效的更新虚拟 DOM，key 来给每个节点做一个唯一标识，这样可以提高性能</strong></p>
<p>注意：**不推荐 **同时使用 <code>v-if</code> 和 <code>v-for</code>，因为当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。</p>
<p>遍历数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;水果列表&lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-<span class="keyword">for</span>=<span class="string">&#x27;item in fruits&#x27;</span>&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">      &lt;li v-<span class="keyword">for</span>=<span class="string">&#x27;(item, index) in fruits&#x27;</span>&gt;&#123;&#123;item + <span class="string">&#x27;---&#x27;</span> + index&#125;&#125;&lt;/li&gt;</span><br><span class="line">      &lt;li :key=<span class="string">&#x27;item.id&#x27;</span> v-<span class="keyword">for</span>=<span class="string">&#x27;(item, index) in myFruits&#x27;</span>&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;item.ename&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;-----&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;item.cname&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        fruits: [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>],</span><br><span class="line">        myFruits: [&#123;</span><br><span class="line">          id: <span class="number">1</span>,</span><br><span class="line">          ename: <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">          cname: <span class="string">&#x27;苹果&#x27;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          id: <span class="number">2</span>,</span><br><span class="line">          ename: <span class="string">&#x27;orange&#x27;</span>,</span><br><span class="line">          cname: <span class="string">&#x27;橘子&#x27;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          id: <span class="number">3</span>,</span><br><span class="line">          ename: <span class="string">&#x27;banana&#x27;</span>,</span><br><span class="line">          cname: <span class="string">&#x27;香蕉&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>遍历对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;!-- v,k,i 顺序是固定的，即 值，属性，索引 --&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">if</span>=<span class="string">&#x27;v==13&#x27;</span> v-<span class="keyword">for</span>=<span class="string">&#x27;(v,k,i) in obj&#x27;</span>&gt;&#123;&#123;v + <span class="string">&#x27;---&#x27;</span> + k + <span class="string">&#x27;---&#x27;</span> + i&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">          uname: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">          age: <span class="number">13</span>,</span><br><span class="line">          gender: <span class="string">&#x27;female&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a><strong>事件修饰符</strong></h4><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求，但 Vue 不推荐我们操作 DOM ，为了解决这个问题，Vue 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>，具体更多请 <a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">参考文档</a></p>
<p>特征：修饰符是由 <code>点开头的指令后缀 </code>来表示的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div v-on:click=<span class="string">&#x27;handle0&#x27;</span>&gt;</span><br><span class="line">      &lt;!-- vue 做法: v-on:click.stop 阻止冒泡 --&gt;</span><br><span class="line">      &lt;button v-on:click.stop=<span class="string">&#x27;handle1&#x27;</span>&gt;点击<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;!-- vue 做法: v-on:click.prevent 阻止默认行为 --&gt;</span><br><span class="line">      &lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span> v-on:click.prevent=<span class="string">&#x27;handle2&#x27;</span>&gt;百度&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        num: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handle0: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.num++;</span><br><span class="line">        &#125;,</span><br><span class="line">        handle1: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">          <span class="comment">// 阻止冒泡，传统做法</span></span><br><span class="line">          <span class="comment">// event.stopPropagation();</span></span><br><span class="line">        &#125;,</span><br><span class="line">        handle2: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">          <span class="comment">// 阻止默认行为，传统做法</span></span><br><span class="line">          <span class="comment">// event.preventDefault();</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联,即: 阻止冒泡也阻止默认事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即: 事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>使用修饰符时，顺序很重要。相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<code>所有的</code>点击，而 <code>v-on:click.self.prevent</code> 只会阻止<code>对元素自身的</code>点击。</p>
<h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符，具体请 <a href="https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">参考文档</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        用户名：</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> v-on:keyup.delete=<span class="string">&#x27;clearContent&#x27;</span> v-model=<span class="string">&#x27;uname&#x27;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        密码：</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> v-on:keyup.f1=<span class="string">&#x27;handleSubmit&#x27;</span> v-model=<span class="string">&#x27;pwd&#x27;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;button&quot;</span> v-on:click=<span class="string">&#x27;handleSubmit&#x27;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    Vue.config.keyCodes.f1 = <span class="number">113</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        uname: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        pwd: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        age: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        clearContent:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="comment">// 按 elete 键的时候，清空用户名</span></span><br><span class="line">          <span class="built_in">this</span>.uname = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        handleSubmit: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.uname,<span class="built_in">this</span>.pwd)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="常用特性"><a href="#常用特性" class="headerlink" title="常用特性"></a>常用特性</h3><h4 id="表单操作"><a href="#表单操作" class="headerlink" title="表单操作"></a>表单操作</h4><p>表单是与服务端进行交互的最常见的方式之一，原生的表单在不指定 method 的情况下，默认是 get 请求方式，其中表单项中各项的 name 属性及其值会以 键值对 的形式传递到服务端，并且 value 值在提交按钮为 submit 的时候也会被提交，但利用 ajax 提交是可以自定义提交哪个值的，那么在 Vue 中，对表单的操作又是怎样的呢？</p>
<blockquote>
<p>获取文本的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 v-model 双向绑定 一个值</span></span><br><span class="line">&lt;input v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      <span class="comment">// 默认会让当前的 文本 值为 hello vue</span></span><br><span class="line">      message: <span class="string">&#x27;hello vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取多行文本的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;textarea v-model=<span class="string">&#x27;desc&#x27;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      <span class="comment">// 默认会让当前的 多行文本 值为 nihao</span></span><br><span class="line">      desc: <span class="string">&#x27;nihao&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取单选框中的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、两个单选框需要同时通过 v-model 双向绑定 一个值</span></span><br><span class="line"><span class="comment"> * 2、每一个单选框必须要有 value 属性，且 value 值不能一样 </span></span><br><span class="line"><span class="comment"> * 3、当某一个单选框选中的时候 v-model 会将当前的 value 值改变 data 中的数据</span></span><br><span class="line"><span class="comment"> * gender 的值就是选中的值，我们只需要实时监控他的值就可以了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;input type=<span class="string">&quot;radio&quot;</span> id=<span class="string">&quot;male&quot;</span> value=<span class="string">&quot;1&quot;</span> v-model=<span class="string">&#x27;gender&#x27;</span>&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;male&quot;</span>&gt;男&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=<span class="string">&quot;radio&quot;</span> id=<span class="string">&quot;female&quot;</span> value=<span class="string">&quot;2&quot;</span> v-model=<span class="string">&#x27;gender&#x27;</span>&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;female&quot;</span>&gt;女&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      <span class="comment">// 默认会让当前的 value 值为 2 的单选框选中</span></span><br><span class="line">      gender: <span class="number">2</span> </span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取复选框中的值</p>
<p>Tips：复选框 <code>checkbox</code> 这种的组合时，data 中的数据，我们要定义成数组 否则无法实现多选</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、复选框需要同时通过 v-model 双向绑定 一个值</span></span><br><span class="line"><span class="comment"> * 2、每一个复选框必须要有 value 属性，且 value 值不能一样 </span></span><br><span class="line"><span class="comment"> * 3、当某一个复选框选中的时候 v-model 会将当前的 value 值改变 data 中的数据</span></span><br><span class="line"><span class="comment"> * hobby 的值就是选中的值，我们只需要实时监控他的值就可以了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> id=<span class="string">&quot;ball&quot;</span> value=<span class="string">&quot;1&quot;</span> v-model=<span class="string">&#x27;hobby&#x27;</span>&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;ball&quot;</span>&gt;篮球&lt;/label&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> id=<span class="string">&quot;sing&quot;</span> value=<span class="string">&quot;2&quot;</span> v-model=<span class="string">&#x27;hobby&#x27;</span>&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;sing&quot;</span>&gt;唱歌&lt;/label&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> id=<span class="string">&quot;code&quot;</span> value=<span class="string">&quot;3&quot;</span> v-model=<span class="string">&#x27;hobby&#x27;</span>&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;code&quot;</span>&gt;写代码&lt;/label&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      <span class="comment">// 默认会让当前的 value 值为 2 和 3 的复选框选中</span></span><br><span class="line">      hobby: [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取下拉框和文本框中的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、需要给 select 通过 v-model 双向绑定 一个值 </span></span><br><span class="line"><span class="comment"> * 2、每一个 option 必须要有 value 属性，且 value 值不能一样  </span></span><br><span class="line"><span class="comment"> * 3、当某一个 option 选中的时候 v-model 会将当前的 value 值改变 data 中的数据</span></span><br><span class="line"><span class="comment"> * occupation 的值就是选中的值，我们只需要实时监控他的值就可以了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;select v-model=<span class="string">&#x27;occupation&#x27;</span>&gt;</span><br><span class="line">  &lt;option value=<span class="string">&quot;0&quot;</span>&gt;请选择职业...&lt;/option&gt;</span><br><span class="line">  &lt;option value=<span class="string">&quot;1&quot;</span>&gt;教师&lt;/option&gt;</span><br><span class="line">  &lt;option value=<span class="string">&quot;2&quot;</span>&gt;软件工程师&lt;/option&gt;</span><br><span class="line">  &lt;option value=<span class="string">&quot;3&quot;</span>&gt;律师&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      <span class="comment">// 默认会让当前的 value 值为 2 和 3 的下拉框选中</span></span><br><span class="line">      occupation: [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>],</span><br><span class="line">      desc: <span class="string">&#x27;nihao&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>表单修饰符</p>
<p>Tips：具体查看 <a href="https://cn.vuejs.org/v2/guide/forms.html#%E4%BF%AE%E9%A5%B0%E7%AC%A6">官方文档</a></p>
</blockquote>
<ul>
<li><p><code>.number</code>  转换为数值</p>
<p>注意：<strong>当开始输入非数字的字符串时</strong>，因为 Vue 无法将字符串转换成数值，所以属性值将实时更新成相同的字符串，即使后面输入数字，也将被视作字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 自动将用户的输入值转为数值类型 --&gt;</span><br><span class="line">&lt;input v-model.number=<span class="string">&quot;age&quot;</span> type=<span class="string">&quot;text&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.trim</code>  自动过滤用户输入的首尾空白字符</p>
<p>注意：只能去掉首尾的，不能去除中间的空格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 自动过滤用户输入的首尾空白字符 --&gt;</span><br><span class="line">&lt;input v-model.trim=<span class="string">&quot;msg&quot;</span> type=<span class="string">&quot;text&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.lazy</code>  将 input 事件（输入框一直输入都会触发）切换成 change 事件（输入框失去焦点触发）</p>
<p>注意：.lazy 修饰符延迟了同步更新属性值的时机，即将原本绑定在 input 事件的同步逻辑转变为绑定在 change 事件上</p>
<p>应用：如，账号输入，鼠标离开输入框后提示 “账户已被注册”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在 “change” 时而非 “input” 时更新 --&gt;</span><br><span class="line">&lt;input v-model.lazy=<span class="string">&quot;msg&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>why ? 内置指令不满足需求的时候，需要自定义指令</p>
<p>关于这篇幅，有需求的可以到 <a href="https://cn.vuejs.org/v2/guide/custom-directive.html">官方</a> 进行详细了解，这里做个简单的介绍</p>
<blockquote>
<p>Vue.directive  注册全局指令（可带动态参数）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用自定义的指令，只需在对用的元素中，加上&#x27;v-&#x27;的前缀形成类似于内部指令 &#x27;v-if&#x27;，&#x27;v-text&#x27; 的形式</span></span><br><span class="line"><span class="comment"> * 注意点：</span></span><br><span class="line"><span class="comment"> *  - 在自定义指令中，如果以驼峰命名的方式定义，如：Vue.directive(&#x27;focusA&#x27;,function()&#123;&#125;)</span></span><br><span class="line"><span class="comment"> *  - 在 HTML 中使用的时候，只能通过 v-focus-a 来使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-focus&gt;</span><br><span class="line">&lt;script&gt;    </span><br><span class="line"><span class="comment">// 注册一个全局自定义指令 v-focus</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当绑定元素插入到 DOM 中，其中 el 为 dom 元素</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">　　el:<span class="string">&#x27;#app&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="四大标杆"><a href="#四大标杆" class="headerlink" title="四大标杆"></a>四大标杆</h4><p>Vue 里面有三个非常突出的东西，就是如下，这里主要介绍下这三者的区别和应用场景</p>
<p><a href="https://cn.vuejs.org/v2/guide/computed.html"><strong>方法</strong></a>  &amp;&amp;  <a href="https://cn.vuejs.org/v2/guide/computed.html"><strong>计算属性</strong></a>  &amp;&amp;  <a href="https://cn.vuejs.org/v2/guide/computed.html"><strong>侦听器</strong></a>  &amp;&amp;  <a href="https://cn.vuejs.org/v2/guide/filters.html"><strong>过滤器</strong></a></p>
<p><strong>方法（methods）：</strong>这个最没啥可说的，就是定义了许多函数，对相关进行逻辑处理</p>
<p><strong>计算属性（computed）：</strong>与方法区别不大，唯一就是多了个<strong>响应式依赖缓存机制</strong>，有利性能的提升</p>
<ul>
<li><p><strong>响应式依赖缓存机制：因为计算属性更多的用于 data 中的数据逻辑处理，所以这个响应式依赖中的依赖指的就是 data 中的数据，而只要 data 中的数据不发生改变，也就不会重新计算，进而有利性能提升</strong></p>
</li>
<li><p>应用场景：适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&#x27;Nihao&#x27;</span>,</span><br><span class="line">    <span class="comment">// 下面 computed 中的计算依赖 num 进行</span></span><br><span class="line">    num: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    reverseString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// num 的值不发生改变，total 的结果就会被缓存，而不需要进行多次执行</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">this</span>.num;i++)&#123;</span><br><span class="line">        total += i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>侦听器（watch）：</strong>data 中某个数据绑定对应的一个侦听器，data 中的这个数据发生改变的时候，自然就触发这个侦听器</p>
<p><strong>注意点：</strong></p>
<ul>
<li><strong>watch 中的属性，一定是 data 中已经存在的数据</strong> </li>
<li><strong>当需要监听一个对象的改变时，普通的 watch 方法无法监听到对象内部属性的改变，只有 data 中的数据才能够监听到变化，此时就需要 deep 属性对对象进行深度监听</strong></li>
</ul>
<p>应用场景：</p>
<ul>
<li><p>异步操作：比如 Ajax 异步请求数据，使用 watch 来响应数据的变化</p>
</li>
<li><p>开销较大的操作：耗时比较大的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：验证用户名</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;用户名：&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> v-model.lazy=<span class="string">&#x27;uname&#x27;</span>&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; tip &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        uname: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        tip: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        checkName: <span class="function"><span class="keyword">function</span>(<span class="params">uname</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 调用接口: 使用定时任务的方式模拟接口调用</span></span><br><span class="line">          <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 模拟接口调用</span></span><br><span class="line">            <span class="keyword">if</span> (uname == <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">              that.tip = <span class="string">&#x27;用户名已经存在，请更换一个&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              that.tip = <span class="string">&#x27;用户名可以使用&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      watch: &#123;</span><br><span class="line">        uname: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">          <span class="comment">// 调用后台接口验证用户名的合法性</span></span><br><span class="line">          <span class="built_in">this</span>.checkName(val);</span><br><span class="line">          <span class="comment">// 修改提示信息</span></span><br><span class="line">          <span class="built_in">this</span>.tip = <span class="string">&#x27;正在验证...&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>过滤器（filters）：</strong>允许自定义过滤器，可被用于一些常见的文本格式化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&#x27;msg&#x27;</span>&gt;</span><br><span class="line">  &lt;!-- upper 被定义为接收单个参数的过滤器函数，表达式 msg 的值将作为参数传入到函数中 --&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; msg | upper &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;!--  </span><br><span class="line">    支持级联操作</span><br><span class="line">    upper 被定义为接收单个参数的过滤器函数，表达式 msg 的值将作为参数传入到函数中。</span><br><span class="line">	然后继续调用同样被定义为接收单个参数的过滤器 lower，将 upper 的结果传递到 lower 中。</span><br><span class="line">    （即：过滤完接着过滤）</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; msg | upper | lower &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 支持属性绑定的写法 --&gt;</span><br><span class="line">  &lt;div :abc=<span class="string">&#x27;msg | upper&#x27;</span>&gt;测试数据&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">   <span class="comment">// lower 为全局过滤器     </span></span><br><span class="line">   Vue.filter(<span class="string">&#x27;lower&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val.charAt(<span class="number">0</span>).toLowerCase() + val.slice(<span class="number">1</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">     el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">     data: &#123;</span><br><span class="line">       msg: <span class="string">&#x27;&#x27;</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="comment">// 定义 filters 中的过滤器为局部过滤器 </span></span><br><span class="line">     filters: &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * upper 自定义的过滤器名字</span></span><br><span class="line"><span class="comment">      * 同理：upper 被定义为接收单个参数的过滤器函数，表达式 msg 的值将作为参数传入到函数中</span></span><br><span class="line"><span class="comment">      */</span> </span><br><span class="line">     upper: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 过滤器中一定要有返回值，这样外界使用过滤器的时候才能拿到结果</span></span><br><span class="line">       <span class="keyword">return</span> val.charAt(<span class="number">0</span>).toUpperCase() + val.slice(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>过滤器中传递参数（可多个）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">  &lt;!--</span><br><span class="line">	filterA 被定义为接收三个参数的过滤器函数。</span><br><span class="line">  	其中 message 的值作为第一个参数，</span><br><span class="line">	普通字符串 <span class="string">&#x27;arg1&#x27;</span> 作为第二个参数，表达式 arg2 的值作为第三个参数。</span><br><span class="line">  --&gt;</span><br><span class="line">  &#123;&#123; message | filterA(<span class="string">&#x27;arg1&#x27;</span>, <span class="string">&#x27;arg2&#x27;</span>) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在过滤器中，第一个参数对应的是 管道符前面的数据 n，此时对应 message</span></span><br><span class="line"><span class="comment">   * 第 2 个参数: a 对应实参 arg1 字符串</span></span><br><span class="line"><span class="comment">   * 第 3 个参数: b 对应实参 arg2 字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Vue.filter(<span class="string">&#x27;filterA&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">n,a,b</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>更多详情，请收藏本博主，持续更新……谢谢！</strong></p>
<p>当然，如果您觉得此篇对您有所帮助，想请博主喝杯咖啡，请点击下方按钮，打开您的手机扫一扫，感谢您对本博主的赏识，博主感激不尽！</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 新语法规范</title>
    <url>/JavaScript-%E6%96%B0%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JavaScript 新语法规范，从最初的 <code>ES3</code> 到 <code>ES4</code> 及现在所一直保持的 <code>ES5</code> 规范，发现其中还存在很多问题。就针对发现的一些问题，做了新语法规范的改进，也就是现在的 <code>ES6</code> 及 <code>ES7/8/9</code> 甚至 <code>ES11</code>。下面是关于我对新语法规范学习的一些总结，如果有什么好的建议或者发现一些不好、错误的地方，还希望各位大佬在下方的评论区留言，谢谢！</p>
<p>学习总结过程的代码是基于 <a href="https://gitee.com/sunny-store/javascript-new-standard">Gitee 码云仓库</a> 进行管理的，有需要的可以自行提取，可以的话，请顺便点个 <code>star</code>，谢谢！</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>全局作用域和私有作用域，这两个作用域是我们玩 JavaScript 的人都知道的，那么 <code>ES6</code> 的到来，新增加了一个概念叫<code>块级作用域</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;全局变量 a = &#x27;</span> + a)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;全局变量 a = &#x27;</span> + a)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;test 函数作用域内部变量 b = &#x27;</span> + b)</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">4</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;可以访问到全局变量 a = &#x27;</span> + a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;可以访问到变量 c = &#x27;</span> + c)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;不能访问到变量 d = &#x27;</span> + d)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果</span></span><br><span class="line"><span class="comment"> * 全局变量 a = 1</span></span><br><span class="line"><span class="comment"> * 可以访问到全局变量 a = 1</span></span><br><span class="line"><span class="comment"> * test 函数作用域内部变量 b = 2</span></span><br><span class="line"><span class="comment"> * 全局变量 a = 1</span></span><br><span class="line"><span class="comment"> * 可以访问到变量 c = 3</span></span><br><span class="line"><span class="comment"> * Uncaught ReferenceError: d is not defined</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以知道，全局变量 <code>a</code> 在任何地方都可以被访问到，函数内部变量 <code>b</code> 和 <code>c</code> 在函数内部作用域中都可以被访问到，这也正是我们所熟悉的全局作用域和私有作用域，没毛病。那么变量 <code>d</code> 被访问的时候为什么就被报错了呢？</p>
<p>相信大家都注意到了，变量 <code>d</code> 是被 <code>let</code> 进行声明定义的，这也就是我们即将要说的 <code>块级作用域</code>，顾名思义，就是含有<code>块</code>的概念，这个块指的就是 <code>&#123;&#125;</code> 大括号，大括号内的作用域就是称为块级作用域。</p>
<p>我们发现，上述代码中，if()<code>&#123;...&#125;</code> 内的变量仍然可以被其大括号外部访问到，所以块级作用域的出现也正是为了弥补 JS 的这个缺陷，用 let 进行变量声明定义，就可以形成一个块级作用域，正如上述代码中的那样，变量 d 无法被访问到。</p>
<blockquote>
<p>Tips：let 声明定义的变量也没有变量提升的概念</p>
</blockquote>
<p>全局作用域、私有作用域和块级作用域都说到了，那么剩下的就是<code>动态作用域</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">test.bind(&#123; <span class="attr">a</span>: <span class="number">10</span> &#125;)()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> * 10</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>所谓动态作用域其实就是他的作用域不固定，我们可以通过一些方式，利用 <code>this</code> 指向，通过 <code>bind</code> 的方式改变 this 的指向，从而形成动态作用域。上述代码中，第一次输出结果 1，是因为 this 指向的是全局 window，输出结果 10，是因为 test.bind 将 this 指向了 { a: 10 } 这个对象，从而输出结果 10。</p>
<h4 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h4><p>关于 let 前面讲过了挺多，这里做以下总结：</p>
<ul>
<li>let 声明的变量具有块级作用域的概念；</li>
<li>let 声明的变量没有变量提升的概念；</li>
<li>let 声明的变量名不能重复；</li>
<li>let 声明的全局变量不能用全局对象的属性来访问。</li>
</ul>
<p>const 除了具备上述 let 的特点之外，<code>const 用于定义常量</code>，这是 const 独有的特点。</p>
<blockquote>
<p>Tips：另外就是 let 和 var 均可以先声明后赋值，但 const 不行。</p>
</blockquote>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>举个例子，我们平时想要将一个数组中的某一项拿到，需要对数组进行变量，以索引的方式进行取值，比较麻烦，而解构赋值便很好的解决了这个问题。<strong>解构赋值，咬文嚼字一下就是将一个结构进行解析，解析出来的值再进行赋给对应的变量。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)	<span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以发现，等号两边的结构是一样的，都是数组，呈对应关系。等号右边便是要进行结构的 “东西” ，这个 “东西” 目前是一个数组，那么解构完了后，我们需要一个同样对应的 “东西” 去接收解构出来的细碎的小物品，一个一个的对应起来，这也就是解构赋值，其中 <code>a 对应 1，即 a = 1，b 对应 2，即 b = 2，c 对应 3，即 c = 3</code>。 下面再来看几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, [c, d]] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d)	<span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>a 对应 1，即 a = 1，b 对应 2，即 b = 2</p>
<p>因为 [c, d] 对应 [3, 4]，所以 c 对应 3，即 c = 3，d 对应 4，即 d = 4</p>
<blockquote>
<p>Tips：到来这里，有没有感觉像以前做数学题~哈哈</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, [c]] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)	<span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>a 对应 1，即 a = 1，b 对应 2，即 b = 2</p>
<p>[c] 对应 [3, 4]，因为左边只有一个接收的，所以我们只接收右边的第一个，得出 c 对应 3，即 c = 3，而右边的 4 没有对应的，所以保留。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)	<span class="comment">// 1 2 [3, 4]</span></span><br></pre></td></tr></table></figure>

<p>a 对应 1，即 a = 1，b 对应 2，即 b = 2</p>
<p>因为 c 对应 [3, 4]，所以 c  = [3, 4]，c 的值是一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d)	<span class="comment">// 1 2 [3, 4] undefined</span></span><br></pre></td></tr></table></figure>

<p>同理，一一对应，没得对应的自然就是 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d = <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d)	<span class="comment">// 1 2 [3, 4] 6</span></span><br></pre></td></tr></table></figure>

<p>同理一一对应，左边的 d 给了初值了，右边又有对应关系，那自然是覆盖了啦</p>
<p>既然数组可以，那么对象呢？一起来看看~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;sunny&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = user</span><br><span class="line"><span class="built_in">console</span>.log(name, age)	<span class="comment">// sunny 20</span></span><br><span class="line"><span class="keyword">let</span> &#123; age, name &#125; = user</span><br><span class="line"><span class="built_in">console</span>.log(name, age)	<span class="comment">// sunny 20</span></span><br></pre></td></tr></table></figure>

<p>从上述代码中发现，对象也是可以解构赋值的，而且它们的对应关系是<strong>根据 key 属性进行对应的，之前数组是通过 下标，即通过顺序进行对应的</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;sunny&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: uname, <span class="attr">age</span>: uage &#125; = user</span><br><span class="line"><span class="built_in">console</span>.log(uname, uage)	<span class="comment">// sunny 20</span></span><br></pre></td></tr></table></figure>

<p>既然我们知道了，对象的解构是通过 key 属性进行对应解构的，那么就可以利用 key 进行对对应的属性起别名，如上所示。</p>
<p>数组，对象都可以，那么类似数组的<strong>字符串</strong>可不可以呢？答案<strong>是可以的</strong>，<strong>其操作和思想和数组差不多，可以参考数组的解构赋值</strong>。</p>
<p>了解了这么多，总结一下：<strong>解构赋值，就是左边的结构对应右边的结构，左边是接收方，右边是赋予方，接收方少于赋予方，那么就是按需解构赋值；一样就是完全解构赋值，多于就是贪得无厌，对应不到的就是 undefined</strong>。</p>
<p>常见应用场景：</p>
<ul>
<li><p>默认值赋初值：定义数组某项赋初值，函数形参赋初值，函数返回值解构赋值等</p>
</li>
<li><p>异步数据请求 json 数据解构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;hello&quot;, &quot;b&quot;: &quot;world&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment">// JSON.parse(json): 把字符串转换成对应对象</span></span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = <span class="built_in">JSON</span>.parse(json)</span><br><span class="line"><span class="built_in">console</span>.log(a, b)	<span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>对于数组，我想大家再熟悉不过了，操作数组的基础就是对数组的遍历，而遍历数组的方式有很多，其中不乏传统的遍历方式，更多的是结合实际问题而做出的改进方式，也就是 ES6 新增的方式，下面一起来了解下，传统的遍历方式和 ES6 新特性下的遍历方式。</p>
<p>定义一个数组：<code>let arr = [1, 2, 3, 4, 5]</code>，下面分别以不同的方式对其进行遍历操作</p>
<h4 id="ES5-方式"><a href="#ES5-方式" class="headerlink" title="ES5 方式"></a>ES5 方式</h4><ul>
<li><p><strong>for 循环</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>forEach()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.forEach(function(currentValue, index, arr), thisValue)</span></span><br><span class="line"><span class="comment"> * function(currentValue, index, arr): 回调函数【必传】</span></span><br><span class="line"><span class="comment"> *  - currentValue: 当前元素【必须】</span></span><br><span class="line"><span class="comment"> *  - index: 当前元素的索引值【可选】</span></span><br><span class="line"><span class="comment"> *  - arr: 当前元素所属的数组对象【可选】</span></span><br><span class="line"><span class="comment"> * thisValue: 传递给函数的值一般用 &quot;this&quot; 值，如果这个参数为空，&quot;undefined&quot; 会传递给 &quot;this&quot; 值。【可选】</span></span><br><span class="line"><span class="comment"> * 注意: forEach() 对于空数组是不会执行回调函数的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem, index, array)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>for 循环</code> 和 <code>forEach()</code> 的区别：<strong>for 循环支持 break 和 continue，而 forEach() 不支持，即 forEach() 中途不能跳出循环</strong>。</p>
<ul>
<li><p><strong>map()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.forEach(function(currentValue, index, arr), thisValue)</span></span><br><span class="line"><span class="comment"> * function(currentValue, index, arr): 同上</span></span><br><span class="line"><span class="comment"> * thisValue: 同上</span></span><br><span class="line"><span class="comment"> * 注意: map() 对于空数组是不会执行回调函数的，map() 不会改变原始数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  value += <span class="number">1</span></span><br><span class="line">  <span class="comment">// console.log(value)</span></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>map()</code> 和 <code>forEach()</code> 的区别：<strong>forEach() 只是简单的遍历，而 map() 会遍历数组中的每一个元素，然后根据这个回调函数进行回调操作，将我们需要的返回值以一个新数组的形式返回，原数组不变</strong>。</p>
<ul>
<li><p><strong>filter()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.filter(function(currentValue,index,arr), thisValue): 参数介绍同上</span></span><br><span class="line"><span class="comment"> * 注意： filter() 不会对空数组进行检测，filter() 不会改变原始数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> result = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(value)</span></span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>filter()</code> 的特点：<strong>从遍历项中，利用回调函数对遍历项进行过滤筛选操作，符合条件的项以一个新数组的形式返回，原数组不变</strong>。</p>
<ul>
<li><p><strong>some()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.some(function(currentValue,index,arr),thisValue): 参数介绍、注意同上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> result = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(value)</span></span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>some()</code> 的特点：<strong>some() 方法会依次执行数组的每个元素，如果有一个元素满足条件，则返回 true , 剩余的元素不会再执行检测；如果没有满足条件的元素，则返回 false，返回的是一个布尔值，原数组不变</strong>。</p>
<ul>
<li><p><strong>every()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.every(function(currentValue,index,arr), thisValue): 参数、注意介绍同上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> result = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(value)</span></span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>every()</code> 的特点：<strong>every() 方法会依次执行数组的每个元素，如果有一个元素不满足条件，则直接返回 false , 剩余的元素不会再执行检测；如果所有的元素都满足条件，则返回 true，返回的是一个布尔值，原数组不变</strong>。</p>
<p><strong>所以：some() 方法强调的是个体，every() 方法强调的是整体</strong></p>
<ul>
<li><p><strong>reduce()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</span></span><br><span class="line"><span class="comment"> * function(total,currentValue, index,arr): 回调函数【必传】</span></span><br><span class="line"><span class="comment"> *  - total: 上一次调用回调函数的返回值，当然第一次调用的时候，即相当于初始值【必传】</span></span><br><span class="line"><span class="comment"> *  - currentValue: 当前元素【必须】</span></span><br><span class="line"><span class="comment"> *  - currentIndex: 当前元素的索引值【可选】</span></span><br><span class="line"><span class="comment"> *  - arr: 当前元素所属的数组对象【可选】</span></span><br><span class="line"><span class="comment"> * initialValue: 传递给函数的初始值【可选】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比如遍历 arr 实现求和操作</span></span><br><span class="line"><span class="comment"> *  - 0: 相当于 initialValue，用于 &#x27;和（sum）&#x27; 的起始值，如果不传，起始值就是 1</span></span><br><span class="line"><span class="comment"> * 到了第二次：pre 的值就是返回值，这个返回值源于上一次累加的结果，即 prev + cur -&gt; 0 + 1 -&gt; 返回 1</span></span><br><span class="line"><span class="comment"> * 依此类推...</span></span><br><span class="line"><span class="comment"> * 最后返回，最后累加的值，即计算结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="built_in">console</span>.log(prev)</span><br><span class="line">  <span class="comment">// 0 1 3 6 8</span></span><br><span class="line">  <span class="keyword">return</span> prev + cur</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现数组的去重</span></span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(prev) // []: 起始值，空数组</span></span><br><span class="line">  prev.indexOf(cur) === <span class="number">-1</span> &amp;&amp; prev.push(cur)</span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>for in</strong>：一般<strong>不用于</strong>遍历数组，会出现将数组原型上定义的方法也同时遍历出来，及各种问题（一般用于遍历对象）</p>
</li>
</ul>
<h4 id="ES6-方式"><a href="#ES6-方式" class="headerlink" title="ES6 方式"></a>ES6 方式</h4><ul>
<li><p><strong>find()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.find(function(currentValue, index, arr),thisValue)</span></span><br><span class="line"><span class="comment"> * 参数、注意同上 forEach</span></span><br><span class="line"><span class="comment"> * 返回值：返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> res = arr.find(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">8</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, res)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>findIndex()</strong></p>
<p>该方法同 <code>find()</code> 类似，区别在于 <code>findIndex()</code> 返回的是符合测试条件的第一个<code>数组元素索引</code>，如果没有符合条件的则返回  <code>-1</code> 。</p>
</li>
<li><p><strong>for of</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历获得数组的每一项 - 直接法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历获得数组的每一项 - 间接法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历获得数组的每一项索引值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历获得数组的每一项及其索引值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, item] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h4><p>伪数组是<code>有长度</code>，<code>能遍历</code>，<code>不能直接调用数组的 API</code> 的数组</p>
<p>伪数组特征：</p>
<ul>
<li><p>按照索引形式存储数据（索引是非负的整数）</p>
</li>
<li><p>具备一个 length 属性</p>
</li>
</ul>
<p>伪数组形式：</p>
<ul>
<li><p>arguments，于 ES6 中废除</p>
</li>
<li><p>document.querySelectorAll(‘img’)</p>
</li>
<li><p>{ 0: ‘a’, 1: ‘b’, length: ‘5’}</p>
</li>
</ul>
<h4 id="ES6-扩展"><a href="#ES6-扩展" class="headerlink" title="ES6 扩展"></a>ES6 扩展</h4><blockquote>
<p>伪数组转换成真正的数组</p>
</blockquote>
<ul>
<li><p><strong>Array.from(object（或需要转换的伪数组）, [遍历函数], [当前元素的 this 指向])</strong></p>
</li>
<li><p>作用：生成一个新数组或者将一个伪数组转换成真正的数组</p>
</li>
<li><p>应用：一般用于伪数组转换成真数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个伪数组</span></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;es6&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;es7&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;es8&#x27;</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike)</span><br><span class="line">arr.push(<span class="string">&#x27;es9&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>新数组生成方式及其方式对应的应用</p>
</blockquote>
<p>我们都知道，生成一个新数组的方式有很多种方式，传统的 <code>new Array()</code> 构建方式，当我们传入的参数只有一个的时候，代表的是构建生成一个只有长度的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<p>而传入的值有多个的时候，那么就是具有长度，并且每一项都有值的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<p>但往往第一种情况不是我们想要的，所以第二种方式就出来了</p>
<ul>
<li><p><strong>Array.of([N个数据，’,’号隔开])</strong></p>
</li>
<li><p>作用：生成指定数据项的数组</p>
</li>
<li><p>应用：将多个数据项拼接成新的数组</p>
</li>
<li><p>注意：会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个数据</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个数据</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&#x27;sunny&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123;<span class="attr">name</span>: <span class="string">&#x27;sunny&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当然，还有第三种方式，就是进行<code>填充</code></p>
<ul>
<li><p><strong>Array.fill(被填充的元素,  [ start ], [ end ])</strong></p>
</li>
<li><p>说明：start 和 end: 指定 开始位置 和 结束位置范围内的数，替换成被填充的元素；不指定则所有项替换成 被填充的元素</p>
</li>
<li><p>注意：会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// arr.fill(&#x27;sunny&#x27;, 1, 3)</span></span><br><span class="line">arr.fill(<span class="number">0</span>)	<span class="comment">// 全部替换</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>替换数组的某些元素</p>
</blockquote>
<ul>
<li><p><strong>arr.copyWithin(指定替换元素的起始位置,  [ 指定读取元素开始位置 ],  [ 指定读取元素停止位置 ])</strong></p>
</li>
<li><p>说明：替换的内容就是 <strong>读取元素开始到结束位置之间的内容</strong></p>
</li>
<li><p>注意：会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">1</span>, <span class="number">3</span>))	<span class="comment">// 1 4 5 4 5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>检测（查询）数组内是否包含某项</p>
</blockquote>
<p><code>ES5</code> 中做法是利用 <code>indexOf()</code> 进行检测，<code>ES6</code> 中利用 <code>includes()</code> 进行检测</p>
<ul>
<li><p><strong>arr.indexOf(需要查找的元素，[ 指定开始查找的位置（合法取值：0 到 stringObject.length - 1）])</strong></p>
</li>
<li><p>说明：检测（查找）有则返回对应元素所在的索引，无则返回 -1</p>
</li>
<li><p>注意：无法检测 NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">NaN</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">NaN</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>arr.includes(需要查找的元素, [ 指定开始查找的位置（默认 0，支持负数）])</strong></p>
</li>
<li><p>说明：检测（查找）有则返回 true，无则返回 false，如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索</p>
</li>
<li><p>注意：可以检测 NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>注意：这两种方法都只能用于检测基本数据类型，不能检测引用数据类型</code></p>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>对于函数的重要性，我这里就不做过多的赘述了，我们常常利用函数进行封装一些我们想要处理的功能，这时候在 ES5 中，常常有个点是必须要考虑的，那就是函数的参数，比如哪些是必传的，哪些是可选的，然后进行一些列处理，等等操作。而在 ES6 中，其新特性为我们提供了很多便利。</p>
<blockquote>
<p>函数的默认值</p>
</blockquote>
<p>假设我们要封装一个方法，这个方法有个参数是必传的，另一个是可选的，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面的参数传递中，我只传了一个实参，那么输出的结果就是：hello undefined，因为 y 的值没有传嘛，所以 y 就是一个可选的参数，就需要做处理，ES5 中处理方式呢，就是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  y = y || <span class="string">&#x27;world&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断一些 y 的值有没有传，有的话就将传递给 y 的实参赋值给 y，不然就是取它的默认值 world，而假如我们传递给 y 的是 0 呢，0 是一个 false 的布尔值含义，所以 y 还是会被赋值默认值 world，这样我们在封装函数的时候就增加了思考量，所以 ES6 针对这一问题，给出了新的赋值默认值的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y = <span class="string">&#x27;world&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;hello&#x27;</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>一看上面的代码，相比之前 ES5 的处理方式而言，就简便很多了，直接给 y 一个默认值，有传递实参就是取该实参的值，没有就是取默认值，就不需要像 ES5 中那样的做法去做判断之类的操作。除了<code>代码简洁</code>，你还会发现它的<code>代码可阅读性很强</code>，一眼看去就可以看出哪些参数是必传的，哪些是可选的。另外就是当你后期想要对这个函数进行优化的时候，省去一些参数，那么这些默认的很方便就可以进行简洁优化！ </p>
<p><strong>注意：ES6 中这样处理函数参数默认值，这默认值必须位于所有形参的最后面</strong></p>
<blockquote>
<p>实参与形参巧用解构赋值</p>
</blockquote>
<p>关于解构赋值，前面已经说的很清楚了，所以这里也不做过多的赘述，形参与实参之间传递形成一种对应关系，进行解构赋值。</p>
<blockquote>
<p>length 属性</p>
</blockquote>
<p>length ，当你看到这个，第一想到的是不是数组的长度，其实这里的 length 不是指的数组的长度，而是 <strong>函数必传参数的个数，也称函数未指定默认值参数的个数</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y = <span class="number">2</span>, z = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.length)	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>很显然，未指定默认值的参数就是 x，所以输出 1，如果都指定默认值，那就是输出 0。</p>
<blockquote>
<p>尾逗号</p>
</blockquote>
<p>尾逗号是 ES8 中在函数的参数后面新增一个逗号，作用就是 git 仓库协同开发的过程中，使得代码的改动体现的更友好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    a, </span></span></span><br><span class="line"><span class="function"><span class="params">    b, </span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符，顾名思义它是个运算符，表现形式是 <code>...</code> 三个点，相信你已经意思到这个点的含义了，没错，就是扩展！作用就是：<strong>把数组或类数组展开成用逗号隔开的值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c)	<span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">foo(...arr)</span><br></pre></td></tr></table></figure>

<p>从上面的例子中会发现，是不是有点解构赋值的感觉呢，其实不是，解构赋值要求两边的结构完全一样，但此时的结构并不一样，但 a，b，c 仍旧可以输出对应的值，这正是因为，在进行参数传递的时候，<code>...arr</code> 将数组 arr 的值展开了，那么这样的好处可以帮助我们做些什么事呢？最常见的可以说就是数组的合并了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment">// 传统 ES5 的做法</span></span><br><span class="line"><span class="comment">// Array.prototype.push.apply(arr1, arr2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的做法</span></span><br><span class="line">arr1.push(...arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)	<span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>因为 push，只能 push 单个值，所以借助展开运算符很方便的就可以进行数组的合并。当然这个并不仅仅适用于数组，试试看把一个字符串展开会是什么样呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(...str)	<span class="comment">// s u n n y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [...str]</span><br><span class="line"><span class="built_in">console</span>.log(arr)	<span class="comment">// [&quot;s&quot;, &quot;u&quot;, &quot;n&quot;, &quot;n&quot;, &quot;y&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面的结果是不是让你理解了之前说的：把数组或类数组展开成用逗号隔开的值~~</p>
<p>那么既然有扩展，那会不会有组合呢？是的，是有的，它叫 <code>rest 参数</code>，它的作用就是<strong>把逗号隔开的值组合成一个数组</strong>。下面我们来看一个例子，实现任意数的求和。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的方式 - arguments（ES6 已废除）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    sum += item</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>))		<span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))	<span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的方式 - from</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="comment">// from 将 arguments 伪数组转换成真数组</span></span><br><span class="line">  <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    sum += item</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的方式 - rest</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(args)</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  args.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    sum += item</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>从上面的方式中你会发现，是不是最后一种方式最简单、最实用呢，这也是 rest 的含义，不管你传递多少个参数，我都给你转成数组，注意是真正的数组哦，那么剩下的就是对数组进行操作了。所以这也是 rest 的一个应用场景之一：<strong>对于不确定参数的处理</strong>，下面再来看一个，部分参数确定，部分不确定的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)		<span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(args)		<span class="comment">// [2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>对于参数 x 是确定的，但剩下的是不确定的，那么把不确定的参数就是丢给 <code>...</code> 形成一个数组去处理，聪明的你应该很快就会想到，rest 是不是可以和解构赋值配合使用呢？是的，请看</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, ...y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x)	<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(y)	<span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>所以，<strong>扩展运算符与 rest 参数互为逆运算</strong>，具体使用还是得结合具体的场景。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在 ES5 中，我们定义函数有两种形式，分别是具名函数和匿名函数，具体形式相信不用我多说了，这里主要说下两者的注意项：</p>
<ul>
<li>具名函数的调用没有位置限制（一般是全局声明，有需求的地方调用）</li>
<li>匿名函数调用需要在其声明之后</li>
</ul>
<p>ES6 中对函数存在的一些问题做了改进，具体形式就是箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>一个很形象的点就是它的那个箭头，你可以这样简单的理解：<strong>箭头左边的是参数，右边的是函数体</strong>，箭头函数就是匿名函数的改造版</p>
<p>箭头函数简化的几个点：（我的建议是：不省略，统一代码风格）</p>
<ul>
<li><p>函数体只有一条语句的时候，大括号可以省略</p>
</li>
<li><p>函数的参数只有一个参数的时候，括号可以省略</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function"><span class="params">x</span> =&gt;</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>箭头函数与普通函数的区别：</p>
<ul>
<li><strong>箭头函数是匿名函数，不能作为构造函数，不能使用 new 关键字，自然也就没有原型对象</strong></li>
<li><strong>箭头函数不绑定 arguments，取而代之的是用 rest 参数</strong></li>
<li><strong>箭头函数不绑定 this（没有 this），会捕获其所在的上下文的 this 值（箭头函数外层的作用域 this），作为自己的 this 值，任何方法都改变不了其指向</strong></li>
</ul>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性的简洁写法"><a href="#属性的简洁写法" class="headerlink" title="属性的简洁写法"></a>属性的简洁写法</h4><p>其实对于属性的简洁写法就一句话：<strong>key value 同名可只写其中一个</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">24</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name,	<span class="comment">// name: name</span></span><br><span class="line">    age		<span class="comment">// age: age</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<h4 id="方法的简洁写法"><a href="#方法的简洁写法" class="headerlink" title="方法的简洁写法"></a>方法的简洁写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// ES5 写法</span></span><br><span class="line">  study_1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在学习&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ES6 写法</span></span><br><span class="line">  study_2 () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在学习&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<p>其实还是你习惯那种写法就使用哪种写法</p>
<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>属性名表达式什么意思呢，就是：<strong>对象的属性变量（表达式）化</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;school&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)	<span class="comment">// &#123;school: &quot;sunny&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看出，对象 obj 的属性 s，经过 <code>[ ]</code> 使得属性 s 变量化解析，所以得出上面的结果</p>
<h4 id="新增-Api"><a href="#新增-Api" class="headerlink" title="新增 Api"></a>新增 Api</h4><h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>作用：判断两个值是否严格相等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">2</span>, <span class="string">&#x27;2&#x27;</span>))	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>严格相等，意思就是<strong>数值和类型</strong>上都要相等，上述代码中，数字 2 和 字符串 2 肯定是不严格相等的，那么这个时候你肯定会想起 <code>===</code> ，三等也是严格相等，那么两者有什么区别呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>))	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>)			<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>))		<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>)				<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>其实也说不上什么区别，就是对于有些特殊值的情况下严等的结果会不一样</p>
<p><strong>注意：两个对象即使内容一样，但它们是不相等的，原因是每一个对象都有自己的堆内存空间</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;sunny&#x27;</span>,</span><br><span class="line">  age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;sunny&#x27;</span>,</span><br><span class="line">  age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(obj1, obj2)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p>说到这个方法之前，我们前面有说到扩展运算符，但基本都是应用于数组中，其实对象也是可以的，只不过对象不能脱离对象本质展开出来，展开出来后要么直接用 { } 内部接收要么内部接收后赋值给另一个对象或变量，所以表面上看起来，好似没什么作用与改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  b: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(...x)  	// 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; ...x &#125;)	<span class="comment">// &#123;a: 3, b: 4&#125;</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; ...x &#125;</span><br><span class="line"><span class="built_in">console</span>.log(y)			<span class="comment">// &#123;a: 3, b: 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>那么真的就没什么用吗？其实是有的，从它的表现上来看，实现了<strong>对象的浅克隆</strong></p>
<p><strong>Object.assign() 方法主要是用于对象和合并，Object.assign(目标对象，…源对象)，返回目标对象</strong></p>
<p><strong>注意：同名的属性会进行覆盖，源对象覆盖目标对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  b: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y = &#123;</span><br><span class="line">  c: <span class="number">5</span>,</span><br><span class="line">  a: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(y, x)</span><br><span class="line"><span class="built_in">console</span>.log(y)	<span class="comment">// &#123;c: 5, a: 3, b: 4&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h4><p>对于对象的遍历，直接上方式吧，没啥可多说的，let obj = { name: ‘sunny’, age: 24 }</p>
<ul>
<li><p><strong>for in</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>下面的方式均是将<code>对象转数组</code>再对数组进行遍历，从而实现对对象的遍历</p>
<ul>
<li><p><strong>Object.keys()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Object.getOwnPropertyNames()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Reflect.ownKeys( 目标对象 )</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="扩展-—-对象深浅克隆"><a href="#扩展-—-对象深浅克隆" class="headerlink" title="扩展 — 对象深浅克隆"></a>扩展 — 对象深浅克隆</h4><p>对象深浅克隆也称对象深浅拷贝，其实说白了就是 copy 一份和原来一模一样的东西出来</p>
<p>目的：<strong>可能某个操作会导致原对象的结构或数据改变，但是我们并不想原对象的结构或数据发生改变，就只好复制一个与原对象一模一样的出来操作了</strong></p>
<p>如下：一个对象中的属性值，并不一定是基本的数据类型，还可能是数组，对象，正则等等，obj1 对象中，属性名 c 的值，又是一个对象，其中对象中 x 的值还可能是一个对象，这就是所谓的多维对象或者多维数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">100</span>,</span><br><span class="line">  b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  c: &#123;</span><br><span class="line">    x: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  d: <span class="regexp">/^\d+$/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝（克隆）：只克隆第一层，即：只克隆 obj1 层，对于属性名 c 值这层或更深层不克隆</strong></p>
<p><strong>深拷贝（克隆）：全克隆</strong></p>
<blockquote>
<p>实现方式</p>
</blockquote>
<ul>
<li><p>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝实现方式 - 1</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1 &#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝实现方式 - 2</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.assign(obj2, obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝实现方式 - 3</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj1.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  obj2[key] = obj1[key]</span><br><span class="line">  <span class="comment">// 将 obj1 第一层拷贝（克隆）到 obj2 中</span></span><br><span class="line">  <span class="comment">// 那么实现深拷贝（克隆），那边对内层的对象再次进行该操作，便实现了深克隆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝实现方式 - 1</span></span><br><span class="line"><span class="comment"> *  - JSON.stringify(obj1) 将对象转换成字符串格式对象</span></span><br><span class="line"><span class="comment"> *  - JSON.parse() 字符串格式对象再变成 对象格式</span></span><br><span class="line"><span class="comment"> * 弊端：</span></span><br><span class="line"><span class="comment"> *  - 通过 JSON.stringify() 方法将对象转换成字符串，如果该对象中的属性名的值有</span></span><br><span class="line"><span class="comment"> *  - 函数、日期格式和正则等的数据值，那么会出现一些问题（即不可实现）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.stringify(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// &#123;&quot;a&quot;:100,&quot;b&quot;:[1,2,3],&quot;c&quot;:&#123;&quot;x&quot;:10&#125;,&quot;d&quot;:&#123;&#125;&#125;</span></span><br><span class="line">obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1))</span><br><span class="line"><span class="built_in">console</span>.log(obj2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝实现方式 - 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objDeedClone</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保证 obj 是一个对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测正则</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测时间日期格式</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * obj.constructor 保证传入的对象或者实例指向当前传入的 obj</span></span><br><span class="line"><span class="comment">   * 即：克隆的结果和之前保持相同的所属类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="keyword">new</span> obj.constructor()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj1.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObj[key] = obj1[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = objDeedClone(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h3><h4 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h4><p>对于<code>类</code>这个概念相信大家都很清楚，我也不过多的去赘述了。这是个面向对象编程的时代，虽然 JavaScript 是<code>基于对象</code>编程的语言，但基本不过多的去深究的话，是可以理解成面向对象编程的语言的，那么它在传统 <code>ES5</code> 中的体现是怎样的呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类：其实就是构造函数</span></span><br><span class="line"><span class="comment"> *   - 首字母一般大写，区别于普通函数</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> *   - 可以传：如，name, age 等</span></span><br><span class="line"><span class="comment"> *   - 也可以不传：这样内部属性的值就是写死的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实例属性：如下</span></span><br><span class="line"><span class="comment">   *   - 构造函数内部通过 this 定义</span></span><br><span class="line"><span class="comment">   *   - 通过 实例对象 进行获取调用</span></span><br><span class="line"><span class="comment">   *   - 不能通过 构造函数名 获取调用</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  People.count++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态属性：如下</span></span><br><span class="line"><span class="comment"> *  - 构造函数外部通过 构造函数名 定义</span></span><br><span class="line"><span class="comment"> *  - 通过 构造函数名 获取调用</span></span><br><span class="line"><span class="comment"> *  - 不能通过 实例对象 获取调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">People.count = <span class="number">0</span></span><br><span class="line"><span class="comment">// 静态方法：同理静态属性</span></span><br><span class="line">People.getCount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age) <span class="comment">// undefined，因为静态方法的 this 指向当前的构造函数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;当前共有&#x27;</span> + People.count + <span class="string">&#x27;个人&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法：同理实例属性，不过一般实例方法定义在构造函数外部的原型上</span></span><br><span class="line">People.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this) // 实例方法的 this 指向的是实例对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> People(<span class="string">&#x27;sunny&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line">p1.showName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> People(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p2)</span><br><span class="line">p2.showName()</span><br><span class="line"><span class="built_in">console</span>.log(People.count)</span><br><span class="line">People.getCount()</span><br></pre></td></tr></table></figure>

<p>了解了类这个概念和形式，那么在面向对象编程中，还有个很重要的点就是<code>继承</code>，在 ES5 中对继承的实现方式也有很多种，下面介绍三种主要的形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;名字是:&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造函数继承</p>
</blockquote>
<p>当我们 new 出 Dog 这个实例对象的时候，将通过 call 方法，将 Dog 的 this 传递到父类，让<strong>父类中的实例对象指向 Dog 这个实例对象</strong>。</p>
<p><code>理解：</code>Animal 找到了失散多年的一个儿子 Dog，那么 Dog 自然就可以用父亲的东西了</p>
<ul>
<li><p><strong>子类只能继承父类的属性</strong>，不能继承父类的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// name 属性是从父类那继承而来的</span></span><br><span class="line">  Animal.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="comment">// 子类特有属性 color</span></span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> d1 = <span class="keyword">new</span> Dog(<span class="string">&#x27;wangcai&#x27;</span>, <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(d1)</span><br><span class="line">d1.showName()	<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>原型继承</p>
</blockquote>
<p>Dog 的原型指向 Animal 的实例化对象，Dog 原型的构造函数指回 Dog</p>
<p>不理解的请自行补习 <code>原型及原型链</code> 相关的知识</p>
<ul>
<li><p><strong>子类只能继承父类的方法</strong>，不能继承父类的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dog 的原型指向 Animal 的实例化对象</span></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="comment">// Dog 原型的构造函数指回 Dog</span></span><br><span class="line">Dog.prototype.constuctor = Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d1 = <span class="keyword">new</span> Dog(<span class="string">&#x27;wangcai&#x27;</span>, <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(d1)</span><br><span class="line">d1.showName() <span class="comment">// 名字是：undefined</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>组合继承</p>
</blockquote>
<p>组合继承，顾名思义就是构造函数继承和原型继承的结合方式，这样就可以实现<strong>属性和方法都可以继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数继承</span></span><br><span class="line">  Animal.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line">Dog.prototype.constuctor = Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d1 = <span class="keyword">new</span> Dog(<span class="string">&#x27;wangcai&#x27;</span>, <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"><span class="comment">// 两者结合：组合继承</span></span><br><span class="line"><span class="built_in">console</span>.log(d1)</span><br><span class="line">d1.showName()</span><br></pre></td></tr></table></figure>

<p>了解了 ES5 对类和继承的相关概念和形式后，你的感觉是什么呢？这个就因人而异了，下面我们来看看 <code>ES6</code> 新特性中关于类与继承的概念和形式</p>
<p><code>ES6</code> 中提供了一个关键字 <code>class</code> 来帮助我们轻松定义一个类，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  showName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法：static 关键字进行声明，但是调用还是和之前 ES5 方式一样</span></span><br><span class="line">  <span class="keyword">static</span> getCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态属性：定义方式和调用方式同 ES5 一样</span></span><br><span class="line">People.count = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> People(<span class="string">&#x27;sunny&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="built_in">console</span>.log(People.count)</span><br><span class="line"><span class="built_in">console</span>.log(People.getCount())</span><br></pre></td></tr></table></figure>

<p>看起来有没有感觉很清爽呢，是的，其实这就是 ES6 带来的便利，也就是语法糖，但是 <strong>ES6 并不支持定义静态方法那样去定义定义静态属性，静态属性的定义和调用还是和之前 ES5 一样，静态方法虽然可以通过 static 关键字进行那样定义，但是调用方式还是和 ES5 一样</strong></p>
<p>当然 ES6 提供的关键字 class 不仅仅是提供定义类带来了便利，还提供了 <code>get</code> 和 <code>set</code>。<strong>get 声明一个属性是只读的，要对其进行赋值需要通过 set 进行</strong>，所以通过 get 和 set 可以进行一些业务逻辑操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为避免 set 设置值时候出现的死循环而引入的新属性</span></span><br><span class="line">    <span class="built_in">this</span>._sex = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  get sex () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._sex === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;male&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>._sex === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;female&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  set sex (val) &#123;</span><br><span class="line">    <span class="comment">// this.sex = val // 会造成死循环，设置值就会触发 set，不断设置不断触发，就死循环了</span></span><br><span class="line">    <span class="keyword">if</span> (val === <span class="number">0</span> || val === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>._sex = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> People(<span class="string">&#x27;sunny&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="comment">// 对 sex 实例属性进行赋值，触发 set 设置值</span></span><br><span class="line">p1.sex = <span class="number">5</span></span><br><span class="line"><span class="comment">// 读取 sex 属性的值，触发 get 进行读取 </span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sex)</span><br></pre></td></tr></table></figure>

<p>通过上述例子，我们可以发现，<strong>通过 get 和 set ，我们可以对其声明的属性进行一些逻辑业务操作，注意点：最后调用的属性还是 get 和 set 声明的属性（如：sex），而新引入的属性（如：_sex）是为了解决 set 赋值出现死循环的问题而引入的，所以当你希望你在设置属性和获取属性的时候，希望有一些业务逻辑操作，而不是直接去获取和设置的时候，就需要把这个属性声明一个 get 和 set</strong></p>
<p>那么在继承上呢？<code>ES6</code> 提供了个关键字 <code>extends</code> 很方便的实现了<code>继承</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, age, company) &#123;</span><br><span class="line">    <span class="comment">// 继承父类的 name age</span></span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">    <span class="built_in">this</span>.company = company</span><br><span class="line">  &#125;</span><br><span class="line">  showCompany () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.company)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c1 = <span class="keyword">new</span> Coder(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;sunny&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c1)</span><br><span class="line">c1.showName()</span><br><span class="line">c1.showCompany()</span><br><span class="line">c1.sex = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(c1.sex)</span><br><span class="line"><span class="built_in">console</span>.log(Coder.getCount())</span><br></pre></td></tr></table></figure>

<p>通过上述方式我们可以发现，子类对父类的继承是完全继承的，但是要注意的就是，<strong>静态属性的定义和获取调用还是和 ES5 一样，而静态方法的定义采取 static 关键字，获取调用还是和 ES5 一样</strong> </p>
<p>其中关于 <strong>super 关键字</strong>的注意事项，请参考阮一峰大佬写的 <a href="https://es6.ruanyifeng.com/#docs/class-extends#super-%E5%85%B3%E9%94%AE%E5%AD%97"><strong>ES6 入门教程</strong></a></p>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>我们都知道 JavaScript 原始数据类型一共有 Number、String、Boolean、null、undefined、Object（Array 和 function 都属于对象）六种，而 ES6 中又增加了一位新成员 <code>Symbol</code>，<strong>表示的是独一无二的，并不是对象，可以理解为不重复的 “字符串”</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line"><span class="built_in">console</span>.log(s2)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>独一无二嘛，肯定 s1 和 s2 不相等，所以为了区别 s1 和 s2，可以为 Symbol 添加描述：以字符串的形式传入给 Symbol()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)	<span class="comment">// Symbol(&#x27;foo&#x27;)</span></span><br><span class="line"><span class="built_in">console</span>.log(s2)	<span class="comment">// Symbol(&#x27;bar&#x27;)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>添加了描述的 Symbol，输出的也是带描述的 Symbol，这样我们就可以知道具体是哪个值，不仅输出上可以看出，字面上也可以看出。</p>
<p><strong>注意：当传入的描述是一个对象的时候，Symbol 会调用 toString 方法将对象转换成字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;imooc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(obj)</span><br><span class="line"><span class="built_in">console</span>.log(s)	<span class="comment">// Symbol([object, object])</span></span><br></pre></td></tr></table></figure>

<p>其实 Symbol 还是有为 true 的时候</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>当用 Symbol.for 去声明一个 Symbol 的时候，并所添加的描述一致的时候，所声明的 Symbol 是一样的</strong>，原因就是：以这样的方式声明的 Symbol 是一个全局的 Symbol，当你再次以 Symbol.for 去声明的时候，它首先会去全局环境下找是否有声明过这样描述的 Symbol，如果有那么你再次声明的会指向前面声明的，所以它们是一样的。（<strong>和定义位置无关，以这种方式定义的 Symbol 就是一个全局环境下的</strong>）</p>
<ul>
<li><p><strong>Symbol.keyFor</strong></p>
<p>作用：返回一个已经 <code>全局登记</code> 的 Symbol 描述</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2)) <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>常见应用场景</strong></p>
</blockquote>
<ul>
<li><p><strong>把 Symbol 作为当前对象的 key，以保证当前的 key 并不冲突</strong> </p>
<p>我们都知道，一个对象的属性是唯一的、不重复的，当我们用一个对象来存储一个班级信息的时候，班级可能存在同名但是信息不同的两个人，这样就会导致后定义的那个人就会把前一个同名的人的信息覆盖（属性和值），这样不就少了一个人嘛</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stu1 = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="keyword">const</span> stu2 = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="keyword">const</span> grade = &#123;</span><br><span class="line">  [stu1]: &#123; <span class="attr">address</span>: <span class="string">&#x27;yyy&#x27;</span>, <span class="attr">tel</span>: <span class="string">&#x27;222&#x27;</span> &#125;,</span><br><span class="line">  [stu2]: &#123; <span class="attr">address</span>: <span class="string">&#x27;zzz&#x27;</span>, <span class="attr">tel</span>: <span class="string">&#x27;333&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(grade)	<span class="comment">// &#123;李四: &#123; address: &#x27;zzz&#x27;, tel: &#x27;333&#x27; &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stu1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> stu2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> grade = &#123;</span><br><span class="line">  [stu1]: &#123; <span class="attr">address</span>: <span class="string">&#x27;yyy&#x27;</span>, <span class="attr">tel</span>: <span class="string">&#x27;222&#x27;</span> &#125;,</span><br><span class="line">  [stu2]: &#123; <span class="attr">address</span>: <span class="string">&#x27;zzz&#x27;</span>, <span class="attr">tel</span>: <span class="string">&#x27;333&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(grade) <span class="comment">// &#123;Symbol(李四): &#123;…&#125;, Symbol(李四): &#123;…&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(grade[stu1])	<span class="comment">// &#123;address: &quot;yyy&quot;, tel: &quot;222&quot;&#125; 一样可以获取对象的 value</span></span><br><span class="line"><span class="built_in">console</span>.log(grade[stu2])	<span class="comment">// &#123;address: &quot;zzz&quot;, tel: &quot;333&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对属性进行隐藏，保护属性（只是一定程度上）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;guohaoqi&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>[sym] = <span class="string">&#x27;guohaoqi.com&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>[sym]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="string">&#x27;sunny&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>对 user 进行遍历</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)	<span class="comment">// name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(user)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)	<span class="comment">// name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现 for in 和 for of 都无法遍历出 Symbol(‘guohaoqi’) 属性，在一定程度上起到了 <code>保护 / 隐藏</code> 的作用</p>
<p>但如果只要 Symbol(‘guohaoqi’) 属性，可以采用 <code>Object.getOwnPropertySymbols</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.getOwnPropertySymbols(user)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)	<span class="comment">// Symbol(guohaoqi)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者都要的话可以采用 <code>for of</code> 结合 <code>Reflect.ownKeys()</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(user)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)	<span class="comment">// name Symbol(guohaoqi)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消除重复字符串，降低代码耦合度</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span></span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Triangle&#x27;</span>:</span><br><span class="line">      area = <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Circle&#x27;</span>:</span><br><span class="line">      area = <span class="number">2</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="string">&#x27;Triangle&#x27;</span>))	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>消除 ‘Triangle’ 和 ‘Circle’ 后的改进代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  triangle: <span class="built_in">Symbol</span>(),</span><br><span class="line">  circle: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span></span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.triangle:</span><br><span class="line">      area = <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> shapeType.circle:</span><br><span class="line">      area = <span class="number">2</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(shapeType.triangle))	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>改进后的代码显然没有出现一个字符串</p>
</li>
</ul>
<h3 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h3><p>Set 和 Map 都是 ES6 新引入的新型数据结构，特点都是：<strong>存储的值都是唯一的，不重复的</strong></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><blockquote>
<p><strong>常用 API</strong></p>
</blockquote>
<ul>
<li><p>添加：<code>add</code> 、删除：<code>delete</code> 和 清空：<code>clear</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">s.add(<span class="string">&#x27;sunny&#x27;</span>).add(<span class="string">&#x27;es&#x27;</span>)	<span class="comment">// 添加，支持链式操作</span></span><br><span class="line">s.delete(<span class="number">2</span>)	<span class="comment">// 删除某个值</span></span><br><span class="line">s.clear()	<span class="comment">// 清空</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否有哪个值：<code>has</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.has(<span class="string">&#x27;sunny&#x27;</span>))	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当前 Set 有多少个值：size</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.size)	<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历：之前学到的用于遍历数组的方式，对 Set 基本都适用</p>
<p>注意：<strong>Set 中键和值是一样的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如：</span></span><br><span class="line"><span class="comment"> * set.keys(): 读取所有的 key 值</span></span><br><span class="line"><span class="comment"> * set.values(): 读取所有的 value 值</span></span><br><span class="line"><span class="comment"> * set.entries(): 读取所有的 key value 值</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>常见应用</strong></p>
</blockquote>
<ul>
<li><p>数组去重 和 合并去重</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并去重</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([...arr1, ...arr2])</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 结构 -&gt; array 结构的两种方式</span></span><br><span class="line"><span class="built_in">console</span>.log([...s])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(s))</span><br></pre></td></tr></table></figure>
</li>
<li><p>求交集 和 差集</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2)</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1.filter(<span class="function"><span class="params">item</span> =&gt;</span> s2.has(item)))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(result))	<span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2)</span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1.filter(<span class="function"><span class="params">item</span> =&gt;</span> !s2.has(item)))</span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2.filter(<span class="function"><span class="params">item</span> =&gt;</span> !s1.has(item)))</span><br><span class="line"><span class="built_in">console</span>.log([...arr3, ...arr4])	<span class="comment">// [1, 5, 6]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="扩展-WeakSet"><a href="#扩展-WeakSet" class="headerlink" title="扩展 - WeakSet"></a>扩展 - WeakSet</h4><p><code>特点：</code></p>
<ul>
<li><strong>WeakSet 只能存储对象，不能存储数字、字符串之类的</strong></li>
<li><strong>Set 常见的 API ，WeakSet 也适用，如：add，delete，has</strong></li>
<li><strong>WeakSet 不能被遍历，是一种弱引用，所以不存在垃圾回收机制</strong></li>
</ul>
<p><code>弱引用：</code><strong>相当于对 WeakSet 的引用，它不会被计入垃圾回收机制，所以不存在垃圾回收机制，所以适用于临时存放一些对象，这些对象被销毁，WeakSet 对这些对象的引用也会消失</strong></p>
<p><code>垃圾回收机制：</code><strong>计数的回收机制，假如定义一个变量，刚定义的时候结果是 0，这个值被引用一次结果就会 +1，依此类推，只要这个值结果不为 0，垃圾回收机制就不会回收这个值，也就是不会释放当前这个内存空间</strong></p>
<p><code>注意：</code><strong>因为只能存储对象，对象是引用类型，每一个对象都有自己独立开辟的空间，所以删除的时候需要注意删除对应的对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line">ws.add(<span class="number">1</span>)	<span class="comment">// Invalid value used in weak set 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  age: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">ws.add(obj1)</span><br><span class="line">ws.add(obj2)</span><br><span class="line"><span class="comment">// ws.delete(obj1)</span></span><br><span class="line"><span class="built_in">console</span>.log(ws)	<span class="comment">// WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ws.has(obj2)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map 也是类似对象一样的新型数据结构，但比对象更简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>常用 API</strong></p>
</blockquote>
<ul>
<li><p>设置值、获取值和删除值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置值 set( key, value )</span></span><br><span class="line">m.set(obj, <span class="string">&#x27;es&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取值 get( key )</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(obj))</span><br><span class="line"><span class="comment">// 删除值 delete( key )</span></span><br><span class="line">m.delete(obj)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取值的数量 和 查询值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;imooc&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">5</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 获取值的数量</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size)</span><br><span class="line"><span class="comment">// 查询值</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历</p>
<p>同 Set，但 <strong>Map 的 key 和 value 是可以不一样的</strong>，但遍历方式基本一样</p>
<p>注意：<strong>用 forEach 遍历的时候，key 和 value 的顺序是相反的，其它的是正常的</strong>，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(value, key))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>常见应用：传统对象的应用场景，Map 都适用</strong></p>
</blockquote>
<h4 id="扩展-WeekMap"><a href="#扩展-WeekMap" class="headerlink" title="扩展 - WeekMap"></a>扩展 - WeekMap</h4><p><strong>基本同 WeakSet，WeekMap 不支持 clear() 方法和 size() 方法，同样也不支持遍历，其 key 必须是一个引用类型</strong></p>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><h4 id="UniCode"><a href="#UniCode" class="headerlink" title="UniCode"></a>UniCode</h4><p>UniCode 是一种很神奇的编码，可以表示很多类型的字符，ES6 对 UniCode 进行了进一步的加强，加强点主要是对 <code>码点</code> 进行了改进和加强，传统的码点是有一定范围的：<code>0000 ~ ffff</code>，超出这个范围就会出错，转换成一个不认识的符号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">例如：\u&#123;对应码点值&#125;	<span class="comment">// 这样的好处就是，这样这个码点就不仅仅局限于那个范围了</span></span><br></pre></td></tr></table></figure>

<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串，这个在项目中用的非常的多，相比传统的字符串拼接，学了这个后，你会发现这个方便多了</p>
<p>模板字符串：用反引号去替换传统的单引号和双引号</p>
<blockquote>
<p>直接换行</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str4 = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;2&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;3&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="built_in">console</span>.log(str4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;3&lt;/li&gt;</span></span><br><span class="line"><span class="comment">// &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure>

<p>试想一下，上面这个，如果你用 + 去做字符串拼接，要写的多罗嗦，还容易出错</p>
<blockquote>
<p>含有变量或者表达式：**${ 变量名 或 表达式 }**</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">14</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">&#x27;ES&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str5 = <span class="string">`我的年龄是:<span class="subst">$&#123;a + b&#125;</span>,我在学<span class="subst">$&#123;c&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(str5)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>嵌套模板</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isLargeScreen = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> class2 = <span class="string">`icon icon-<span class="subst">$&#123;isLargeScreen() ? <span class="string">&#x27;big&#x27;</span> : <span class="string">&#x27;small&#x27;</span>&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(class2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>带标签的模板字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo(1, 2, 3, 4)</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">24</span></span><br><span class="line">foo<span class="string">`这是<span class="subst">$&#123;name&#125;</span>,他的年龄是<span class="subst">$&#123;age&#125;</span>岁`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;这是&quot;, &quot;,他的年龄是&quot;, &quot;岁&quot;, raw: Array(3)]</span></span><br><span class="line"><span class="comment">// sunny</span></span><br><span class="line"><span class="comment">// 24</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>很显然，输出结果，一方面给我们转换成了数组，另一方面变量部分做了对应输出，所以这种带标签的模板字符串，会做对应转换和输出，<strong>以变量为基准，变量前后的会按序转变为数组的项，而对应变量则输出对应的值，并且其中还包含一个 raw，这是原始字符串</strong></p>
<h4 id="新-API"><a href="#新-API" class="headerlink" title="新 API"></a>新 API</h4><ul>
<li><p><strong>String.fromCodePoint()</strong></p>
<p>作用：将对应 uniCode 码点转换成对应字符返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)) <span class="comment">// ES5: 超过范围的不能识别</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)) <span class="comment">// ES6: 超过范围的仍可识别</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>String.prototype.includes()</strong></p>
<p>作用：类似 ES5 中的 indexOf，查找对应字符串中是否包含某字符，包含返回 true，否则返回 false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">&#x27;su1&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>String.prototype.startsWith() 和 String.prototype.endsWith()</strong></p>
<p>作用：前者表示该字符串以什么字符开头，后者表示以什么字符结尾</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">&#x27;su&#x27;</span>))	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&#x27;unn&#x27;</span>))	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>String.prototype.repeat()</strong></p>
<p>作用：让指定字符串重复多少次，进行拼接返回一个新字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="comment">// 5：表示重复 5 此</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.repeat(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr)	<span class="comment">// sunnysunnysunnysunnysunn</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="字符串遍历器接口"><a href="#字符串遍历器接口" class="headerlink" title="字符串遍历器接口"></a>字符串遍历器接口</h4><p>其实就是用 for of 去遍历字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="string">&#x27;sunny&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h3><p>关于正则，其实没什么好说和需要注意的，需要了解更多的可以前往阮一峰大佬的 <a href="https://es6.ruanyifeng.com/#docs/regex">正则的扩展</a></p>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><p>关于数值，其实没什么好说和需要注意的，需要了解更多的可以前往阮一峰大佬的 <a href="https://es6.ruanyifeng.com/#docs/number">数值的扩展</a></p>
<p>幂运算符</p>
<p>ES7 新增了一个幂运算符：<code>**</code>，等同于 Math.pow()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2 底数，10 指数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> ** <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h3 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h3><p>待更新</p>
<h3 id="异步解决方案"><a href="#异步解决方案" class="headerlink" title="异步解决方案"></a>异步解决方案</h3><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 是一个 ES6 中提出的异步解决方案，比如可以避免解决异步操作出现的回调地狱问题，从而更优雅的编写异步代码，下面来看下它的基本使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise 的精髓在于状态管理</span></span><br><span class="line"><span class="comment"> * resolve: 异步操作执行成功的回调函数</span></span><br><span class="line"><span class="comment"> * reject: 异步操作执行失败的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sunny&#x27;</span>)</span><br><span class="line">        <span class="comment">// 符合某个条件，判断调用成功与否</span></span><br><span class="line">        <span class="comment">// if(...)&#123;</span></span><br><span class="line">        <span class="comment">//     resolve()</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     reject()</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// resolve(&#x27;成功&#x27;)</span></span><br><span class="line">        reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行成功，resolve() 的进一步操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行失败，reject() 的进一步操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise 是一个构造函数，需要通过 new 关键字进行实例化操作，并且支持 <code>链式编程</code>，即 <code>.then</code> 的链式调用，其中 .then 也有两个参数，第一个是：<strong>resolve() 异步操作执行成功的回调函数所进行的进一步操作，并且可以进行参数传递，如上述的 resolve(‘成功’)，.then 的第一个参数函数接收，并 res 接收入参，从而进行进一步的处理</strong>，第二个同理，<strong>reject()</strong> 的相关处理。</p>
<p>假如我有一个需求，需要实现 省 | 市 | 县 的联动，那么就可以借助 Promise 的链式操作来实现，new Promise 包裹第一个异步操作，执行 省 的选取，将选取的省，如 湖南省，作为参数传递给 .then 进行该省下的 市 级进行选取，同理县级操作，这样就保证了异步的按需顺序执行</p>
<p>当然，<strong>new Promise 包裹第一个异步操作是立即执行的</strong>，如下的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"><span class="comment">// 1 2 5 3</span></span><br></pre></td></tr></table></figure>

<p>我们假设 new Promise 里包裹的是一个异步操作且该操作会执行成功，所以自然不会走 reject() -&gt; err =&gt; { console.log(‘4’) }，但 .then 中的回调操作不会立即执行，需要等 resolve() 执行回调成功后执行，所以输出的结果是：1 2 5 3，具体的详细原因可以去了解 JavaScript 的线程机制和宏任务、微任务以及同步异步相关的操作。</p>
<blockquote>
<p>Promise 的三种状态</p>
</blockquote>
<ul>
<li><p>进行中（pending）：异步操作正在执行中的状态</p>
</li>
<li><p>成功（fulfilled）：异步操作执行结果为成功的状态</p>
</li>
<li><p>失败（rejected）：异步操作执行结果为失败的状态</p>
</li>
</ul>
<p><strong>注意：Promise 状态是不可逆的，并且是不可改变的，取决于当前的异步操作</strong></p>
<blockquote>
<p>Promise 解决（改写）回调深渊</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：一定要记得 return 一个 new Promise 进行操作</span></span><br><span class="line"><span class="comment"> * 原因：不然就是对一个空 Promise 对象进行，也就是 “脱链”，从而达不到想要的效果</span></span><br><span class="line"><span class="comment"> * 失败状态的处理：.catch 去做统一捕获处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    ajax(<span class="string">&#x27;static/a.json&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a成功&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        ajax(<span class="string">&#x27;static/b.json&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b成功&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        ajax(<span class="string">&#x27;static/c.json&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;c成功&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise 静态方法</p>
</blockquote>
<ul>
<li><p>resolve 和 reject</p>
<p>含义：当没有 Promise 实例的时候，对于相关异步结果分开操作，返回 Promise 实例进行 .then 操作</p>
<p>返回：Promise 对象，使得当我们没有 Promise 实例的时候，仍然可以调用它的实例方法，如 .then 等</p>
<p>接收：可以接收字符串等可被 Promise 对象解析的参数，也可以是一个<code>Promise</code>对象，或者是一个 thenable</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 异步操作成功</span></span><br><span class="line">            resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 异步操作失败 return &#x27;fail&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">false</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>all</p>
<p>含义：当<code>所有</code>异步操作都执行成功后才会执行 .all 这个静态方法，如果哪怕有一个失败，都不会执行 .all</p>
<p>返回：返回一个 Promise 实例</p>
<p>接收：一个数组（由多个 Promise 实例组成的数组）或别的可迭代对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">        resolve(<span class="string">&#x27;1成功&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// resolve(&#x27;2成功&#x27;)</span></span><br><span class="line">        reject(<span class="string">&#x27;2失败&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">        resolve(<span class="string">&#x27;3成功&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)	<span class="comment">// 成功，会执行并输出：[ &quot;1成功&quot;, &quot;2成功&quot;, &quot;2成功&quot; ]</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)	<span class="comment">// 失败，不会执行输出，进入 reject 或者 catch</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实际应用场景：多张图片全部上传成功提示用户 - 上传成功</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imgArr = [<span class="string">&#x27;1.jpg&#x27;</span>, <span class="string">&#x27;2.jpg&#x27;</span>, <span class="string">&#x27;3.jpg&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> promiseArr = []</span><br><span class="line">imgArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    promiseArr.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 图片上传的操作</span></span><br><span class="line">        resolve()</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all(promiseArr).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 插入数据库的操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;图片全部上传完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>race</p>
<p>介绍：使用基本同 all，区别在于，race 只要有一个异步是成功，那么就认为整体的状态是成功的，相反只要有一个异步是失败，那么就认为整体的状态是失败的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实际应用场景：加载图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载图片，可能有的成功，也有的可能失败</span></span><br><span class="line"><span class="comment"> * 设定一个超时，如：2s 内为成功，超过 2s 为失败，显示加载超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(img)</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = <span class="string">&#x27;http://www.xxx.com/xx.jpg&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="string">&#x27;图片请求超时&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([getImg(), timeout()]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p>Generator 是一种异步解决方案，但它不同于其它的异步解决方案，它可以让你的程序在执行的过程中<code>暂停</code>。</p>
<p>Generator 的两个特征：*<em>1、带有 * ，2、带有 yield 关键字*</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用 foo 这个函数的时候，你会发现控制台并没有打印输出 i 的值，这就是 Generator 的特点，需要手动的去调用执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = foo()</span><br><span class="line"><span class="built_in">console</span>.log(f.next())	<span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next())	<span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next())	<span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next())	<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过手动调用 f.next() 方法，输出的结果是生成器的迭代器对象，value 值表示输出的是当前的值，done: false 表示的是当前是否执行完，这里是未执行完</p>
<p>注意点：<strong>1、Generator 不能作为构造器函数使用；2、yield 只能在 Generator 函数内去使用</strong></p>
<p>关于 yield 关键字和 next() 函数的联系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span>(x + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span>(y / <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">12</span>)) <span class="comment">// y = 2 * 12，所以：z = 24 / 3 = 8</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">13</span>)) <span class="comment">// z = 13 x = 5 42</span></span><br></pre></td></tr></table></figure>

<p>next() 调用会去执行 yield 关键字后面的代码，所以是 6，很好理解，那么第二次调用 next()，(yield(x + 1)) 的值是多少呢？这个时候就是关键的地方了，next() 是可以进行传参的，参数对应的就是上一次 yield 关键字执行表达式返回的结果，而这里并没有传参，所以是 NaN，而传递参数的就是上述的结果，认知上可能存在很多的不一样，习惯就好了</p>
<p>通过 Generator 函数对异步操作进行管控</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建XMLHttpRequest对象</span></span><br><span class="line">    <span class="keyword">var</span> xmlhttp</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        xmlhttp = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兼容早期浏览器</span></span><br><span class="line">        xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、发送请求</span></span><br><span class="line">    xmlhttp.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line">    xmlhttp.send()</span><br><span class="line">    <span class="comment">// 3、服务端响应</span></span><br><span class="line">    xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState === <span class="number">4</span> &amp;&amp; xmlhttp.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(xmlhttp.responseText)</span><br><span class="line">            <span class="comment">// console.log(obj)</span></span><br><span class="line">            callback(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    ajax(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 一步一步的执行</span></span><br><span class="line">        getData.next(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request 三次调用 三次结果 按照我们想要的顺序执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">yield</span> request(<span class="string">&#x27;static/a.json&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">yield</span> request(<span class="string">&#x27;static/b.json&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">    <span class="keyword">let</span> res3 = <span class="keyword">yield</span> request(<span class="string">&#x27;static/c.json&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getData = gen()</span><br><span class="line">getData.next()</span><br></pre></td></tr></table></figure>

<h4 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h4><p>async / await 是 ES8 中新增的异步解决方案，相比之前的 Promise 和 Generator 来说，语义化更好，代码更简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;sunny&#x27;</span> 	<span class="comment">// 相当于 Promise.resolve(&#x27;sunny&#x27;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo())	<span class="comment">// Promise &#123;&lt;resolved&gt;: &#x27;sunny&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>既然是异步解决方案，那么它又是怎么解决异步问题的呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个异步操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 不传递参数</span></span><br><span class="line">            <span class="comment">// console.log(1)</span></span><br><span class="line">            <span class="comment">// resolve()</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 传递参数</span></span><br><span class="line">            resolve(<span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// await 后跟一个异步操作</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不传递参数</span></span><br><span class="line">    <span class="comment">// await timeout()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递参数</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> timeout()</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()	<span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

<p>在 async 函数内部声明一个 await 关键字，意思就是：等后面的异步代码执行完再执行后面的代码，其实这就是 Generator 的语法糖</p>
<p>当然，每一个异步操作不可能全是成功的，失败的处理方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// resolve(&#x27;success&#x27;)</span></span><br><span class="line">            reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// async 函数返回的是一个 Promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> timeout()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以可以结合 Promise 的实例方法进行解决</span></span><br><span class="line">foo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以其实，往往更多的时候，async / await 是结合 Promise 去解决一些异步问题的，像请求数据，应该就是最常见的异步操作，可以使用 Axios 等基于 Ajax 封装的库进行，因为像这样的库返回的也是 Promise，所以操作起来会很方便</p>
<blockquote>
<p>async / await 特点</p>
</blockquote>
<ul>
<li>async 函数返回的是一个 Promise 对象</li>
<li>await 关键字一定要使用在 async 函数内部</li>
</ul>
<h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h3><p>迭代器是一种接口机制，为各种不同的数据结构提供统一访问的机制，主要给 for of 进行，其实说白了就是：不支持遍历的数据结构，让其可遍历</p>
<p>我们先回忆一下上面的 Generator，有说到调用 next() 方法，输出的结果是生成器的迭代器对象，那么我们来实现一下这个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nextIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next() &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; arr.length ? &#123;</span><br><span class="line">                value: arr[nextIndex++],</span><br><span class="line">                done: <span class="literal">false</span></span><br><span class="line">            &#125; : &#123;</span><br><span class="line">                value: <span class="literal">undefined</span>,</span><br><span class="line">                done: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = makeIterator([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br></pre></td></tr></table></figure>

<p>通过上述的实现，我们可以看出，<strong>遍历器对象的本质就是一个指针对象</strong></p>
<p>上述对于数组 [‘a’, ‘b’, ‘c’] 而言，本身就是可迭代（遍历）的，那么它为什么可遍历呢？</p>
<p>一般我们对于一种数据结构，看其是否可遍历，主要是看其是否具有 <code>Symbol.iterator</code> ，只要你当前这个对象中 Symbol 有这个，就说明是可遍历的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> courses)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">// 固定写法</span></span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br></pre></td></tr></table></figure>

<p>所以，对于数组这种结构，它自带这个 Symbol.iterator，也就是说它自身遵循了 iterator 这个协议，自然可遍历</p>
<p>常见遵循了 iterator 这个接口协议的数据结构</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>arguments 伪数组</li>
<li>DOM 对象（NodeList）</li>
</ul>
<p>所以想让一种不可遍历的数据结构变成可遍历的，就得让他遵循 iterator 这个接口协议，即这个 Tips</p>
<blockquote>
<p>Tips</p>
<p>可迭代协议：是否具有 Symbol.iterator，有 -&gt; 可迭代，无 -&gt; 不可迭代</p>
<p>迭代器协议：当前结构必须符合：return { next(){ return{value, done} }}，见上述实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可遍历数据结构</span></span><br><span class="line"><span class="keyword">let</span> courses = &#123;</span><br><span class="line">    allCourse: &#123;</span><br><span class="line">        frontend: [<span class="string">&#x27;ES&#x27;</span>, <span class="string">&#x27;小程序&#x27;</span>, <span class="string">&#x27;Vue&#x27;</span>, <span class="string">&#x27;React&#x27;</span>],</span><br><span class="line">        backend: [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;SpringBoot&#x27;</span>],</span><br><span class="line">        webapp: [<span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;IOS&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成可遍历</span></span><br><span class="line">courses[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遵循可迭代协议 Symbol.iterator</span></span><br><span class="line">    <span class="keyword">let</span> allCourse = <span class="built_in">this</span>.allCourse</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Reflect</span>.ownKeys(allCourse)</span><br><span class="line">    <span class="comment">// 遵循迭代器协议 return &#123; next()&#123; return&#123;value, done&#125; &#125;&#125;</span></span><br><span class="line">    <span class="keyword">let</span> values = []</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next() &#123;</span><br><span class="line">            <span class="keyword">if</span> (!values.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (keys.length) &#123;</span><br><span class="line">                    values = allCourse[keys[<span class="number">0</span>]]</span><br><span class="line">                    keys.shift()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: !values.length,</span><br><span class="line">                value: values.shift()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历测试</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> courses) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么要这样做？很简单，降低代码的耦合度，使得代码的公用性和可维护性更好</p>
<p>扩展 - Generator 实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 Generator 实现的好处，Generator 帮我们实现了 next()，具备了 value 和 done</span></span><br><span class="line">courses[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> allCourse = <span class="built_in">this</span>.allCourse</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Reflect</span>.ownKeys(allCourse)</span><br><span class="line">    <span class="keyword">let</span> values = []</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!values.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys.length) &#123;</span><br><span class="line">                values = allCourse[keys[<span class="number">0</span>]]</span><br><span class="line">                keys.shift()</span><br><span class="line">                <span class="keyword">yield</span> values.shift()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">yield</span> values.shift()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> courses) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块化-Module"><a href="#模块化-Module" class="headerlink" title="模块化 Module"></a>模块化 Module</h3><p>至于模块化是什么，它解决了什么问题，我这里就不做过多赘述了，这里主要是针对 ES6 的模块化规范</p>
<p>导出模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 1 - 逐个导出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 导出常量（变量同理）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="comment">// 导出方法（函数）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br><span class="line"><span class="comment">// 导出对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;es&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    showName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;obj&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 2 - 统一导出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> &#123; a, b, sum, obj, People &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 3 - export default 单个导出和统一导出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; a, b, sum, obj, People &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 4 - export default 导出 与 export 导出结合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br></pre></td></tr></table></figure>

<p>导入模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 1 和 2，接收方式</span></span><br><span class="line"><span class="comment"> * 逗号分隔多个模块</span></span><br><span class="line"><span class="comment"> * as: 起别名，突破注意点 1 的限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; a <span class="keyword">as</span> aa, b, sum, obj, People &#125; <span class="keyword">from</span> <span class="string">&#x27;模块路径&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 3，接收方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> aa <span class="keyword">from</span> <span class="string">&#x27;模块路径&#x27;</span>	<span class="comment">// 单个</span></span><br><span class="line"><span class="keyword">import</span> mod <span class="keyword">from</span> <span class="string">&#x27;模块路径&#x27;</span>	<span class="comment">// 统一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 4，接收方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> add, &#123; str &#125; <span class="keyword">from</span> <span class="string">&#x27;模块路径&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意点</p>
<ul>
<li>使用 export 关键字导出一个模块的时候，导入的模块名要和导出的模块名需要一致，如：b</li>
<li>使用了 as 关键字进行起别名，那么原来的名字就不能用了，如：aa</li>
<li>使用 export default 导出，导入的模块名要和导出的模块名不需要一致，导入的时候，模块名规范命名即可</li>
<li>使用 export default 导出，export default 一个文件内只能使用一次（出现一次）</li>
</ul>
<p><strong>更多详情，请收藏本博主，持续更新……谢谢！</strong></p>
<p>当然，如果您觉得此篇对您有所帮助，想请博主喝杯咖啡，请点击下方按钮，打开您的手机扫一扫，感谢您对本博主的赏识，博主感激不尽！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习笔记</title>
    <url>/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>好记性不如烂笔头</p>
<p>学习，总结，收获，成长 </p>
<h3 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML ~ 5"></a>HTML ~ 5</h3><h4 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h4><h5 id="1-1、常见的标签"><a href="#1-1、常见的标签" class="headerlink" title="1.1、常见的标签"></a>1.1、常见的标签</h5><table>
<thead>
<tr>
<th align="center">常用标签名称</th>
<th align="center">标签</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标题</td>
<td align="center"><code>&lt;h1&gt;&lt;/h1&gt; ~~ &lt;h6&gt;&lt;/h6&gt;</code></td>
</tr>
<tr>
<td align="center">段落</td>
<td align="center"><code>&lt;p&gt;&lt;/p&gt;</code></td>
</tr>
<tr>
<td align="center">水平线</td>
<td align="center"><code>&lt;hr /&gt;</code></td>
</tr>
<tr>
<td align="center">换行</td>
<td align="center"><code>&lt;br /&gt;</code></td>
</tr>
<tr>
<td align="center">文本格式化</td>
<td align="center"><code>&lt;pre&gt;&lt;/pre&gt;</code></td>
</tr>
<tr>
<td align="center">文字斜体</td>
<td align="center"><code>&lt;i&gt;&lt;/i&gt;</code>、<code>&lt;em&gt;&lt;/em&gt;</code></td>
</tr>
<tr>
<td align="center">加粗</td>
<td align="center"><code>&lt;b&gt;&lt;/b&gt;</code>、<code>&lt;strong&gt;&lt;/strong&gt;</code></td>
</tr>
<tr>
<td align="center">下标、上标</td>
<td align="center"><code>&lt;sub&gt;</code> 、<code>&lt;sup&gt;</code></td>
</tr>
<tr>
<td align="center">下划线</td>
<td align="center"><code>&lt;ins&gt;</code></td>
</tr>
<tr>
<td align="center">删除线</td>
<td align="center"><code>&lt;del&gt;</code></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>关于标签这一块，不做过多的列举。具体请看：<a href="https://www.w3school.com.cn/index.html">W3C</a></p>
<h5 id="1-2、表格"><a href="#1-2、表格" class="headerlink" title="1.2、表格"></a>1.2、表格</h5><p><strong>注意：</strong>不适合页面布局，适合数据布局</p>
<p>表格的基本结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表格开始 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表格标题，居中显示 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">caption</span>&gt;</span>...<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- tr 行标签 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 表格头，内容剧中，加粗显示 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">th</span>&gt;</span>......<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- td 单元格 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">td</span>&gt;</span>......<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			......</span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">td</span>&gt;</span>......<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			......</span><br><span class="line">		<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			......</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 表格结束 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>表格结构划分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">caption</span>&gt;</span>...<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表格的头（放标题之类的内容） --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表格的主体（放数据主体） --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">th</span>&gt;</span>主体<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表格的脚（放表格的脚注） --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">th</span>&gt;</span>脚注<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表格操作：合并单元格</p>
<ul>
<li>跨行合并：rowspan</li>
<li>跨列合并：colspan</li>
<li>合并思想：将多个内容合并的时候，就会有多于的东西，把它删掉</li>
<li>合并公式：删除的个数 = 合并的个数 – 1</li>
<li>合并顺序：先上 后下 先左 后右</li>
</ul>
<h5 id="1-3、列表"><a href="#1-3、列表" class="headerlink" title="1.3、列表"></a>1.3、列表</h5><p>列表主要有：有序列表、无序列表和自定义列表</p>
<p>有序列表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span>	</span><br><span class="line">	......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>无序列表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span>	</span><br><span class="line">	......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义列表：标题+描述内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>定义列表项<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>列表项描叙<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>定义列表项<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>列表项描述<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">	......</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>1、自定义列表中，多个 dd 对应一个 dt；2、建议有序、无序标签后只放 li 标签，其它标签放 li 内</p>
<h5 id="1-4、表单"><a href="#1-4、表单" class="headerlink" title="1.4、表单"></a>1.4、表单</h5><p>通过一个注册案例直接学习表单，简单明了，通俗易懂。</p>
<p><strong>数据交互：name 的属性值为 key，value 的属性值为 value，组成键值对的形式与服务端进行交互</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  form: 表单域标签</span></span><br><span class="line"><span class="comment">  input: 重点，具体查看官方文档</span></span><br><span class="line"><span class="comment">  label: 作用是增加用户体验，for 属性规定与哪个表单元素绑定（for 属性值 = 表单元素 id 的属性值）</span></span><br><span class="line"><span class="comment">	&lt;label for=&quot;username&quot;&gt;账号：&lt;/label&gt;</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;</span></span><br><span class="line"><span class="comment">  textarea: 多行文本域标签</span></span><br><span class="line"><span class="comment">  select: 下拉菜单（可通过 optgroup 进行分组）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">width</span>=<span class="string">&quot;800&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span> <span class="attr">alian</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">caption</span>&gt;</span>青春不常在，抓紧谈恋爱<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">td</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                    radio: 单选框</span></span><br><span class="line"><span class="comment">                      - 默认情况下，单选框不会互斥</span></span><br><span class="line"><span class="comment">					- 互斥条件：都设置一个 name 属性，且属性值相同</span></span><br><span class="line"><span class="comment">                      - 默认选中：添加 checked 属性，且属性名和属性值一样，可以简写，如下所示</span></span><br><span class="line"><span class="comment">						- 但是在 xhtml 中不能简写，需要写：checked = &quot;checked&quot;</span></span><br><span class="line"><span class="comment">					- value=&quot;male&quot;，即：name 的属性值</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/man.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;男&quot;</span>&gt;</span> 男</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/women.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;女&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span> 女</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">td</span>&gt;</span>生日<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;请选择年&quot;</span>&gt;</span>请选择年<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1990&quot;</span>&gt;</span>1990<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1991&quot;</span>&gt;</span>1991<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;请选择月&quot;</span>&gt;</span>请选择月<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;请选择日&quot;</span>&gt;</span>请选择日<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;01&quot;</span>&gt;</span>01<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;02&quot;</span>&gt;</span>02<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>所在地区<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;湖南&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>婚姻状况<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;status&quot;</span>&gt;</span> 已婚</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;status&quot;</span>&gt;</span> 未婚</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学历<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;本科&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>月薪<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;999999999&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">td</span>&gt;</span>手机号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18888888888&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">           	<span class="tag">&lt;<span class="name">td</span>&gt;</span>昵称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;王富贵&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>喜欢的类型<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 同理 radio 单选框 --&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;likec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lolita&quot;</span>&gt;</span>萝莉</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;likec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;charming&quot;</span>&gt;</span>妩媚</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;likec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sexy&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span>性感</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;likec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ripe&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span>成熟</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;likec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yangboy&quot;</span>&gt;</span>小鲜肉</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;likec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;styleman&quot;</span>&gt;</span>型男</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">           	<span class="tag">&lt;<span class="name">td</span>&gt;</span>自我介绍<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">           	<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;introduce&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>你是个什么样子的人？<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">           	<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我同意注册条款<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="1-5、三大标签"><a href="#1-5、三大标签" class="headerlink" title="1.5、三大标签"></a>1.5、三大标签</h5><blockquote>
<p>块级标签：独占一行，可设置宽高等属性</p>
</blockquote>
<p>常见：h1~h6，p，div，ul，ol， li 等</p>
<p>特点：</p>
<ul>
<li>总是从新行开始</li>
<li>高度、行高、外边距以及内边距等都是可以控制</li>
<li>宽度默认是容器的 100%</li>
<li>可以容纳内联元素和其它块级元素</li>
</ul>
<blockquote>
<p>行内标签：不占独立区域，不可设置宽高等属性</p>
</blockquote>
<p>常见：a，span，del，em，strong，ins 等</p>
<p>特点：</p>
<ul>
<li>和相邻行内元素在一行上</li>
<li>宽、高无效，但水平方向的 padding 和 margin 可以设置，垂直方向的无效</li>
<li>默认宽度就是它本身内容的宽度</li>
<li>行内元素只能容纳文本或其它行内元素</li>
</ul>
<blockquote>
<p>行内块标签：可设置宽高等</p>
</blockquote>
<p>常见：img，input，td 等</p>
<p>特点：</p>
<ul>
<li><p>和相邻行内（行内块）元素在一行上，但是之间会有空白缝隙</p>
</li>
<li><p>默认宽度就是它本身内容的宽度</p>
</li>
<li><p>高度、行高、外边距以及内边距等都是可以控制</p>
</li>
</ul>
<blockquote>
<p>三者之间的转换方式</p>
</blockquote>
<ul>
<li><p>块转行内：display: inline</p>
</li>
<li><p>行内转块：display: block</p>
</li>
<li><p>块、行内转行内块：display: inline-block</p>
</li>
</ul>
<h5 id="1-6、语义化标签"><a href="#1-6、语义化标签" class="headerlink" title="1.6、语义化标签"></a>1.6、语义化标签</h5><table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">语义化含义</th>
<th align="center">标签</th>
<th align="center">语义化含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">header</td>
<td align="center">头部</td>
<td align="center">nav</td>
<td align="center">导航</td>
</tr>
<tr>
<td align="center">article</td>
<td align="center">内容</td>
<td align="center">section</td>
<td align="center">块级</td>
</tr>
<tr>
<td align="center">aside</td>
<td align="center">侧边栏</td>
<td align="center">footer</td>
<td align="center">尾部</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>在 <code>IE9</code> 浏览器中，需要把语义化标签都转换为 <code>块级元素</code></p>
<h5 id="1-7、多媒体标签"><a href="#1-7、多媒体标签" class="headerlink" title="1.7、多媒体标签"></a>1.7、多媒体标签</h5><h6 id="1-7-1、audio-音频"><a href="#1-7-1、audio-音频" class="headerlink" title="1.7.1、audio - 音频"></a>1.7.1、audio - 音频</h6><blockquote>
<p>支持格式：ogg、mp3 和 wav</p>
</blockquote>
<ul>
<li><p>兼容性问题处理</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./media/snow.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多个 source,多个音频文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="1-7-2、video-视频"><a href="#1-7-2、video-视频" class="headerlink" title="1.7.2、video - 视频"></a>1.7.2、video - 视频</h6><blockquote>
<p>支持格式：ogg、mp4 和 webm</p>
</blockquote>
<ul>
<li>兼容性问题处理（同 audio）</li>
</ul>
<h6 id="1-7-3、总结"><a href="#1-7-3、总结" class="headerlink" title="1.7.3、总结"></a>1.7.3、总结</h6><ul>
<li>音频标签与视频标签使用基本一致</li>
<li>在不同浏览器下情况不同，存在兼容性问题</li>
<li>谷歌浏览器把音频和视频标签的自动播放都禁止了，添加 <code>muted</code> 标签可以自己播放</li>
</ul>
<h3 id="CSS-3"><a href="#CSS-3" class="headerlink" title="CSS ~ 3"></a>CSS ~ 3</h3><h4 id="1、基础知识-1"><a href="#1、基础知识-1" class="headerlink" title="1、基础知识"></a>1、基础知识</h4><h5 id="1-1、样式引用"><a href="#1-1、样式引用" class="headerlink" title="1.1、样式引用"></a>1.1、样式引用</h5><p>样式引用的优先级：行内 &gt; 内部 &gt; 导入/链入外部样式</p>
<p><strong>注意：</strong>链入外部样式采取就近原则（近 html 元素：即近 <code>&lt;body&gt;</code> ）</p>
<ul>
<li><p>内部样式（嵌入样式）：写在<code>&lt;head&gt;&lt;/head&gt;</code>标签内</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;内部样式&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>样式加载：与 html 文件同时加载</p>
</li>
<li><p>行内样式：在开始标签内添加 style 样式属性</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;color:red;&quot;&gt;内容&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>样式加载：与 html 文件同时加载</p>
</li>
<li><p>外部样式：把 css 样式代码写在独立的一个文件中，再将这个 xx.css 文件引入 html 中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;xx.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>样式加载：与 html 文件同时加载</p>
</li>
<li><p>导入式：@import</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	<span class="keyword">@import</span> url(<span class="string">&quot;xx.css&quot;</span>);	<span class="comment">/* 位于 style 中第一行 */</span></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>样式加载：html 文件加载完，再加载样式</p>
</li>
</ul>
<h5 id="1-2、选择器"><a href="#1-2、选择器" class="headerlink" title="1.2、选择器"></a>1.2、选择器</h5><p>关于 CSS 的选择器不做过多赘述，详情具体参见：<a href="https://www.w3school.com.cn/css/index.asp">CSS 选择器</a></p>
<ul>
<li><p>属性选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择具有 disabled 属性的 button 元素 */</span></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-attr">[disabled]</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: default</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择具有 type 属性且属性值等于 search 的元素 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=search]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配具有 class 属性且属性值以 black 开头的元素 */</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-attr">[class^=black]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配具有 class 属性且属性值以 black 结尾的元素 */</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-attr">[class$=black]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: lightsalmon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配具有 class 属性且属性值中含有 black 的元素 */</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-attr">[class*=black]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: lightseagreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构伪类选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匹配父元素中的第一个子元素 li */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightseagreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配父元素中的最后一个 li 元素 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightcoral;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配父元素中第 n 个子元素 li */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nth-child(n) 详解</span></span><br><span class="line"><span class="comment"> * 1、本质上就是选中第 n 个子元素</span></span><br><span class="line"><span class="comment"> * 2、n: 可以是数字、关键字、公式</span></span><br><span class="line"><span class="comment"> * 3、n: 如果是数字，就是选中第几个</span></span><br><span class="line"><span class="comment"> * 4、常见的关键字: even 偶数、odd 奇数</span></span><br><span class="line"><span class="comment"> * 5、常见公式(如果 n 是公式，则从 0 开始计算)</span></span><br><span class="line"><span class="comment"> *   2n、2n+1、5n ...</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nt-of-type: 选择指定类型的元素</span></span><br><span class="line"><span class="comment"> * nth-child: 选择父元素里面的第几个子元素，不管是第几个类型</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>伪元素选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ::before: 在元素内部的前面插入内容</span></span><br><span class="line"><span class="comment"> * ::after: 在元素内部的后面插入内容</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意事项：</span></span><br><span class="line"><span class="comment"> * 1、必须有 content 属性</span></span><br><span class="line"><span class="comment"> * 2、创建的是一个元素，但是属于行内元素</span></span><br><span class="line"><span class="comment"> * 3、权重: 1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加字体图标 */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">220px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">22px</span>;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid lightseagreen;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;\ea50&#x27;</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;icomoon&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>兄弟选择器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * + : 选中相邻的一个</span></span><br><span class="line"><span class="comment"> * ~ : 选中相邻的全部</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">.first + li &#123;…&#125;</span><br><span class="line"></span><br><span class="line">.first ~ li &#123;…&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-3、三大特性"><a href="#1-3、三大特性" class="headerlink" title="1.3、三大特性"></a>1.3、三大特性</h5><p>层叠性：样式冲突，以最后书写样式为准</p>
<ul>
<li>口诀：长江后浪推前浪，前浪死在沙滩上</li>
</ul>
<p>继承性：子标签继承父标签的部分样式</p>
<ul>
<li>特点：color 和 text-，font-，line- 开头的均可继承</li>
<li>理解：子承父业</li>
<li>优点：简化代码，降低 css 样式的复杂性</li>
<li>口诀：龙生龙，凤生凤，老鼠的儿子生来会打洞</li>
</ul>
<p>优先级</p>
<ul>
<li><p>!important 声明最高</p>
</li>
<li><p>行内样式 &gt; 内部样式 &gt; 外部样式</p>
</li>
<li><p>ID选择器 &gt; class选择器 &gt; 标签选择器 &gt; 通配符</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原则：权值相同，就近原则；不同，高者优先</span></span><br><span class="line"><span class="comment"> * 权值规则</span></span><br><span class="line"><span class="comment"> *   1、统计不同选择器的个数</span></span><br><span class="line"><span class="comment"> *   2、每类选择器的个数乘以相应权值</span></span><br><span class="line"><span class="comment"> *   3、把所有的值相加得出选择器的权值</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">#main div.warning h2 &#123;…&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Id:1		 class:1		标签:2</span></span><br><span class="line"><span class="comment"> * 1*100=100	1*10=10		2*1=2</span></span><br><span class="line"><span class="comment"> * 权值：100 + 10 + 2 = 112</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-4、盒子模型"><a href="#1-4、盒子模型" class="headerlink" title="1.4、盒子模型"></a>1.4、盒子模型</h5><p>盒子模型是 CSS 三大必须精通的模块之一</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200728233036.png"> </p>
<blockquote>
<p>属性介绍</p>
</blockquote>
<p>宽度：width    |    高度：height</p>
<p>最大宽度：max-width    |    最小宽度：min-width</p>
<p>边框缩写：border: 宽度 样式 颜色    |    圆角边框：border-radius</p>
<p>内边距：值不能设置负值</p>
<ul>
<li><p>padding: 值1     // 四个方向都为 值1</p>
</li>
<li><p>padding: 值1    值2    // 上下 = 值1，左右 = 值2</p>
</li>
<li><p>padding: 值1    值2    值3    // 上 = 值1，左右 = 值2，下 = 值3</p>
</li>
<li><p>padding: 值1    值2    值3    值4    // 上 = 值1，右 = 值2，下 = 值3， 左 = 值4</p>
</li>
</ul>
<p>外边距：值可正可负（值设置同 padding）</p>
<blockquote>
<p>盒模型的种类</p>
</blockquote>
<p>CSS 3 中为了优化盒模型，解决宽度偏差带来的错位问题，可以通过 box-sizing 来指定盒模型</p>
<p>方式：通过指定 content-box、border-box 来改变盒子大小的计算方式</p>
<ul>
<li><p>W3C 标准盒模型：content-box，width 和 height = 内容的宽高</p>
</li>
<li><p>CSS3 盒模型：border-box，width 和 height = 内容的宽度 + border 和 padding</p>
</li>
</ul>
<p><strong>注意：</strong>CSS3 盒模型中，如果添加了padding和border,那么真正放置内容的区域会减小</p>
<p>优缺点：</p>
<ul>
<li>标准盒模型，增加了像素的计算负担，降低了开发效率</li>
<li>C3 盒模型，页面结构更加稳固</li>
</ul>
<blockquote>
<p>常见问题</p>
</blockquote>
<p>问题一：外边距合并并引发外边距塌陷（嵌套盒子）</p>
<p>说明：垂直方向，两个相邻元素都设置外边距，外边距会发生合并，合并后外边距高度 = 两个发生合并外边距的高度中的最大值</p>
<p>外边距合并问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200728233255.png"> </p>
<p>外边距塌陷问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200728233341.png"> </p>
<p>解决方式：触发形成 BFC</p>
<blockquote>
<p>几个技巧</p>
</blockquote>
<p>技巧一：外边距实现盒子水平居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 满足两个条件:</span></span><br><span class="line"><span class="comment"> * 1、必须是块级元素</span></span><br><span class="line"><span class="comment"> * 2、盒子必须指定了宽度</span></span><br><span class="line"><span class="comment"> * 注意：文字居中，text-align: center，其中 0 为像素，可根据需求指定多少</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="selector-class">.header</span> &#123; <span class="attribute">width</span>: <span class="number">960px</span>; <span class="attribute">margin</span>: <span class="number">0</span> auto &#125;</span><br></pre></td></tr></table></figure>

<p>技巧二：实现盒子水平垂直居中的4种方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html,</span><br><span class="line">        body &#123;</span><br><span class="line">            height: 100%;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            line-height: 48px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            font-size: 16px;</span><br><span class="line">            border: 1px solid lightblue;</span><br><span class="line">            background: lightcyan;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* body &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125; */</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方式 1 : 定位 1 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 缺陷：需要知道盒子的具体宽高，但盒子的宽高可能是动态的（自适应，JS控制等） */</span></span></span><br><span class="line">        /* .box &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            margin-top: -100px;</span><br><span class="line">            margin-left: -250px;</span><br><span class="line">        &#125; */</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方式 2 : 定位 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 缺陷：盒子必须得有宽高，缺一不可 */</span></span></span><br><span class="line">        /* .box &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            margin: auto;</span><br><span class="line">        &#125; */</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方式 3 : 定位 3 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 好处：不需要宽高 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 缺陷：兼容性不是很好 */</span></span></span><br><span class="line">        /* .box &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translate(-50%, -50%);</span><br><span class="line">        &#125; */</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方式 4 : 弹性盒模型 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 缺陷：兼容性不好 */</span></span></span><br><span class="line">        body &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items: center;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 原则：不谈兼容性，目前来说，基本不考虑兼容性了，那种还拿兼容说事的公司，可以不去了 */</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        box 盒子在 body 水平垂直居中</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>技巧三：关于插入图片和背景图片的处理</p>
<p>插入图片（img）</p>
<ul>
<li><p>更改大小：width 和 height</p>
</li>
<li><p>更改位置：margin 或 padding 盒模型，因为插入图片可以当作盒模型处理</p>
</li>
</ul>
<p>背景图片</p>
<ul>
<li>更改大小：background-size</li>
<li>更改位置：background-position</li>
</ul>
<h5 id="1-5、浮动"><a href="#1-5、浮动" class="headerlink" title="1.5、浮动"></a>1.5、浮动</h5><p>概念：指设置了浮动属性的元素会脱离标准流的控制，移动到其父元素中指定位置的过程</p>
<p>方式：选择器 { float: 属性值; }</p>
<ul>
<li>left: 左浮动    |    right: 右浮动    |    none: 不浮动</li>
</ul>
<p>目的：为了让多个块级元素同一行显示</p>
<p>特性：</p>
<ul>
<li><p>脱离标准流，不占位置，会影响标准流</p>
</li>
<li><p>浮动元素总是找离它最近的父级元素对齐，但不会超出内边距范围</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200728233440.png"> </p>
</li>
<li><p>浮动的元素排列位置，跟上一个元素（块级）有关系</p>
<p>如果上一个元素有浮动，则 A 元素顶部会和上一个元素的顶部对齐</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200728233504.png"> </p>
<p>如果上一个元素是标准流，则 A 元素顶部会和上一个元素的低部对齐</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200728233509.png"> </p>
<p>结论：一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其它子级都需要浮动，这样才能一行对齐显示</p>
</li>
<li><p>元素添加浮动后，元素会具有行内块元素的特性（元素添加浮动后，元素会具有行内块元素的特性来显示相应的浮动）</p>
</li>
</ul>
<p>总结：浮 | 漏 | 特</p>
<ul>
<li>浮：加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面</li>
<li>漏：加了浮动的盒子，不占位置，它原来的位置给了标准流的盒子</li>
<li>特：特别注意，首先浮动的盒子需要和标准流的父级搭配使用，其次浮动可以使元素显示模式体现为行内块特性</li>
</ul>
<blockquote>
<p>清除浮动</p>
</blockquote>
<p>原理：把浮动的盒子圈到里面，让父盒子闭合出口和入口不然它们出来影响其它元素</p>
<p>本质：为了解决父级元素因为子级浮动引起内部高度为 0 的问题</p>
<p>方式：</p>
<ul>
<li><p>clear 属性：选择器 { clear: 属性值; }</p>
</li>
<li><p>额外标签法：在浮动元素末尾添加一个空标签，如：<code>&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;</code></p>
</li>
<li><p>触发 BFC</p>
</li>
<li><p>after 伪元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 兼容 IE6/7 */</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>content: ”.” 里面尽量跟一个小点，或者其它，尽量不要为空，否则火狐 7.0 前的版本会生成空格</p>
</li>
<li><p>before 和 after 双伪元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>BFC</p>
</blockquote>
<p>概念：块级格式化上下文，官方话语就不多说介绍了</p>
<p>目的：形成一个完整独立的空间，让空间里的子元素不会影响到外面的布局</p>
<p>设置 CSS 样式触发 BFC：</p>
<ul>
<li>float 不为 none（就是要有浮动）</li>
<li>position 不为 relative 和 static</li>
<li>overflow 为 auto scroll 和 hidden</li>
<li>display 为 table-cell 或 inline-block</li>
</ul>
<h5 id="1-6、定位"><a href="#1-6、定位" class="headerlink" title="1.6、定位"></a>1.6、定位</h5><p>定位属性：定位模式 和 边偏移</p>
<ul>
<li>定位模式：static    |    relative    |    absolute    |    fixed</li>
<li>边偏移：top    |    bottom    |    left    |    right</li>
</ul>
<blockquote>
<p>定位模式</p>
</blockquote>
<ul>
<li><p>静态定位：static</p>
<p>指定：position: static;</p>
<p>特点：所有元素的默认定位方式，默认标准流</p>
</li>
<li><p>相对定位：relative</p>
<p>指定：position: relative;</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200801190131.png"> </p>
<p>基点：以<strong>自己的左上角为基点</strong>移动（相对于自己来移动位置）</p>
<p>特点：</p>
<ul>
<li><p><strong>不脱标</strong>，盒子仍在<strong>标准流</strong>中</p>
</li>
<li><p>通过边偏移移动位置，但是<strong>原来所占的位置，继续占有</strong></p>
</li>
</ul>
</li>
<li><p>绝对定位：absolute</p>
<p>指定：position: absolute;</p>
<p>基点：</p>
<ul>
<li><p>若<strong>父级没有</strong>定位：以<strong>浏览器当前屏幕</strong>为准对齐</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200801190146.png"></p>
</li>
<li><p>若<strong>父级有</strong>定位：将依据<strong>最近的已经定位（绝对、固定或相对定位）的父元素（祖先）</strong>进行定位</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200801190154.png"></p>
</li>
</ul>
<p>特点：<strong>完全脱标，完全不占位置</strong></p>
</li>
<li><p><strong>注意：</strong>如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位</p>
</li>
<li><p>固定定位：fixed</p>
<p>指定：position: fixed;</p>
<p>基点：以<strong>浏览器窗口作为参照物</strong></p>
<p>特点：</p>
<ul>
<li><p>固定定位的元素<strong>跟父亲没有任何关系，只认浏览器</strong></p>
</li>
<li><p>固定定位<strong>完全脱标</strong>，<strong>不占有位置</strong>，<strong>不随着滚动条滚动</strong></p>
</li>
</ul>
</li>
<li><p>叠放次序：z-index</p>
<p>概念：当对多个元素同时设置定位时，定位元素之间有可能会发生重叠</p>
<p>指定：z-index: 2</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200801190551.png"> </p>
<p>说明：</p>
<ul>
<li><p>z-index 的默认值是 0，取值越大，定位元素在层叠元素中越居上</p>
</li>
<li><p>如果取值相同，则根据书写顺序，后来居上</p>
</li>
<li><p>后面数字一定不能加单位</p>
</li>
<li><p>只有相对定位，绝对定位和固定定位有此属性</p>
</li>
</ul>
</li>
<li><p>子绝父相（常用技巧）：子级是绝对定位的话，父级要用相对定位</p>
</li>
</ul>
<h5 id="1-7、页面布局"><a href="#1-7、页面布局" class="headerlink" title="1.7、页面布局"></a>1.7、页面布局</h5><p><strong>版心</strong></p>
<p>指网页中主体内容所在的区域（一般在浏览器窗口中水平居中显示，常见宽度 1200px）</p>
<p><strong>布局流程</strong></p>
<ul>
<li>确定页面的版心（可视区）</li>
<li>分析页面中的行模块，以及每个行模块中的列模块</li>
<li>制作 HTML 结构</li>
<li>CSS 初始化，然后运用盒子模型的原理，通过 DIV + CSS 布局来控制页面的各个模块</li>
</ul>
<p><strong>几大经典布局</strong></p>
<h4 id="2、2D-效果"><a href="#2、2D-效果" class="headerlink" title="2、2D 效果"></a>2、2D 效果</h4><h5 id="2-1、二维坐标系"><a href="#2-1、二维坐标系" class="headerlink" title="2.1、二维坐标系"></a>2.1、二维坐标系</h5><p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/article/20200801225825.png"> </p>
<h5 id="2-2、阴影效果"><a href="#2-2、阴影效果" class="headerlink" title="2.2、阴影效果"></a>2.2、阴影效果</h5><p><strong>文字阴影：text-shadow: X-Offset Y-Offset Blur Color</strong></p>
<p>说明：</p>
<ul>
<li>X-Offset：阴影的水平偏移距离，其值为正值时阴影向右偏移反之向左偏移</li>
<li>Y-Offset：阴影的垂直偏移距离，其值为正值时阴影向下偏移反之向上偏移</li>
<li>Blur：阴影的模糊程度，其值不能是负值，如果值越大阴影越模糊，反之阴影越清晰，值为0则无阴影模糊</li>
<li>Color：阴影的颜色，其可以使用 rgba 色</li>
</ul>
<p><strong>边框阴影：box-shadow: h-shadow v-shadow blur spread color inset</strong></p>
<p>说明：同文字阴影</p>
<ul>
<li><p>spread：阴影的尺寸，值越大，扩散面积越大</p>
</li>
<li><p>inset：外部阴影改为内部阴影</p>
</li>
</ul>
<h5 id="2-3、圆角"><a href="#2-3、圆角" class="headerlink" title="2.3、圆角"></a>2.3、圆角</h5><h5 id="2-4、渐变"><a href="#2-4、渐变" class="headerlink" title="2.4、渐变"></a>2.4、渐变</h5><ul>
<li>线性渐变：指沿着某条直线朝一个方向产生渐变效果</li>
<li>径向渐变：从一个中心点开始沿着四周产生渐变效果</li>
</ul>
<h5 id="2-5、过渡"><a href="#2-5、过渡" class="headerlink" title="2.5、过渡"></a>2.5、过渡</h5><h5 id="2-6、变换"><a href="#2-6、变换" class="headerlink" title="2.6、变换"></a>2.6、变换</h5><blockquote>
<p>translate - 位移</p>
</blockquote>
<ul>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(<span class="selector-tag">x</span>, <span class="selector-tag">y</span>)</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">n</span>)</span><br><span class="line"><span class="selector-tag">transfrom</span>: <span class="selector-tag">translateY</span>(<span class="selector-tag">n</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、最大优点: 不影响其他元素的位置</span></span><br><span class="line"><span class="comment"> * 2、百分比单位: 是相对于本身的宽度和高度来进行计算的</span></span><br><span class="line"><span class="comment"> * 3、行内标签没有效果</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightseagreen;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="comment">/* 水平垂直移动 100px */</span></span><br><span class="line">  <span class="comment">/* transform: translate(100px, 100px); */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 水平移动 100px */</span></span><br><span class="line">  <span class="comment">/* transform: translate(100px, 0) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 垂直移动 100px */</span></span><br><span class="line">  <span class="comment">/* transform: translate(0, 100px) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 水平移动 100px */</span></span><br><span class="line">  <span class="comment">/* transform: translateX(100px); */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 垂直移动 100px */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">100px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>rotate - 旋转</p>
</blockquote>
<ul>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 单位是：deg */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(度数)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置旋转中心点 */</span></span><br><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">x</span> <span class="selector-tag">y</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rotate - 旋转</span></span><br><span class="line"><span class="comment"> * 1、角度为正时，顺时针; 角度为负时，逆时针</span></span><br><span class="line"><span class="comment"> * 2、默认旋转的中心点是元素的中心点</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置旋转中心点</span></span><br><span class="line"><span class="comment"> * 1、参数 x 和 y 用空格隔开</span></span><br><span class="line"><span class="comment"> * 2、默认旋转的中心点是元素的中心点(50%, 50%) 或 (center, center)</span></span><br><span class="line"><span class="comment"> * 3、还可以给 x y 设置像素或者方位名词(top、bottom、left、right、center)</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>scale - 缩放</p>
</blockquote>
<ul>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(<span class="selector-tag">x</span>, <span class="selector-tag">y</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、参数 x 和 y 用逗号隔开</span></span><br><span class="line"><span class="comment"> * 2、最大优势: 可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="comment">/* 注意，数字是倍数的含义，所以不需要加单位 */</span></span><br><span class="line">	<span class="comment">/* transform: scale(2, 2) */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 实现等比缩放，同时修改宽与高 */</span></span><br><span class="line">	<span class="comment">/* transform: scale(2) */</span></span><br><span class="line">   </span><br><span class="line">	<span class="comment">/* 小于 1 就等于缩放*/</span></span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>skew - 倾斜</p>
</blockquote>
<blockquote>
<p>以上综合写法</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、同时使用多个转换，格式：transform: translate() rotate() scale() skew()</span></span><br><span class="line"><span class="comment"> * 2、顺序会影响到转换的效果(先旋转会改变坐标轴方向)</span></span><br><span class="line"><span class="comment"> * 3、当同时有位移或者其他属性的时候，要将位移放到最前面</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">200px</span>, <span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">360deg</span>) <span class="built_in">scale</span>(<span class="number">1.2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、动画"><a href="#3、动画" class="headerlink" title="3、动画"></a>3、动画</h4><h5 id="3-1、基本使用"><a href="#3-1、基本使用" class="headerlink" title="3.1、基本使用"></a>3.1、基本使用</h5><ul>
<li>先定义动画</li>
<li>在调用定义好的动画</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义动画 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> 动画名称 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动画序列: 0% 是动画的开始，100 % 是动画的完成, 这样的规则就是动画序列</span></span><br><span class="line"><span class="comment">     * 动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数</span></span><br><span class="line"><span class="comment">     * 用百分比来规定变化发生的时间，或用 from 和 to，等同于 0% 和 100%</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用动画( 谁用动画，谁调用 ) */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">	<span class="comment">/* 调用动画 */</span></span><br><span class="line">    <span class="attribute">animation-name</span>: 动画名称;</span><br><span class="line"> 	<span class="comment">/* 持续时间 */</span></span><br><span class="line"> 	<span class="attribute">animation-duration</span>: 持续时间；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2、常见属性"><a href="#3-2、常见属性" class="headerlink" title="3.2、常见属性"></a>3.2、常见属性</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">  <span class="comment">/* 动画名称 */</span></span><br><span class="line">  <span class="attribute">animation-name</span>: move;</span><br><span class="line">  <span class="comment">/* 动画花费时长 */</span></span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="comment">/* 动画速度曲线, 默认值: ease */</span></span><br><span class="line">  <span class="attribute">animation-timing-function</span>: ease;</span><br><span class="line">  <span class="comment">/* 动画等待多长时间执行 */</span></span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">  <span class="comment">/* 规定动画播放次数 infinite: 无限循环 */</span></span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">  <span class="comment">/* 是否逆行播放 */</span></span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">  <span class="comment">/* 动画结束之后的状态 */</span></span><br><span class="line">  <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 规定动画是否暂停或者播放 */</span></span><br><span class="line">  <span class="comment">/* 常和鼠标经过等其他配合使用 */</span></span><br><span class="line">  <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简写说明</span></span><br><span class="line"><span class="comment"> * 1、简写属性里面不包含: animation-paly-state</span></span><br><span class="line"><span class="comment"> * 2、当同时有位移或者其他属性的时候，要将位移放到最前面</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">name</span> <span class="selector-tag">duration</span> <span class="selector-tag">timing-function</span> <span class="selector-tag">delay</span> <span class="selector-tag">iteration-count</span> <span class="selector-tag">direction</span> <span class="selector-tag">fill-mode</span></span><br></pre></td></tr></table></figure>

<h4 id="4、3D转换"><a href="#4、3D转换" class="headerlink" title="4、3D转换"></a>4、3D转换</h4><h5 id="4-1、基本介绍"><a href="#4-1、基本介绍" class="headerlink" title="4.1、基本介绍"></a>4.1、基本介绍</h5><h6 id="4-1-1、特点"><a href="#4-1-1、特点" class="headerlink" title="4.1.1、特点"></a>4.1.1、特点</h6><ul>
<li>近大远小</li>
<li>物体和面遮挡不可见</li>
</ul>
<h6 id="4-1-2、三维坐标系"><a href="#4-1-2、三维坐标系" class="headerlink" title="4.1.2、三维坐标系"></a>4.1.2、三维坐标系</h6><ul>
<li><p>x 轴：水平向右  –  <strong>注意：x 轴右边是正值，左边是负值</strong></p>
</li>
<li><p>y 轴：垂直向下  –  <strong>注意：y 轴下面是正值，上面是负值</strong></p>
</li>
<li><p>z 轴：垂直屏幕  –  <strong>注意：往外边的是正值，往里面的是负值</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824202524.png"> </p>
<h5 id="4-2、位移"><a href="#4-2、位移" class="headerlink" title="4.2、位移"></a>4.2、位移</h5><h6 id="4-2-1、语法"><a href="#4-2-1、语法" class="headerlink" title="4.2.1、语法"></a>4.2.1、语法</h6><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* x、y、z 分别指要移动的轴的方向的距离 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate3d</span>(<span class="selector-tag">x</span>, <span class="selector-tag">y</span>, <span class="selector-tag">z</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate3d</span>(100<span class="selector-tag">px</span>, 100<span class="selector-tag">px</span>, 0)</span><br></pre></td></tr></table></figure>

<h5 id="4-3、透视"><a href="#4-3、透视" class="headerlink" title="4.3、透视"></a>4.3、透视</h5><h6 id="4-3-1、介绍"><a href="#4-3-1、介绍" class="headerlink" title="4.3.1、介绍"></a>4.3.1、介绍</h6><ul>
<li>如果想要网页产生 <code>3D</code> 效果就需要透视(理解成 <code>3D</code> 物体投影的 <code>2D</code> 平面上)</li>
<li>实际上模仿人类的视觉位置，可视为安排一直眼睛去看</li>
<li>透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离</li>
<li>距离视觉点越近的在电脑平面成像越大，越远成像越小</li>
<li>透视的单位是像素( px )</li>
</ul>
<h6 id="4-3-2、重点说明"><a href="#4-3-2、重点说明" class="headerlink" title="4.3.2、重点说明"></a>4.3.2、重点说明</h6><ul>
<li><p><strong>透视需要写在被视察元素的父盒子上面</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 结构 */</span></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 样式 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="comment">/* 写在父盒子上面 */</span></span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">1000px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824202740.png"> </p>
<blockquote>
<p>d：视距，指人的眼睛到屏幕的距离</p>
<p>z： z 轴，z 轴越大(正值)，看到的物体就越大</p>
</blockquote>
</li>
<li><p><code>translateZ</code> 与 <code>perspecitve</code> 的区别</p>
<blockquote>
<p><code>perspecitve</code> 给父级进行设置，<code>translateZ</code> 给子元素进行设置不同的大小</p>
</blockquote>
</li>
</ul>
<h5 id="4-4、旋转"><a href="#4-4、旋转" class="headerlink" title="4.4、旋转"></a>4.4、旋转</h5><ul>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * transform: rotateX(45deg) -- 沿着 x 轴正方向旋转 45 度</span></span><br><span class="line"><span class="comment"> * transform: rotateY(45deg) -- 沿着 y 轴正方向旋转 45 度</span></span><br><span class="line"><span class="comment"> * transform: rotateZ(45deg) -- 沿着 z 轴正方向旋转 45 度</span></span><br><span class="line"><span class="comment"> * transform: rotate3d(x, y, z, 45deg) -- 沿着自定义轴旋转 45 deg 为角度</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x, y, z 表示旋转轴的矢量，是标识你是否希望沿着该轴进行旋转，最后一个标识旋转的角度</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>rotateX — 左手准则</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左手的手拇指指向 x 轴的正方向</span></span><br><span class="line"><span class="comment"> * 其余手指的弯曲方向就是该元素沿着 x 轴旋转的方向</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824202827.png"></p>
<ul>
<li><p>rotateY — 左手准则</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左手的拇指指向 y 轴的正方向</span></span><br><span class="line"><span class="comment"> * 其余的手指弯曲方向就是该元素沿着 y 轴旋转的方向(正值)</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824202838.png"></p>
<h5 id="4-5、3D呈现"><a href="#4-5、3D呈现" class="headerlink" title="4.5、3D呈现"></a>4.5、3D呈现</h5><ul>
<li><p><code>transform-style</code></p>
</li>
<li><p>说明</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制子元素是否开启三维立体环境</span></span><br><span class="line"><span class="comment"> * flat: 默认值，不开启</span></span><br><span class="line"><span class="comment"> * preserve-3d: 开启</span></span><br><span class="line"><span class="comment"> * 代码写给父级，但是影响的是子盒子</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5、常见问题与技巧"><a href="#5、常见问题与技巧" class="headerlink" title="5、常见问题与技巧"></a>5、常见问题与技巧</h4><h5 id="5-1、常见问题"><a href="#5-1、常见问题" class="headerlink" title="5.1、常见问题"></a>5.1、常见问题</h5><p><strong>问题 1：</strong><code>display</code>、<code>visibility</code> 和 <code>overflow</code> 三者的区别（面试题）</p>
<ul>
<li><p>display：强调显示</p>
</li>
<li><p>display: none，隐藏对象</p>
</li>
<li><p>display: block，除了转换成块级元素之外，同时还有显示元素的意思</p>
</li>
</ul>
<p>特点：<strong>隐藏之后，不再保留位置</strong></p>
<ul>
<li>visibility：强调可见性</li>
<li>visibility: visible，显示</li>
<li>visibility: hidden，隐藏</li>
</ul>
<p>特点：<strong>隐藏之后，继续保留原有位置</strong></p>
<ul>
<li>overflow：强调溢出</li>
<li>overflow: hidden，不显示超过对象尺寸的内容，超出的部分隐藏掉</li>
</ul>
<p><strong>问题 2：</strong>为什么图片底部会有一条白色缝隙？（面试题）</p>
<p>原因：图片的默认对齐是以文字的基线对齐的</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200801194833.png"></p>
<p>解决：改变图片，使得图片不与基线对齐，与底线对齐即可</p>
<h5 id="5-2、常用技巧"><a href="#5-2、常用技巧" class="headerlink" title="5.2、常用技巧"></a>5.2、常用技巧</h5><p><strong>技巧 1：</strong>溢出的文字隐藏</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">	<span class="attribute">text-overflow</span>:ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><h4 id="1、基础知识-2"><a href="#1、基础知识-2" class="headerlink" title="1、基础知识"></a>1、基础知识</h4><h5 id="1-1、兼容处理"><a href="#1-1、兼容处理" class="headerlink" title="1.1、兼容处理"></a>1.1、兼容处理</h5><blockquote>
<p>兼容移动端主流浏览器，处理 <code>Webkit</code> 内核浏览器即可</p>
</blockquote>
<h5 id="1-2、视口"><a href="#1-2、视口" class="headerlink" title="1.2、视口"></a>1.2、视口</h5><ul>
<li><p>布局视口，视觉视口 和 理想视口，重点关注：理想视口</p>
</li>
<li><p>理想视口：将布局视口的宽度，通过 <code>meta</code> 标签修改为视觉视口</p>
</li>
<li><p>代码体现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * width: 设置宽度是设备的宽度</span><br><span class="line"> * initial-scale: 初始缩放比</span><br><span class="line"> * max/minimum: 最大最小缩放比</span><br><span class="line"> * user-scalable: 用户是否可以缩放</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-3、二倍图"><a href="#1-3、二倍图" class="headerlink" title="1.3、二倍图"></a>1.3、二倍图</h5><ul>
<li><p>原因：一张图片放手机上显示会按照物理像素比进行缩放，所以准备的图片需要比实际需要的大 2 倍</p>
</li>
<li><p>目的：避免图片模糊</p>
</li>
<li><p>扩展：多倍图，3/4/…等倍数，具体看实际需求</p>
</li>
<li><p>目标：上述主要争对插入图，背景图看下面介绍</p>
</li>
<li><p>背景缩放</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位: 长度|百分比|cover|contain</span></span><br><span class="line"><span class="comment"> * cover: 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域</span></span><br><span class="line"><span class="comment"> * contain: 把背景图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</span></span><br><span class="line"><span class="comment"> * 目标: 主要是正对背景图片的处理</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">background-size</span>: 背景图片宽度 背景图片高度;</span><br></pre></td></tr></table></figure>
</li>
<li><p>背景精灵图</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、将精灵图等比例缩放为原来的一半</span></span><br><span class="line"><span class="comment"> * 2、根据缩放后的精灵图进行选取测量</span></span><br><span class="line"><span class="comment"> * 3、注意: 代码里 background-size, 也要写明宽度原来的一半</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-4、开发"><a href="#1-4、开发" class="headerlink" title="1.4、开发"></a>1.4、开发</h5><ul>
<li><p>形式：移动端页面单独做（主流）或者响应式开发（费时、麻烦）</p>
</li>
<li><p>样式初始化：推荐 <code>normalize.css</code></p>
</li>
<li><p>盒模型选择</p>
<blockquote>
<p>传统模式宽度计算: 盒子的宽度 = CSS中设置的width + border + padding</p>
<p>CSS3盒子模型: 盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*CSS3 盒子模型（IE 盒模型）*/</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*传统盒子模型（W3C 盒模型）*/</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择 */</span></span><br><span class="line">移动端可以全部使用 <span class="selector-tag">CSS3</span> 盒子模型</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">PC</span> 端如果完全需要兼容，就用传统模式，如果不考虑兼容性，就选择 <span class="selector-tag">CSS3</span> 盒子模型</span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 点击高亮 设置为 transparent 完成透明 */</span></span><br><span class="line"><span class="selector-tag">-webkit-tap-highlight-color</span>: <span class="selector-tag">transparent</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在移动端浏览器默认的外观在 iOS 上加上这个属性才能给按钮和输入框自定义样式 */</span></span><br><span class="line"><span class="selector-tag">-webkit-appearance</span>: <span class="selector-tag">none</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 禁用长按页面时的弹出菜单 */</span></span><br><span class="line"><span class="selector-tag">-webkit-touch-callout</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、页面布局方案"><a href="#2、页面布局方案" class="headerlink" title="2、页面布局方案"></a>2、页面布局方案</h4><blockquote>
<p>移动端单独制作</p>
</blockquote>
<ul>
<li><p>流式布局（百分比布局）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100%</span><br><span class="line"><span class="comment">/* 避免因为 无限缩放/放大 而导致变形 */</span></span><br><span class="line"><span class="selector-tag">max-width</span>: 960<span class="selector-tag">px</span>（具体视情况定值）;</span><br><span class="line"><span class="selector-tag">min-width</span>: 320<span class="selector-tag">px</span>（具体视情况定值）;</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex 弹性布局（强烈推荐）</p>
<blockquote>
<p>原理</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、任何一个容器 都可以指定为 flex 布局</span></span><br><span class="line"><span class="comment"> * 2、当为父盒子设为 flex 布局后，子元素的 float、clear 和 vertical-align 属性将失效</span></span><br><span class="line"><span class="comment"> * 3、采用 Flex 布局的元素，称为 Flex 容器，它的所有子元素自动成为容器成员，称为 Flex 项目</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">总结: 通过给父盒子添加<span class="selector-tag">flex</span>属性，来控制子盒子的位置和排列方式</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常见父属性</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认主轴: x, 默认侧轴: y, 元素是跟着主轴来排列的</span></span><br><span class="line"><span class="comment"> * 主轴侧轴可以设置</span></span><br><span class="line"><span class="comment"> * 具体查文档</span></span><br><span class="line"><span class="comment"> * 注意: 使用之前确定好谁是主轴</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="selector-tag">flex-direction</span>: 设置主轴的方向</span><br><span class="line"><span class="selector-tag">justify-content</span>: 设置主轴上的子元素排列方式</span><br><span class="line"><span class="selector-tag">flex-wrap</span>: 设置子元素是否换行</span><br><span class="line"><span class="selector-tag">align-content</span>: 设置侧轴上的子元素的排列方式（多行）</span><br><span class="line"><span class="selector-tag">align-items</span>: 设置侧轴上的子元素排列方式（单行）</span><br><span class="line"><span class="selector-tag">flex-flow</span>: 复合属性，相当于同时设置了 <span class="selector-tag">flex-direction</span> 和 <span class="selector-tag">flex-wrap</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常见子属性</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义子项目分配 剩余空间，用 flex 来表示占多少份数</span></span><br><span class="line"><span class="comment"> * 剩余空间: 就是若干个子盒子中除了给了固定宽度/高度之外剩余的空间</span></span><br><span class="line"><span class="comment"> * 注意: 分配的是剩余空间</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="selector-tag">flex</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* 默认值 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性</span></span><br><span class="line"><span class="comment"> * 默认值为 auto, 表示继承父元素的 align-items 属性，如果没有父元素, 则等同于 stretch</span></span><br><span class="line"><span class="comment"> * 注意: 允许单个项目</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">flex-end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义项目的排列顺序</span></span><br><span class="line"><span class="comment"> * 数值越小，排列越靠前</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="selector-tag">order</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* 默认值 0 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>less + rem + 媒体查询布局</p>
<blockquote>
<p>rem 和 em</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * em: 相对于父元素字体大小</span></span><br><span class="line"><span class="comment"> * rem: 相对于根元素( html )字体大小</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">   <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">   <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">10em</span>; <span class="comment">/* 10 * 12px = 120px */</span></span><br><span class="line">   <span class="attribute">width</span>: <span class="number">10rem</span>; <span class="comment">/* 10 * 14px = 140px */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>媒体查询</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @media开头, 注意@符号</span></span><br><span class="line"><span class="comment"> * mediatype: 媒体类型, all | print | screen</span></span><br><span class="line"><span class="comment"> * and|not|only: 关键字, 相当于 且 | 非 | 仅</span></span><br><span class="line"><span class="comment"> * media feature: 媒体特性必须有小括号包含, width | max-width | min-width</span></span><br><span class="line"><span class="comment"> * 书写规范: 从小到大 or 从大到小</span></span><br><span class="line"><span class="comment"> * 注意: 媒体类型 和 关键字 以及 媒体特性的单位 &quot;px&quot; 不能省略 </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feature) &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>less 基础</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、变量</span></span><br><span class="line"><span class="comment"> * 形式: @变量名: 值;</span></span><br><span class="line"><span class="comment"> * 规范: 必须有@为前缀, 不能包含特殊字符, 不能以数字开头, 大小写敏感</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">@color: pink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、编译</span></span><br><span class="line"><span class="comment"> * 插件: Easy LESS</span></span><br><span class="line"><span class="comment"> * 使用: 编写的 less 文件，保存便会自动生成一个同名的 css 文件</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、嵌套</span></span><br><span class="line"><span class="comment"> * 子元素的样式直接写到父元素里面</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">/* css 写法 */</span></span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* less 写法 */</span></span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    .logo &#123;</span><br><span class="line">       <span class="selector-tag">width</span>: 300<span class="selector-tag">px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 伪类/伪元素/交集嵌套:  需要 &amp; 连接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  &amp;:hover&#123;</span><br><span class="line">      <span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4、运算</span></span><br><span class="line"><span class="comment"> * 对象: 任何数字、颜色或者变量</span></span><br><span class="line"><span class="comment"> * 符号: 加（+）、减（-）、乘（*）、除（/）</span></span><br><span class="line"><span class="comment"> * 单位: 两数参与运算，相同结果取同单位, 不同则取第一个数的单位</span></span><br><span class="line"><span class="comment"> * 规则: 同数学, 先乘除后加减，有括号先算括号</span></span><br><span class="line"><span class="comment"> * 注意: 运算符中间左右有个空格隔开, 例如: 1px + 5</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">/* Less 里面写 */</span></span><br><span class="line">@witdh: 10px + 5;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: @witdh solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 css */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">15px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>适配方案</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 1</span></span><br><span class="line"><span class="comment"> * less + 媒体查询 + rem</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">动态设置 <span class="selector-tag">html</span> 标签的 <span class="selector-tag">font-size</span> 大小</span><br><span class="line">1、假设设计稿是 750<span class="selector-tag">px</span> <span class="selector-tag">-</span>&gt; 页面元素值（<span class="selector-tag">px</span>）</span><br><span class="line">2、假设我们把整个屏幕划分为 15 等份（划分标准不一可以是 20 份也可以是 10 等份）</span><br><span class="line">3、每一份作为 html 字体大小，这里就是 750px / 15 = 50px（屏幕宽度 / 划分的份数）</span><br><span class="line">4、那么在 320px 设备的时候，字体大小为 320px / 15 = 21.33px</span><br><span class="line">5、用 页面元素的大小 除以 不同的 <span class="selector-tag">html</span> 字体大小 会发现他们比例还是相同的</span><br><span class="line">比如:</span><br><span class="line">以 750<span class="selector-tag">px</span> 为标准设计稿</span><br><span class="line">一个 100*100 像素的页面元素在 750px 屏幕下, 就是 100 / 50 = 2rem, 即 2rem*2rem, 比例是 1:1</span><br><span class="line">总结:</span><br><span class="line">页面元素的 rem 值 = 页面元素值（px）/（屏幕宽度 / 划分的份数）</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 2（推荐）</span></span><br><span class="line"><span class="comment"> * flexible.js + rem</span></span><br><span class="line"><span class="comment"> * flexible.js: 移动端适配库</span></span><br><span class="line"><span class="comment"> * 插件: cssrem -&gt; px 转换 rem</span></span><br><span class="line"><span class="comment"> * 插件好处: 代替 less 的简便换算</span></span><br><span class="line"><span class="comment"> * 插件默认: font-size: 16px</span></span><br><span class="line"><span class="comment"> * 插件默认值改变: 点开 vs code 设置（用户区） -&gt; 更多操作 -&gt; 打开 settings.json -&gt; 配置 settings.json -&gt; 搜索 cssroot -&gt; 配置 &quot;cssrem.rootFontSize&quot;（左边不要修改）-&gt; 点击 复制到设置, 到右边修改 -&gt; 改成你需求的值 -&gt; 重启 vs code</span></span><br><span class="line"><span class="comment"> * 注意: 如果当屏幕大于 750px 的时候希望不要再去重置 html 字体, 所以要自己通过媒体查询设置一下, 并且要把权重提到最高</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">/* 媒体查询设置 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">750px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="comment">/* !important 提权到最高 */</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">75px</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">好处: 再也不需要再写不同屏幕的媒体查询</span><br><span class="line">原理: 把当前设备划分为 10 等份，但是不同设备下，比例还是一致的</span><br><span class="line">比如:</span><br><span class="line">当前设计稿是 750px, 那么只需要把 html 文字大小设置为 75px (750px / 10) 就可以</span><br><span class="line">总结:</span><br><span class="line">页面元素的 rem 值 = 页面元素值（px） / 75, 剩余的，让 flexible.js 去算</span><br></pre></td></tr></table></figure>
</li>
<li><p>混合布局</p>
</li>
</ul>
<blockquote>
<p>响应式</p>
</blockquote>
<ul>
<li>媒体查询</li>
<li>BootStrap</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h4 id="1、基础语法"><a href="#1、基础语法" class="headerlink" title="1、基础语法"></a>1、基础语法</h4><h5 id="1-1、变量"><a href="#1-1、变量" class="headerlink" title="1.1、变量"></a>1.1、变量</h5><ul>
<li><p>概念：程序在内存中申请的一块用来存放数据的空间</p>
</li>
<li><p>使用及注意方面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var [变量名] = 值（ 声明 + 赋值 + 初始化 ）</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时声明多个变量，用 &quot;,&quot; 隔开</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖性</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">18</span>;</span><br><span class="line">x = <span class="number">81</span></span><br><span class="line"><span class="built_in">console</span>.log(x)	<span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只声明, 不赋值</span></span><br><span class="line"><span class="keyword">var</span>  x;</span><br><span class="line"><span class="built_in">console</span>.log (x);	<span class="comment">// undefined</span></span><br><span class="line">原因: </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不声明, 只赋值</span></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log (x);	<span class="comment">// 10</span></span><br><span class="line">原因: </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不声明, 不赋值, 直接使用</span></span><br><span class="line"><span class="built_in">console</span>.log (x);	<span class="comment">// 报错</span></span><br><span class="line">原因: </span><br></pre></td></tr></table></figure>
</li>
<li><p>命名规范</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、由字母、数字、下划线、美元符号组成;</span></span><br><span class="line"><span class="comment"> * 2、严格区分大小写;</span></span><br><span class="line"><span class="comment"> * 3、不能以数字开头;</span></span><br><span class="line"><span class="comment"> * 4、不能是关键字、保留字;</span></span><br><span class="line"><span class="comment"> * 5、变量名必须有意义;</span></span><br><span class="line"><span class="comment"> * 6、遵守驼峰命名法.</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-2、数据类型"><a href="#1-2、数据类型" class="headerlink" title="1.2、数据类型"></a>1.2、数据类型</h5><p><strong>Number</strong></p>
<ul>
<li><p>整数、小数、负数、进制</p>
</li>
<li><p>最大值：Number.MAX_VALUE，最小值：Number.MIN_VALUE</p>
</li>
<li><p>特殊值：NaN，代表一个非数值，即非有效数字（NaN 和谁都不相等，包括自己）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * isNaN([value])</span></span><br><span class="line"><span class="comment"> * 作用: 判断该值是不是一个非数字</span></span><br><span class="line"><span class="comment"> * true: 不是有效数字</span></span><br><span class="line"><span class="comment"> * false: 是有效数字</span></span><br><span class="line"><span class="comment"> * 原理: 先检测 value 是否为数字，是则输出 false，不是则进行数据类型转换后再检测</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">var</span> usrAge = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(userAge));    <span class="comment">// false，21 不是一个非数字</span></span><br><span class="line"><span class="keyword">var</span> usrName = <span class="string">&quot;andy&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(userName));	<span class="comment">// true，&quot;andy&quot; 是一个非数字</span></span><br></pre></td></tr></table></figure>

<p><strong>String</strong></p>
<ul>
<li><p>特点：字符串型可以是引号中的 <code>任意文本</code>，其语法为：双引号 和 单引号</p>
</li>
<li><p>嵌套：外双内单，外单内双</p>
</li>
<li><p>转义符：\n …等等，具体查文档</p>
</li>
<li><p>长度：String(定义的字符串).length</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拼接</span></span><br><span class="line"><span class="comment"> * 形式: 使用 + 进行拼接，字符串 + 任何类型 = 拼接之后的新字符串</span></span><br><span class="line"><span class="comment"> * 辨析 + 口诀: 数值相加，字符相连</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">alert(<span class="string">&#x27;hello&#x27;</span> + <span class="string">&#x27; &#x27;</span> + <span class="string">&#x27;world&#x27;</span>); <span class="comment">// hello world</span></span><br><span class="line">alert(<span class="string">&#x27;100&#x27;</span> + <span class="string">&#x27;100&#x27;</span>); 			<span class="comment">// 100100</span></span><br><span class="line">alert(<span class="string">&#x27;11&#x27;</span> + <span class="number">12</span>);     			<span class="comment">// 1112</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">alert(<span class="string">&#x27;我今年&#x27;</span> + age + <span class="string">&#x27;岁啦&#x27;</span>);	 <span class="comment">// 我今年18岁啦</span></span><br></pre></td></tr></table></figure>

<p><strong>Boolean</strong></p>
<ul>
<li>值：true 和 false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 布尔型和数字型相加，true 的值为 1，false 的值为 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="number">1</span>);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> + <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>Undefined</strong></p>
<p>含义：未定义</p>
<p><strong>Null</strong></p>
<p>含义：空对象指针</p>
<p><strong>Object</strong></p>
<p>普通对象</p>
<ul>
<li>由大括号包裹起来的</li>
<li>由零到多组属性名和属性值（键值对）组成</li>
</ul>
<p><strong>数据类型检测方式</strong></p>
<ul>
<li><p>typeof [变量]</p>
<p>返回值：使用typeof检测出来的结果是一个字符串，字符串中包含着对应的数据类型，例如：”num ber”/“string”/“boolen”/“undefined”/“object”/“function”</p>
<p>注意：typeof 检测 数组 / 正则 / 对象，最后返回的都是 “object”，也就是基于这种方式无法细分对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot; 因为 null 代表空对象指针（没有指向任何的内存空间）</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>数据类型转换</strong></p>
<ul>
<li>其它类型    —&gt;    Number</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 1</span></span><br><span class="line"><span class="comment"> * parseInt(字符串): 把一个字符串中的整数部分解析出来</span></span><br><span class="line"><span class="comment"> * parseFloat(字符串): 把一个字符串中小数(浮点数)部分解析出来</span></span><br><span class="line"><span class="comment"> * 特点: 遇到一个非有效数字字符，查找结束</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;13.5px&#x27;</span>) 			<span class="comment">// 13</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;13.5px&#x27;</span>) 		<span class="comment">// 13.5</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;width:13.5px&#x27;</span>)	<span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 2</span></span><br><span class="line"><span class="comment"> * Number(变量) - 强制转换</span></span><br><span class="line"><span class="comment"> * 如果当前字符串中出现任意一个非有效数字字符，结果则为 NaN（重点）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;13&#x27;</span>) 			<span class="comment">// 13</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;13px&#x27;</span>)			<span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;13.5&#x27;</span>)			<span class="comment">// 13.5</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)			<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)		<span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) 				<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 3</span></span><br><span class="line"><span class="comment"> * 浏览器自动转换 - 强制转换</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其它类型    —&gt;    String</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 1</span></span><br><span class="line"><span class="comment"> * 变量.toString()</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">(&#123;&#125;).toString() 		<span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line">[<span class="number">12</span>,<span class="number">23</span>].toString() 		<span class="comment">// &#x27;12,23&#x27;</span></span><br><span class="line">[<span class="number">12</span>].toString()			<span class="comment">// &#x27;12&#x27;</span></span><br><span class="line">/^$/.toString() 		<span class="comment">// &#x27;/^$/&#x27;</span></span><br><span class="line">[].toString() 			<span class="comment">// &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 2 - 强制转换</span></span><br><span class="line"><span class="comment"> * String(变量)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 3 - 隐式转换</span></span><br><span class="line"><span class="comment"> * &quot;+&quot; 号拼接</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其它类型    —&gt;    Boolean</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式: Boolean()</span></span><br><span class="line"><span class="comment"> * JS 中只有 “ 0/NaN/空字符串/null/undefined ” 这五个值转换为布尔类型的 false，其余都转换为 true</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

<h5 id="1-3、运算符"><a href="#1-3、运算符" class="headerlink" title="1.3、运算符"></a>1.3、运算符</h5><p><strong>算术运算符</strong></p>
<ul>
<li><p>加（+）减（-）乘（*）除（/），取余数（取模）（%）</p>
</li>
<li><p>表达式：由数字、运算符、变量等组成的式子</p>
</li>
<li><p>递增（++），递减（ – ）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">++num: 先自加，后返回值</span><br><span class="line">num++: 先返回原值，后自加</span><br><span class="line">递减（ -- ）同理</span><br></pre></td></tr></table></figure>

<p><strong>比较（关系）运算符</strong></p>
<ul>
<li>大于（&gt;）…等等那些</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意点</span></span><br><span class="line">= : 赋值，把右边给左边</span><br><span class="line">== : 判断，判断两边值是否相等（注意隐式转换）</span><br><span class="line">=== : 全等，判断两边值和数据类型是否完全相同</span><br></pre></td></tr></table></figure>

<p><strong>逻辑运算符</strong></p>
<ul>
<li>与（&amp;&amp;）或（||）非（！）</li>
</ul>
<p><strong>… 更多查相关文档</strong></p>
<h5 id="1-4、流程控制"><a href="#1-4、流程控制" class="headerlink" title="1.4、流程控制"></a>1.4、流程控制</h5><p>顺序：代码自上而下，顺序执行</p>
<p>分支：条件判断</p>
<ul>
<li>if else …等等那些</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类比 三元运算符</span></span><br><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span>（表达式<span class="number">1</span>为真时执行）: 表达式<span class="number">3</span>（表达式<span class="number">1</span>为假时执行）;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>( 表达式 )&#123; </span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 表达式 等于 value1 时要执行的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 表达式 等于 value2 时要执行的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 表达式 不等于任何一个 value 时要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关键字 switch 后面括号内可以是表达式或值，通常是一个变量</span></span><br><span class="line"><span class="comment"> * 关键字 case, 后跟一个选项的表达式或值，后面跟一个冒号</span></span><br><span class="line"><span class="comment"> * switch 表达式的值会与结构中的 case 的值做比较</span></span><br><span class="line"><span class="comment"> * 如果存在匹配全等(===)，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束</span></span><br><span class="line"><span class="comment"> * 如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码</span></span><br><span class="line"><span class="comment"> * 注意: 执行 case 里面的语句时，如果没有 break，则继续执行下一个 case 里面的语句。</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

<h5 id="1-5、循环"><a href="#1-5、循环" class="headerlink" title="1.5、循环"></a>1.5、循环</h5><p>for 循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统 for 循环，可多重循环</span></span><br><span class="line"><span class="keyword">for</span>(初始化变量; 条件表达式; 操作表达式 )&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while 和 do-while 循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先判断，再执行循环体</span></span><br><span class="line"><span class="keyword">while</span> (条件表达式) &#123;</span><br><span class="line">    <span class="comment">// 循环体代码 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先执行循环体，再判断</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体代码 - 条件表达式为 true 时重复执行循环体代码</span></span><br><span class="line">&#125; <span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></table></figure>

<p>continue：立即跳出本次循环，继续下一次循环（循环继续）</p>
<p>break：立即跳出整个循环（循环结束）</p>
<h5 id="1-6、数组"><a href="#1-6、数组" class="headerlink" title="1.6、数组"></a>1.6、数组</h5><ul>
<li><p>创建数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式 1</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 2</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化（值类型可任意）</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;大黄&#x27;</span>,<span class="string">&#x27;瑞奇&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引 （下标）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">概念: 用来访问数组元素的序号，从 <span class="number">0</span> 开始</span><br><span class="line">作用: 通过索引来访问、设置、修改对应的数组元素</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> arrStus = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 获取数组中的第 2 个元素, 如果没有则值是 undefined</span></span><br><span class="line">alert(arrStus[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 形式: for 循环</span></span><br><span class="line"><span class="comment"> * 数组的长度: arr.length</span></span><br><span class="line"><span class="comment"> * 数组的元素个数 = 数组的长度 - 1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arrStus[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于数组的长度，在数组的末尾插入新元素</span></span><br><span class="line">数组[ 数组.length ] = 新数据;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-7、函数"><a href="#1-7、函数" class="headerlink" title="1.7、函数"></a>1.7、函数</h5><ul>
<li><p>声明与调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数, 方式 1 - 命名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数体代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数, 方式 2 - 匿名函数</span></span><br><span class="line"><span class="keyword">var</span> fn(函数名) = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数体代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">函数名();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<p>形参：形式上的参数, 当前并不知道是什么</p>
<p>实参：实际上的参数, 当前知道是什么</p>
<p>关系：实参 传递给 形参, 函数被调用的时候传递</p>
<p>数量：均可多个, 一般实参的数量对应形参的数量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实参个数 &gt; 形参个数: 只取到形参的个数</span></span><br><span class="line"><span class="comment"> * 实参个数 &lt; 形参个数: 多出的定义为 undefined, 结果为 NaN</span></span><br><span class="line"><span class="comment"> * arguments</span></span><br><span class="line"><span class="comment"> * 作用: 当不确定有多少个参数传递的时候，可以用 arguments 来获取</span></span><br><span class="line"><span class="comment"> * 身份: 当前函数的一个内置对象</span></span><br><span class="line"><span class="comment"> * 形式: 伪数组, 可遍历</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值</p>
<p>概念：函数调用整体代表的数据</p>
<p>形式：return  需要返回的值;</p>
<p>说明：执行了 return  语句, 函数会停止执行，并返回指定的值</p>
<p>有无：可有可无, 如果函数没有 return ，返回的值是 undefined</p>
</li>
</ul>
<h5 id="1-8、对象"><a href="#1-8、对象" class="headerlink" title="1.8、对象"></a>1.8、对象</h5><p>组成：键值对</p>
<p>注意：JS 对象中属性名是不允许重复的，是唯一的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name:<span class="string">&#x27;web前端&#x27;</span>,</span><br><span class="line">	age:<span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>获取：对象.属性 / 对象[属性]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.name</span><br><span class="line">obj[<span class="string">&#x27;name&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>增 / 改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增</span></span><br><span class="line">obj.sex=<span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">obj.name=<span class="string">&#x27;sunny&#x27;</span>;</span><br><span class="line">obj[<span class="string">&#x27;age&#x27;</span>]=<span class="number">28</span>;</span><br></pre></td></tr></table></figure>

<p>删</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 彻底删除：对象中不存在这个属性了</span></span><br><span class="line"><span class="keyword">delete</span> obj[<span class="string">&#x27;age&#x27;</span>];</span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假删除：并没有移除这个属性，只是让当前属性的值为空</span></span><br><span class="line">obj.sex = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>备注：在获取属性值的时候，如果当前对象有这个属性名，则可以正常获取到值（哪怕是 null），但是如果没有这个属性名，则获取的结果是 undefined</p>
<p><strong>特殊情况</strong></p>
<p><code>一个对象中的属性名不仅仅是字符串格式的，还有可能是数字格式的</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name:<span class="string">&#x27;web前端&#x27;</span>,</span><br><span class="line">	<span class="number">0</span>:<span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当属性名为数字时候的访问形式</span></span><br><span class="line"><span class="comment"> * 以 . 形式访问会报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">obj[<span class="number">0</span>] =&gt; <span class="number">100</span></span><br><span class="line">obj<span class="number">.0</span> =&gt; Uncaught <span class="built_in">SyntaxError</span>: Unexpected number</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当我们存储的属性名不是字符串也不是数字的时候，浏览器会把这个值转换为字符串（toString），然后再进行存储</span></span><br><span class="line"><span class="comment"> *  - 先把 (&#123;&#125;).toString() 后的结果作为对象的属性名存储进来 obj[&#x27;[object Object]&#x27;] = 300</span></span><br><span class="line"><span class="comment"> *  - 获取的时候也是先把对象转换为字符串&#x27;[object Object]&#x27;, 然后获取之前存储的 300</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">obj[&#123;&#125;] = <span class="number">300</span>;</span><br></pre></td></tr></table></figure>

<h5 id="1-9、作用域"><a href="#1-9、作用域" class="headerlink" title="1.9、作用域"></a>1.9、作用域</h5><ul>
<li><p>全局作用域</p>
<p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部作用域</p>
<p>作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 局部变量</span></span><br><span class="line">在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域链</p>
</li>
</ul>
<h5 id="2-0、常用-API"><a href="#2-0、常用-API" class="headerlink" title="2.0、常用 API"></a>2.0、常用 API</h5><blockquote>
<p>Math</p>
</blockquote>
<ul>
<li><p>abs：取绝对值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="number">-666</span>)) <span class="comment">// 666</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="number">666</span>)) <span class="comment">// 666</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ceil / floor：向上取整 / 向下取整</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">10</span>)) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">10.01</span>)) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">-10.01</span>)) <span class="comment">// -10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">10.999</span>)) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">-10.999</span>)) <span class="comment">// -11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>round：四舍五入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">10.49</span>)) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">10.5</span>)) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">-10.49</span>)) <span class="comment">// -10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">-10.5</span>)) <span class="comment">// -10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">-10.51</span>)) <span class="comment">// -11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sqrt：开平方</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.sqrt(<span class="number">100</span>)) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.sqrt(<span class="number">10</span>)) <span class="comment">// 3.1622776601683795</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.sqrt(<span class="number">16</span>)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pow：取幂（N 的 M 次方）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">10</span>)) <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>max / min：获取最大值和最小值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">2</span>,<span class="number">10</span>,<span class="number">44</span>)) <span class="comment">// 44</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min(<span class="number">2</span>,<span class="number">10</span>,<span class="number">44</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>字符串相关</p>
</blockquote>
<ul>
<li><p>charAt / charCodeAt</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * charAt：根据索引获取指定位置的字符</span></span><br><span class="line"><span class="comment"> * charCodeAt：不仅仅获取字符，它获取的是字符对应的 Unicode 编码值(ASCII 码值)</span></span><br><span class="line"><span class="comment"> * 参数：索引</span></span><br><span class="line"><span class="comment"> * 返回：字符或者对应的编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">str.charAt(<span class="number">0</span>) <span class="comment">// s</span></span><br><span class="line">str.charCodeAt(<span class="number">0</span>) <span class="comment">// 115</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">115</span>) <span class="comment">// s，返回编码对应的字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>indexOf / lastIndexOf</p>
<p>基于这两个方法，可以获取字符在字符串中<code>第一次</code>或者<code>最后一次</code>出现位置的<code>索引</code>，有这个字符，返回<code>大于等于零的索引</code>，不包含这个字符，返回的结果是­ -1，所以可以基于这两个方法，验证当前字 符串中是否包含某个字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;sunny&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.indexOf(<span class="string">&#x27;y&#x27;</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="comment">// 条件成立说明包含 y 符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>slice</p>
<p>str.slice(n,m) 从索引 n 开始找到索引为 m 处(不包含 m)，把找到的字符当做新字符串返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="comment">// 截取索引 1 到 3 的字符串</span></span><br><span class="line">str.slice(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// un</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同数组 slice</span></span><br><span class="line"><span class="comment"> *  1、不指定 m，默认查找到字符串的末尾</span></span><br><span class="line"><span class="comment"> *  2、n 和 m，均不指定，则是该字符串的克隆（复制）</span></span><br><span class="line"><span class="comment"> *  3、支持负数索引：用字符串的总长度 + 负数索引做运算（n 或者 m = 总长度 + 负数索引）</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>substring</p>
<p>和 slice 语法一模一样，唯一的区别在于：slice 支持负数索引，而 substring 不支持负数索引</p>
</li>
<li><p>toUpperCase / toLowerCase</p>
<p>实现字母的大小写转换，toUpperCase：小写转大写，toLowerCase：大写转小写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.toUpperCase()	<span class="comment">// SUNNY</span></span><br><span class="line">str.toLowerCase()	<span class="comment">// sunny</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>split</p>
<p>把字符串按照指定的分隔符，拆分成数组中每一项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;12+23+34&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串 转 数组</span></span><br><span class="line">str.split(<span class="string">&#x27;+&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>replace</p>
<p>替换字符串中的原有字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数：原有字符，要替换的新字符</span></span><br><span class="line"><span class="comment"> * 返回：替换后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;helloworld&#x27;</span>;</span><br><span class="line"><span class="comment">// 非正则匹配替换，replace 只执行一次匹配替换</span></span><br><span class="line">str = str.replace(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;你好&#x27;</span>); </span><br><span class="line"><span class="comment">// 正则匹配</span></span><br><span class="line">str = str.replace(<span class="regexp">/hello/g</span>,<span class="string">&#x27;你好&#x27;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>数组相关</p>
</blockquote>
<ul>
<li><p>push / pop</p>
<p>向数组<code>末尾</code>追加新的内容 / 删除数组<code>最后一项</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * push</span></span><br><span class="line"><span class="comment"> * 参数：追加的内容（可以是一个，也可是多个）</span></span><br><span class="line"><span class="comment"> * 返回：新增后数组的长度</span></span><br><span class="line"><span class="comment"> * 注意：原有数组改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> ary = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>];</span><br><span class="line">ary.push(<span class="number">100</span>,&#123;<span class="attr">name</span>:<span class="string">&#x27;xxx&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pop</span></span><br><span class="line"><span class="comment"> * 参数：无</span></span><br><span class="line"><span class="comment"> * 返回：被删除的那一项内容</span></span><br><span class="line"><span class="comment"> * 注意：原有数组改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ary.pop()</span><br></pre></td></tr></table></figure>
</li>
<li><p>shift / unshift</p>
<p>删除数组中的第一项 / 向数组开始位置追加新内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shift</span></span><br><span class="line"><span class="comment"> * 参数：无</span></span><br><span class="line"><span class="comment"> * 返回：被删除的那一项内容</span></span><br><span class="line"><span class="comment"> * 注意：原有数组改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * unshift</span></span><br><span class="line"><span class="comment"> * 参数：要新增的内容</span></span><br><span class="line"><span class="comment"> * 返回：新增后数组的长度</span></span><br><span class="line"><span class="comment"> * 注意：原有数组改变</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>splice</p>
<p>删除指定位置的内容、向数组指定位置增加内容、修改指定位置的信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除：ary.splice(n,m)</span></span><br><span class="line"><span class="comment"> * 含义：从索引 n 开始，删除 m 个内容，把删除的部分以一个新数组返回，原有数组改变</span></span><br><span class="line"><span class="comment"> * 注意：不指定 m 或者删除的个数大于最大长度，都是删除到数组的末尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增：ary.splice(n,0,x,...)</span></span><br><span class="line"><span class="comment"> * 含义：从索引 n 开始删除零项（没删除），把 X 或者更多需要插入的内容存放到数组中索引 n 的 “前面”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改：ary.splice(n,m,x,...)</span></span><br><span class="line"><span class="comment"> * 原理：把原有内容删除掉，然后用新的内容替换这部分信息</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>slice</p>
<p>同 字符串的 slice</p>
<p>注意：原数组不改变</p>
</li>
<li><p>concat</p>
<p>作用：实现多个数组（或者值）的拼接</p>
<p>参数：数组或者值</p>
<p>返回：拼接后的新数组</p>
<p>注意：原有数组不变</p>
</li>
<li><p>toString</p>
<p>作用：把数组转换为字符串</p>
<p>参数：无</p>
<p>返回：数组中的每一项用逗号分隔的字符串</p>
<p>注意：原有数组不变</p>
</li>
<li><p>join（同 split）</p>
<p>作用：把数组转换为字符串</p>
<p>参数：指定的链接符</p>
<p>返回：字符串</p>
<p>注意：原有数组不变</p>
</li>
<li><p>reverse</p>
<p>作用：把数组倒过来排列</p>
<p>参数：无</p>
<p>返回：排列后的新数组</p>
<p>注意：原有数组改变</p>
</li>
<li><p>sort</p>
<p>作用：给数组排序</p>
<p>参数：无 / 函数</p>
<p>返回：排序后的新数组</p>
<p>注意：原有数组改变</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真实项目中，基于 sort 排序，都需要传递参数</span></span><br><span class="line"><span class="keyword">var</span> ary=[<span class="number">18</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">35</span>,<span class="number">3</span>,<span class="number">56</span>];</span><br><span class="line">	ary.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-b; <span class="comment">// 升序, return b-a; 降序</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、Web-API"><a href="#2、Web-API" class="headerlink" title="2、Web API"></a>2、Web API</h4><h5 id="2-1、获取元素"><a href="#2-1、获取元素" class="headerlink" title="2.1、获取元素"></a>2.1、获取元素</h5><ul>
<li><p>根据 ID  获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法: document.getElementById(id)</span></span><br><span class="line"><span class="comment"> * 作用: 根据 ID 获取元素对象</span></span><br><span class="line"><span class="comment"> * 参数: id 值，区分大小写的字符串</span></span><br><span class="line"><span class="comment"> * 返回值: 元素对象 或 null</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;time&quot;</span>&gt;<span class="number">2020</span><span class="number">-9</span><span class="number">-9</span>&lt;/div&gt;</span><br><span class="line">	<span class="comment">// 先得有标签，所以 script 写到标签结构的下面（最后面）</span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> timer = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;time&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(timer);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">typeof</span> timer);</span><br><span class="line">        <span class="comment">// console.dir 打印返回的元素对象，更好的查看里面的属性和方法</span></span><br><span class="line">        <span class="built_in">console</span>.dir(timer);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 标签名 获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法 1 : document.getElementsByTagName(&#x27;标签名&#x27;) </span></span><br><span class="line"><span class="comment"> * 语法 2 : element.getElementsByTagName(&#x27;标签名&#x27;)</span></span><br><span class="line"><span class="comment"> * 作用: 根据标签名获取元素对象</span></span><br><span class="line"><span class="comment"> * 参数: 标签名</span></span><br><span class="line"><span class="comment"> * 返回值: 元素对象集合（伪数组，数组元素是元素对象）</span></span><br><span class="line"><span class="comment"> * 注意: 获取到是动态集合，即: 当页面增加了标签，这个集合中也就增加了元素</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久<span class="number">11</span>&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久<span class="number">22</span>&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久<span class="number">33</span>&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久<span class="number">44</span>&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，应是等你好久<span class="number">55</span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;ul id=<span class="string">&quot;nav&quot;</span>&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;生僻字&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 1. 返回的是: 获取过来元素对象的集合，以伪数组的形式存储的</span></span><br><span class="line">        <span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(lis);</span><br><span class="line">        <span class="built_in">console</span>.log(lis[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 2. 想要依次打印里面的元素对象，可以采取遍历的方式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(lis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. element.getElementsByTagName(): 可以得到这个元素里面的某些标签</span></span><br><span class="line">		<span class="comment">// 先获取外层，逐层获取</span></span><br><span class="line">        <span class="keyword">var</span> nav = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;nav&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> navLis = nav.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(navLis);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>H5 新增获取方式（注意兼容性）</p>
<p>根据 类名 获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法: document.getElementsByClassName(&#x27;类名&#x27;) </span></span><br><span class="line"><span class="comment"> * 作用: 根据类名获取元素对象</span></span><br><span class="line"><span class="comment"> * 参数: 类名</span></span><br><span class="line"><span class="comment"> * 返回值: 元素对象集合（伪数组，数组元素是元素对象）</span></span><br><span class="line"><span class="comment"> * 注意: 获取到是动态集合，即: 当页面增加了标签，这个集合中也就增加了元素</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

<p>根据 选择器 获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法: document.querySelector(&#x27;选择器&#x27;) </span></span><br><span class="line"><span class="comment"> * 作用: 根据选择器获取第一个元素对象</span></span><br><span class="line"><span class="comment"> * 参数: 选择器</span></span><br><span class="line"><span class="comment"> * 返回值: 指定选择器的第一个元素对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语法: document.querySelectorAll(&#x27;选择器&#x27;) </span></span><br><span class="line"><span class="comment"> * 作用: 根据选择器获取所有元素对象</span></span><br><span class="line"><span class="comment"> * 参数: 选择器</span></span><br><span class="line"><span class="comment"> * 返回值: 指定选择器的所有元素对象集合</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;box&quot;</span>&gt;盒子<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;box&quot;</span>&gt;盒子<span class="number">2</span>&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;nav&quot;</span>&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 1. getElementsByClassName 根据类名获得某些元素集合</span></span><br><span class="line">        <span class="keyword">var</span> boxs = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(boxs);</span><br><span class="line">        <span class="comment">// 2. querySelector: 返回指定选择器的第一个元素对象，切记: 里面的选择器需要加符号 .box  #nav</span></span><br><span class="line">        <span class="keyword">var</span> firstBox = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(firstBox);</span><br><span class="line">        <span class="keyword">var</span> nav = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#nav&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(nav);</span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(li);</span><br><span class="line">        <span class="comment">// 3. querySelectorAll()返回指定选择器的所有元素对象集合</span></span><br><span class="line">        <span class="keyword">var</span> allBox = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(allBox);</span><br><span class="line">        <span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(lis);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取特殊元素</p>
<p>body：document.body</p>
<p>html：document.documentElement</p>
</li>
</ul>
<h5 id="2-2、事件"><a href="#2-2、事件" class="headerlink" title="2.2、事件"></a>2.2、事件</h5><ul>
<li><p>三要素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件源（谁）: 触发事件的元素 </span></span><br><span class="line"><span class="comment"> * 事件类型（什么事件）: 例如 click 点击事件</span></span><br><span class="line"><span class="comment"> * 参数: 类名</span></span><br><span class="line"><span class="comment"> * 事件处理程序（做啥）: 事件触发后要执行的代码(函数形式)，事件处理函数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;btn&quot;</span>&gt;唐伯虎&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 执行事件步骤</span></span><br><span class="line">        <span class="comment">//(1) 获取事件源: 例如按钮</span></span><br><span class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">        <span class="comment">//(2) 绑定/注册事件类型: 例如鼠标点击(onclick)</span></span><br><span class="line">        <span class="comment">//(3) 添加事件处理程序: 函数体</span></span><br><span class="line">        btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;点秋香&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件注册的两种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、传统注册方式 </span></span><br><span class="line"><span class="comment"> * 特点: 注册事件的唯一性</span></span><br><span class="line"><span class="comment"> * 注意: 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数会覆盖前面注册的处理函数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、监听注册方式 </span></span><br><span class="line"><span class="comment"> * 方法 1 : addEventListener()</span></span><br><span class="line"><span class="comment"> * 参数: </span></span><br><span class="line"><span class="comment"> * 	 (1)、事件类型字符串，如: click</span></span><br><span class="line"><span class="comment"> *	 (2)、事件处理函数</span></span><br><span class="line"><span class="comment"> *   (3)、布尔值，可选，true: 事件捕获阶段调用，false: 事件冒泡阶段调用</span></span><br><span class="line"><span class="comment"> * 特点: 同一个元素同一个事件可以注册多个监听器</span></span><br><span class="line"><span class="comment"> * 注意: 按注册顺序依次执行, IE9 以后</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 方法 2 : attacheEvent()</span></span><br><span class="line"><span class="comment"> * 参数: </span></span><br><span class="line"><span class="comment"> * 	 (1)、事件类型字符串，如: click</span></span><br><span class="line"><span class="comment"> *	 (2)、事件处理函数（回调函数）</span></span><br><span class="line"><span class="comment"> * 特点: 同一个元素同一个事件可以注册多个监听器</span></span><br><span class="line"><span class="comment"> * 注意: 按注册顺序依次执行, IE9 以前</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;传统注册事件&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;方法监听注册事件&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;ie9 attachEvent&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        <span class="comment">// 1. 传统方式注册事件</span></span><br><span class="line">        btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;hao a u&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 2. 事件侦听注册事件 addEventListener </span></span><br><span class="line">         <span class="comment">// (1) 里面的事件类型是字符串 必定加引号 而且不带 on</span></span><br><span class="line">         <span class="comment">// (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）</span></span><br><span class="line">		<span class="comment">// 注意: 此处 处理函数 一般写具名函数，而不是下面的匿名函数，便于事件删除操作</span></span><br><span class="line">        btns[<span class="number">1</span>].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="number">22</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        btns[<span class="number">1</span>].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="number">33</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="comment">// 3. attachEvent ie9 以前的版本支持</span></span><br><span class="line">        btns[<span class="number">2</span>].attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="number">11</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除（解绑）事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、传统注册事件的删除</span></span><br><span class="line"><span class="comment"> * 形式: 事件源.事件名 = null;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、监听注册事件的删除</span></span><br><span class="line"><span class="comment"> * 方法 1 : removeEventListener()</span></span><br><span class="line"><span class="comment"> * 参数: 同上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 方法 2 : detachEvent()</span></span><br><span class="line"><span class="comment"> * 参数: 同上</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">2</span>&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">3</span>&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        divs[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="number">11</span>);</span><br><span class="line">                <span class="comment">// 1. 传统方式删除事件</span></span><br><span class="line">                divs[<span class="number">0</span>].onclick = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. removeEventListener 删除事件</span></span><br><span class="line">        divs[<span class="number">1</span>].addEventListener(<span class="string">&#x27;click&#x27;</span>, fn) <span class="comment">// 里面的fn 不需要调用加小括号</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="number">22</span>);</span><br><span class="line">            divs[<span class="number">1</span>].removeEventListener(<span class="string">&#x27;click&#x27;</span>, fn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. detachEvent</span></span><br><span class="line">        divs[<span class="number">2</span>].attachEvent(<span class="string">&#x27;onclick&#x27;</span>, fn1);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="number">33</span>);</span><br><span class="line">            divs[<span class="number">2</span>].detachEvent(<span class="string">&#x27;onclick&#x27;</span>, fn1);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM 事件流</p>
<p>概念：事件发生时会在元素节点之间按照特定的顺序传播</p>
<p>事件流的三个阶段</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824203205.png"> </p>
<p>捕获阶段：由外往内，逐层响应（应用较少）</p>
<p>事件冒泡：由内往外，逐层响应（应用较多）</p>
<p>冒泡情况：有冒泡的事件，给父子嵌套的父盒子绑定该事件的时候，由于冒泡，父盒子绑定的事件被执行了两次</p>
<p>注意事项：</p>
<p>（1）、JS 代码中只能执行捕获或者冒泡其中的一个阶段；</p>
<p>（2）、onClick 和 attachEvent 只能得到冒泡阶段；</p>
<p>（3）、部分事件没有冒泡，如：onblur、onfocus、onmouseenter、onmouseleave</p>
</li>
<li><p>事件对象</p>
<p>概念：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意事项</span></span><br><span class="line"><span class="comment"> * 1. event 就是一个事件对象，写到我们侦听函数的，小括号里面，当形参来看</span></span><br><span class="line"><span class="comment"> * 2. 事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数</span></span><br><span class="line"><span class="comment"> * 3. 这个事件对象我们可以自己命名 比如 event 、 evt、 e</span></span><br><span class="line"><span class="comment"> * 4. 有兼容性问题，ie678 通过 window.event 兼容性的写法: e = e || window.event;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">123</span>&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// console.log(e);</span></span><br><span class="line">                <span class="comment">// console.log(window.event);</span></span><br><span class="line">                <span class="comment">// e = e || window.event;</span></span><br><span class="line">                <span class="built_in">console</span>.log(e);</span><br><span class="line">            &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常见属性和方法</span></span><br><span class="line"><span class="comment"> * 1. e.target</span></span><br><span class="line"><span class="comment"> * 返回值: 触发事件的对象（元素）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. e.preventDefault()</span></span><br><span class="line"><span class="comment"> * 作用: 阻止默认事件，比如不让链接跳转, IE9 以上</span></span><br><span class="line"><span class="comment"> * 兼容: ie678: e.returnValue = false;</span></span><br><span class="line"><span class="comment"> * 无兼容问题写法: return false;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3、e.stopPropagation()</span></span><br><span class="line"><span class="comment"> * 作用: 阻止冒泡, IE9 以上</span></span><br><span class="line"><span class="comment"> * 兼容: ie678: e.event.cancelBubble = true;</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件委托（代理、委派）</p>
<p>原理：给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素</p>
<p>表述：<strong>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</strong></p>
<p>作用：减少 DOM 操作次数，提高程序性能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给 ul 注册点击事件，然后利用事件对象的 e.target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上，ul 有注册事件，就会触发事件监听器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点</span></span><br><span class="line">        <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">        ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// alert(&#x27;知否知否，点我应有弹框在手！&#x27;);</span></span><br><span class="line">            <span class="comment">// e.target 这个可以得到我们点击的对象</span></span><br><span class="line">            e.target.style.backgroundColor = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 注意: e.target 和 this 的区别</span></span><br><span class="line"><span class="comment">		 * e.target: 触发事件的对象（元素），点击的是 li，故是 li 元素</span></span><br><span class="line"><span class="comment">		 * this: 指向事件源，绑定点击事件的是 ul，故是获取到的 ul </span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mouseenter 和mouseover 的区别</p>
<p>当鼠标移动到元素上时就会触发 mouseenter 事件，mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发，mouseenter  只会经过自身盒子触发</p>
<p>原因：mouseenter 不会冒泡</p>
<p>注意：跟 mouseenter 搭配，鼠标离开 mouseleave  同样不会冒泡</p>
</li>
</ul>
<h5 id="2-3、操作元素"><a href="#2-3、操作元素" class="headerlink" title="2.3、操作元素"></a>2.3、操作元素</h5><ul>
<li><p>改变元素内容（获取或设置）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 1 : element.innerText </span></span><br><span class="line"><span class="comment"> * 范围: 从起始位置到终止位置的内容</span></span><br><span class="line"><span class="comment"> * 特点: 去除 HTML 标签，空格 和 换行</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 2 : element.innerHTML</span></span><br><span class="line"><span class="comment"> * 范围: 从起始位置到终止位置的全部内容</span></span><br><span class="line"><span class="comment"> * 特点: 包括 HTML 标签，空格 和 换行</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;显示当前系统时间&lt;/button&gt;</span><br><span class="line">    &lt;div&gt;某个时间&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;<span class="number">1123</span>&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 点击了按钮，div里面的文字会发生变化</span></span><br><span class="line">        <span class="comment">// 1. 获取元素 </span></span><br><span class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="comment">// 2. 注册事件</span></span><br><span class="line">        btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// div.innerText = &#x27;2020-6-6&#x27;;</span></span><br><span class="line">            div.innerHTML = getDate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="keyword">var</span> year = date.getFullYear();</span><br><span class="line">            <span class="keyword">var</span> month = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">var</span> dates = date.getDate();</span><br><span class="line">            <span class="keyword">var</span> arr = [<span class="string">&#x27;星期日&#x27;</span>, <span class="string">&#x27;星期一&#x27;</span>, <span class="string">&#x27;星期二&#x27;</span>, <span class="string">&#x27;星期三&#x27;</span>, <span class="string">&#x27;星期四&#x27;</span>, <span class="string">&#x27;星期五&#x27;</span>, <span class="string">&#x27;星期六&#x27;</span>];</span><br><span class="line">            <span class="keyword">var</span> day = date.getDay();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;今天是：&#x27;</span> + year + <span class="string">&#x27;年&#x27;</span> + month + <span class="string">&#x27;月&#x27;</span> + dates + <span class="string">&#x27;日 &#x27;</span> + arr[day];</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作属性</p>
<p>获取属性的值：元素对象.属性名</p>
<p>设置属性的值：元素对象.属性名 = 值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常见操作属性</span></span><br><span class="line"><span class="comment"> * src、href、id、alt、title</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;ldh&quot;</span>&gt;刘德华&lt;/button&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;zxy&quot;</span>&gt;张学友&lt;/button&gt; <span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line">    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 例如: 修改元素属性: src</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var ldh = document.getElementById(&#x27;ldh&#x27;);</span><br><span class="line">        var zxy = document.getElementById(&#x27;zxy&#x27;);</span><br><span class="line">        var img = document.querySelector(&#x27;img&#x27;);</span><br><span class="line">        // 2. 注册事件, 处理程序</span><br><span class="line">        zxy.onclick = function() &#123;</span><br><span class="line">            img.src = &#x27;images/zxy.jpg&#x27;;</span><br><span class="line">            img.title = &#x27;张学友思密达&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        ldh.onclick = function() &#123;</span><br><span class="line">            img.src = &#x27;images/ldh.jpg&#x27;;</span><br><span class="line">            img.title = &#x27;刘德华&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">/**</span></span><br><span class="line"><span class="xml"> * 常见表单操作属性</span></span><br><span class="line"><span class="xml"> * type、value、checked、selected、disabled</span></span><br><span class="line"><span class="xml"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">        var input = document.querySelector(&#x27;input&#x27;);</span><br><span class="line">        // 2. 注册事件 处理程序</span><br><span class="line">        btn.onclick = function() &#123;</span><br><span class="line">            // 表单里面的值，文字内容是通过 value 来修改的</span><br><span class="line">            input.value = &#x27;被点击了&#x27;;</span><br><span class="line">            // 如果想要某个表单被禁用，不能再点击: disabled = true</span><br><span class="line">            // btn.disabled = true;</span><br><span class="line">            this.disabled = true;</span><br><span class="line">            // this 指向的是事件函数的调用者 btn</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 常见样式属性</span><br><span class="line"> * style: 行内样式, 权重较高, 样式较少或者功能简单的情况下使用</span><br><span class="line"> * 方式: 元素对象.style.样式属性 = 值;</span><br><span class="line"> * className: 类名样式, 样式较多或者功能复杂的情况</span><br><span class="line"> * 方式: 元素对象.className = 值;</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 1. 获取元素</span><br><span class="line">        var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        // 2. 注册事件 处理程序</span><br><span class="line">        div.onclick = function() &#123;</span><br><span class="line">            // div.style 里面的属性，采取驼峰命名法 </span><br><span class="line">            this.style.backgroundColor = &#x27;purple&#x27;;</span><br><span class="line">            this.style.width = &#x27;250px&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var test = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">        test.onclick = function() &#123;</span><br><span class="line">            // this.className = &#x27;change&#x27;;</span><br><span class="line">            this.className = &#x27;first change&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义属性的操作</p>
<p>目的：为了保存并使用数据，有些数据可以保存到页面中而不用保存到数据库中</p>
<p>获取属性值：element.属性，元素本身自带的属性</p>
<p>获取属性值：element.getAttribute(‘属性’)，自定义属性</p>
<p>设置元素属性值：element.属性= ‘值’，元素本身自带的属性</p>
<p>设置元素属性值：element.setAttribute(‘属性’, ‘值’)，自定义属性</p>
<p>移除属性：removeAttribute(‘属性’)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;demo&quot;</span> index=<span class="string">&quot;1&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;nav&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="comment">// 1. 获取元素的属性值</span></span><br><span class="line">        <span class="comment">// (1) element.属性</span></span><br><span class="line">        <span class="built_in">console</span>.log(div.id);</span><br><span class="line">        <span class="comment">// (2) element.getAttribute(&#x27;属性&#x27;) </span></span><br><span class="line">        <span class="built_in">console</span>.log(div.getAttribute(<span class="string">&#x27;id&#x27;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(div.getAttribute(<span class="string">&#x27;index&#x27;</span>));</span><br><span class="line">        <span class="comment">// 2. 设置元素属性值</span></span><br><span class="line">        <span class="comment">// (1) element.属性= &#x27;值&#x27;</span></span><br><span class="line">        div.id = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line">        div.className = <span class="string">&#x27;navs&#x27;</span>;</span><br><span class="line">        <span class="comment">// (2) element.setAttribute(&#x27;属性&#x27;, &#x27;值&#x27;);</span></span><br><span class="line">        div.setAttribute(<span class="string">&#x27;index&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="comment">// class 特殊，这里面写的就是 class，不是 className</span></span><br><span class="line">        div.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;footer&#x27;</span>); </span><br><span class="line">        <span class="comment">// 3 移除属性 removeAttribute(属性)    </span></span><br><span class="line">        div.removeAttribute(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>H5 自定义属性</p>
<p>方式：data- 开头作为属性名并赋值，例如：data-index=”1”</p>
<p>目的：为了区分该属性是内置属性还是自定义属性，data- 开头为自定义属性，否则为内置属性</p>
<p>获取 H5 自定义属性：element.getAttribute(‘data-属性’)，兼容获取</p>
<p>获取 H5 自定义属性：element.dataset.属性 or element.dataset[‘属性’]，IE 11 版本以上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div getTime=<span class="string">&quot;20&quot;</span> data-index=<span class="string">&quot;2&quot;</span> data-list-name=<span class="string">&quot;andy&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(div.getAttribute(<span class="string">&#x27;getTime&#x27;</span>));</span><br><span class="line">        div.setAttribute(<span class="string">&#x27;data-time&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(div.getAttribute(<span class="string">&#x27;data-index&#x27;</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(div.getAttribute(<span class="string">&#x27;data-list-name&#x27;</span>));</span><br><span class="line">        <span class="comment">// h5新增的获取自定义属性的方法 它只能获取data-开头的</span></span><br><span class="line">        <span class="comment">// dataset 是一个集合里面存放了所有以data开头的自定义属性</span></span><br><span class="line">        <span class="built_in">console</span>.log(div.dataset);</span><br><span class="line">        <span class="built_in">console</span>.log(div.dataset.index);</span><br><span class="line">        <span class="built_in">console</span>.log(div.dataset[<span class="string">&#x27;index&#x27;</span>]);</span><br><span class="line">        <span class="comment">// 如果自定义属性里面有多个-链接的单词，获取的时候采取 驼峰命名法</span></span><br><span class="line">        <span class="built_in">console</span>.log(div.dataset.listName);</span><br><span class="line">        <span class="built_in">console</span>.log(div.dataset[<span class="string">&#x27;listName&#x27;</span>]);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2-4、节点操作"><a href="#2-4、节点操作" class="headerlink" title="2.4、节点操作"></a>2.4、节点操作</h5><p>目的：使 DOM 元素的操作变得更简单，逻辑性更强</p>
<ul>
<li><p>父子关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父节点: parentNode</span></span><br><span class="line"><span class="comment"> * 注意: 最近的一个父节点(亲爸爸)，如果指定的节点没有父节点则返回 NULL</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;erweima&quot;</span>&gt;×&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 父节点 parentNode</span></span><br><span class="line">        <span class="keyword">var</span> erweima = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.erweima&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(erweima.parentNode);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有子节点: childNodes、children（常用）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">        &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 1. 子节点: childNodes，所有的子节点包含: 元素节点、文本节点等等</span></span><br><span class="line">        <span class="built_in">console</span>.log(ul.childNodes);</span><br><span class="line">        <span class="built_in">console</span>.log(ul.childNodes[<span class="number">0</span>].nodeType);</span><br><span class="line">        <span class="built_in">console</span>.log(ul.childNodes[<span class="number">1</span>].nodeType);</span><br><span class="line">        <span class="comment">// 2. children: 获取所有的子元素节点，也是实际开发常用的，兼容</span></span><br><span class="line">        <span class="built_in">console</span>.log(ul.children);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个子节点: firstChild，所有</span></span><br><span class="line"><span class="comment"> * 最后一个子节点: lastChild，所有</span></span><br><span class="line"><span class="comment"> * 第一个子元素节点: firstElementChild，第一个子元素</span></span><br><span class="line"><span class="comment"> * 最后一个子元素节点: lastElementChild，最后一个子元素</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">        &lt;li&gt;我是li1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li3&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li4&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;我是li5&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> ol = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ol&#x27;</span>);</span><br><span class="line">        <span class="comment">// 1. firstChild 第一个子节点，不管是文本节点还是元素节点都有</span></span><br><span class="line">        <span class="built_in">console</span>.log(ol.firstChild);</span><br><span class="line">        <span class="built_in">console</span>.log(ol.lastChild);</span><br><span class="line">        <span class="comment">// 2. firstElementChild，返回第一个子元素节点，ie9 才支持</span></span><br><span class="line">        <span class="built_in">console</span>.log(ol.firstElementChild);</span><br><span class="line">        <span class="built_in">console</span>.log(ol.lastElementChild);</span><br><span class="line">        <span class="comment">// 3. 实际开发的写法，既没有兼容性问题又返回第一个子元素</span></span><br><span class="line">        <span class="built_in">console</span>.log(ol.children[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(ol.children[ol.children.length - <span class="number">1</span>]);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>兄弟 / 姐妹关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nextSibling、previousSibling - 所有</span></span><br><span class="line"><span class="comment"> * nextElementSibling、previousElementSibling - 元素</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;我是div&lt;/div&gt;</span><br><span class="line">    &lt;span&gt;我是span&lt;/span&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="comment">// 1. nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等</span></span><br><span class="line">        <span class="built_in">console</span>.log(div.nextSibling);</span><br><span class="line">        <span class="built_in">console</span>.log(div.previousSibling);</span><br><span class="line">        <span class="comment">// 2. nextElementSibling 得到下一个兄弟元素节点</span></span><br><span class="line">        <span class="built_in">console</span>.log(div.nextElementSibling);</span><br><span class="line">        <span class="built_in">console</span>.log(div.previousElementSibling);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建节点 和 添加节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建节点</span></span><br><span class="line"><span class="comment"> * 方式: document.createElement(&#x27;tagName&#x27;)</span></span><br><span class="line"><span class="comment"> * 说明: 创建由 tagName 指定的 HTML 元素，原先不存在，是根据需求动态生成的</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> * 方式 1 : node.appendChild(child)</span></span><br><span class="line"><span class="comment"> * 说明: node: 父级, child: 子级，将一个节点添加到指定父节点的子节点列表的末尾</span></span><br><span class="line"><span class="comment"> * 方式 2 : node.insertBefore(child, 指定元素)</span></span><br><span class="line"><span class="comment"> * 说明: node: 父级, child: 子级，将一个节点添加到父节点的指定子节点的前面</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;<span class="number">123</span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 1. 创建元素节点</span></span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        <span class="comment">// 2. 添加节点 node.appendChild(child)</span></span><br><span class="line">        <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">        ul.appendChild(li);</span><br><span class="line">        <span class="comment">// 3. 添加节点 node.insertBefore(child, 指定子节点元素);</span></span><br><span class="line">        <span class="keyword">var</span> lili = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        ul.insertBefore(lili, ul.children[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 4. 想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素</span></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * node.removeChild()</span></span><br><span class="line"><span class="comment"> * 作用: 从 DOM 节点中删除一个子节点</span></span><br><span class="line"><span class="comment"> * 返回: 删除的节点</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;删除&lt;/button&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;熊大&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;熊二&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;光头强&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 1.获取元素</span></span><br><span class="line">        <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        <span class="comment">// 2. 删除元素  node.removeChild(child)</span></span><br><span class="line">        <span class="comment">// ul.removeChild(ul.children[0]);</span></span><br><span class="line">        <span class="comment">// 3. 点击按钮依次删除里面的孩子</span></span><br><span class="line">        btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ul.children.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.disabled = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ul.removeChild(ul.children[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * node.cloneNode()</span></span><br><span class="line"><span class="comment"> * 参数: 空或者 false，浅拷贝即: 只复制标签不复制里面的内容，true，深拷贝</span></span><br><span class="line"><span class="comment"> * 返回: 克隆节点</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;<span class="number">1111</span>&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;<span class="number">3</span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">        <span class="comment">// 1. node.cloneNode();</span></span><br><span class="line">        <span class="comment">// 2. node.cloneNode(true);</span></span><br><span class="line">        <span class="keyword">var</span> lili = ul.children[<span class="number">0</span>].cloneNode(<span class="literal">true</span>);</span><br><span class="line">        ul.appendChild(lili);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三种创建元素的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 1 : document.write()</span></span><br><span class="line"><span class="comment"> * 说明: 如果页面文档流加载完毕，再调用这句话会导致页面重绘</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 2 : element.innerHTML</span></span><br><span class="line"><span class="comment"> * 说明: 将内容写入某个 DOM 节点，不会导致页面全部重绘</span></span><br><span class="line"><span class="comment"> * 效率: 效率更高（不要拼接字符串，采取数组形式拼接）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 3 : document.createElement()</span></span><br><span class="line"><span class="comment"> * 说明: 创建元素</span></span><br><span class="line"><span class="comment"> * 效率: 稍微低一点点，但结构清晰</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;p&gt;abc&lt;/p&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;create&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 三种创建元素方式区别 </span></span><br><span class="line">        <span class="comment">// 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘</span></span><br><span class="line">        <span class="comment">// var btn = document.querySelector(&#x27;button&#x27;);</span></span><br><span class="line">        <span class="comment">// btn.onclick = function() &#123;</span></span><br><span class="line">        <span class="comment">//     document.write(&#x27;&lt;div&gt;123&lt;/div&gt;&#x27;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. innerHTML 创建元素</span></span><br><span class="line">        <span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.inner&#x27;</span>);</span><br><span class="line">        <span class="comment">// for (var i = 0; i &lt;= 100; i++) &#123;</span></span><br><span class="line">			   <span class="comment">// 拼接字符串的方式效率低	</span></span><br><span class="line">        <span class="comment">//     inner.innerHTML += &#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">		<span class="comment">// 数组形式拼接，效率高</span></span><br><span class="line">        <span class="keyword">var</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            arr.push(<span class="string">&#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inner.innerHTML = arr.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="comment">// 3. document.createElement() 创建元素</span></span><br><span class="line">        <span class="keyword">var</span> create = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.create&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            create.appendChild(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h5 id="2-5、算法思想"><a href="#2-5、算法思想" class="headerlink" title="2.5、算法思想"></a>2.5、算法思想</h5><ul>
<li><p>排它思想算法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适用: 如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法</span></span><br><span class="line"><span class="comment"> * 步骤: </span></span><br><span class="line"><span class="comment"> * 1、所有元素全部清除样式（干掉其他人）</span></span><br><span class="line"><span class="comment"> * 2、给当前元素设置样式 （留下我自己）</span></span><br><span class="line"><span class="comment"> * 注意: 注意顺序不能颠倒，首先干掉其他人，再设置自己</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;按钮<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;按钮<span class="number">2</span>&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;按钮<span class="number">3</span>&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;按钮<span class="number">4</span>&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;按钮<span class="number">5</span>&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 1. 获取所有按钮元素</span></span><br><span class="line">        <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        <span class="comment">// btns 得到的是伪数组，里面的每一个元素 btns[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">            btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// (1) 我们先把所有的按钮背景颜色去掉: 干掉所有人</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">                    btns[i].style.backgroundColor = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// (2) 然后才让当前的元素背景颜色为pink: 留下我自己</span></span><br><span class="line">                <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 首先先排除其他人，然后才设置自己的样式，这种排除其他人的思想我们成为排他思想</span></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2-6、顶级对象"><a href="#2-6、顶级对象" class="headerlink" title="2.6、顶级对象"></a>2.6、顶级对象</h5><p>DOM：document</p>
<p>BOM：window</p>
<h5 id="2-7、window-对象常见事件"><a href="#2-7、window-对象常见事件" class="headerlink" title="2.7、window 对象常见事件"></a>2.7、window 对象常见事件</h5><ul>
<li><p>页面（窗口）加载事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 形式 1 : window.onload = function() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * 形式 2 : window.addEventListener(&quot;load&quot;, function() &#123;&#125;)</span></span><br><span class="line"><span class="comment"> * 说明: 窗口 (页面）加载事件，当文档内容完全加载完成会触发该事件, 就调用处理函数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 形式 3 : window.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;&#125;)</span></span><br><span class="line"><span class="comment"> * 说明: 窗口 (页面）加载事件，当文档内容不完全加载完成会触发该事件, 就调用处理函数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// window.onload = function() &#123;</span></span><br><span class="line">        <span class="comment">//     var btn = document.querySelector(&#x27;button&#x27;);</span></span><br><span class="line">        <span class="comment">//     btn.addEventListener(&#x27;click&#x27;, function() &#123;</span></span><br><span class="line">        <span class="comment">//         alert(&#x27;点击我&#x27;);</span></span><br><span class="line">        <span class="comment">//     &#125;)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// window.onload = function() &#123;</span></span><br><span class="line">        <span class="comment">//     alert(22);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">            btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="string">&#x27;点击我&#x27;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            alert(<span class="number">22</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="number">33</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// load 等页面内容全部加载完毕，包含页面dom元素 图片 flash  css 等等</span></span><br><span class="line">            <span class="comment">// DOMContentLoaded 是DOM 加载完毕，不包含图片 falsh css 等就可以执行 加载速度比 load更快一些</span></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整窗口大小事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 形式 1 : window.onresize = function() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * 形式 2 : window.addEventListener(&quot;resize&quot;, function() &#123;&#125;)</span></span><br><span class="line"><span class="comment"> * 说明: 调整窗口大小加载事件，当触发时就调用的处理函数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;变化了&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">window</span>.innerWidth &lt;= <span class="number">800</span>) &#123;</span><br><span class="line">                    div.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    div.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2-8、定时器"><a href="#2-8、定时器" class="headerlink" title="2.8、定时器"></a>2.8、定时器</h5><p>回调函数：简单理解，就是过一会才会调用（回头再调用）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置: setTimeout(回调函数, [间隔的毫秒数]) </span></span><br><span class="line"><span class="comment"> * 执行次数: 一次</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 1. setTimeout </span></span><br><span class="line">        <span class="comment">// 语法规范: window.setTimeout(调用函数, 延时时间);</span></span><br><span class="line">        <span class="comment">// 1. 这个 window 在调用的时候可以省略</span></span><br><span class="line">        <span class="comment">// 2. 这个延时时间单位是毫秒 但是可以省略，如果省略默认的是 0</span></span><br><span class="line">        <span class="comment">// 3. 这个调用函数可以直接写函数 还可以写 函数名 还有一个写法 &#x27;函数名()&#x27;</span></span><br><span class="line">        <span class="comment">// 4. 页面中可能有很多的定时器，我们经常给定时器加标识符 （名字)</span></span><br><span class="line">        <span class="comment">// setTimeout(function() &#123;</span></span><br><span class="line">        <span class="comment">//     console.log(&#x27;时间到了&#x27;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#125;, 2000);</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;爆炸了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> timer1 = <span class="built_in">setTimeout</span>(callback, <span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">var</span> timer2 = <span class="built_in">setTimeout</span>(callback, <span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// setTimeout(&#x27;callback()&#x27;, 3000); // 我们不提倡这个写法</span></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停止: clearTimeout(&#x27;定时器名称&#x27;)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;点击停止定时器&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;爆炸了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置: setInterval(回调函数, [间隔的毫秒数]) </span></span><br><span class="line"><span class="comment"> * 执行次数: 多次（反复）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;继续输出&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停止: clearInterval(&#x27;定时器名称&#x27;)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;begin&quot;</span>&gt;开启定时器&lt;/button&gt;</span><br><span class="line">    &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;stop&quot;</span>&gt;停止定时器&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> begin = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.begin&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> stop = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.stop&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 全局变量  null是一个空对象</span></span><br><span class="line">        begin.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;ni hao ma&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        stop.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-9、this"><a href="#2-9、this" class="headerlink" title="2.9、this"></a>2.9、this</h5><p>指向问题</p>
<p>1、全局作用域或者普通函数中：this -&gt; window</p>
<p>2、定时器：this -&gt; window</p>
<p>3、方法调用中：this -&gt; 调用者</p>
<p>4、构造函数中：this -&gt; 构造函数的实例</p>
<h5 id="2-10、location-对象"><a href="#2-10、location-对象" class="headerlink" title="2.10、location 对象"></a>2.10、location 对象</h5><p>作用：用于获取或设置窗体的 URL，并且可以解析 URL</p>
<p>主要属性：href（返回整个 URL）, search（返回参数）</p>
<p>常见方法</p>
<ul>
<li>页面跳转（重定向），可回退页面: location.assign(‘页面地址’)</li>
<li>页面跳转（重定向），不可回退页面: location.replace(‘页面地址’)</li>
<li>页面刷新: location.reload()，若带参数 true，则为强制刷新</li>
</ul>
<h5 id="2-11、navigator-对象"><a href="#2-11、navigator-对象" class="headerlink" title="2.11、navigator 对象"></a>2.11、navigator 对象</h5><p>作用：包含有关浏览器的信息，借此可以判断用户那个终端打开页面，实现跳转</p>
<p>最常用属性：userAgent，可以返回由客户机发送服务器的 user-agent 头部的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断用户那个终端打开页面，实现跳转</span></span><br><span class="line"><span class="keyword">if</span>((navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">&quot;&quot;</span>;     <span class="comment">//手机</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">&quot;&quot;</span>;     <span class="comment">//电脑</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-12、元素偏移量-offset"><a href="#2-12、元素偏移量-offset" class="headerlink" title="2.12、元素偏移量 offset"></a>2.12、元素偏移量 offset</h5><ul>
<li><p>作用：<strong>动态</strong>的得到该元素的位置（偏移）、大小（宽度高度）等</p>
</li>
<li><p>注意：返回的数值都不带单位</p>
</li>
<li><p>常用属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824204307.png"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824204330.png"> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;father&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;son&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;w&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// offset 系列</span></span><br><span class="line">        <span class="keyword">var</span> father = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>);</span><br><span class="line">        <span class="comment">// 1. 可以得到元素的偏移，位置，返回的不带单位的数值  </span></span><br><span class="line">        <span class="built_in">console</span>.log(father.offsetTop);</span><br><span class="line">        <span class="built_in">console</span>.log(father.offsetLeft);</span><br><span class="line">        <span class="comment">// 它以带有定位的父亲为准，如果没有父亲或者父亲没有定位，则以 body 为准</span></span><br><span class="line">        <span class="built_in">console</span>.log(son.offsetLeft);</span><br><span class="line">        <span class="keyword">var</span> w = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.w&#x27;</span>);</span><br><span class="line">        <span class="comment">// 2. 可以得到元素的大小，宽度和高度，是包含 padding + border + width </span></span><br><span class="line">        <span class="built_in">console</span>.log(w.offsetWidth);</span><br><span class="line">        <span class="built_in">console</span>.log(w.offsetHeight);</span><br><span class="line">        <span class="comment">// 3. 返回带有定位的父亲，否则返回的是 body</span></span><br><span class="line">        <span class="built_in">console</span>.log(son.offsetParent); <span class="comment">// 返回带有定位的父亲 否则返回的是body</span></span><br><span class="line">        <span class="built_in">console</span>.log(son.parentNode); <span class="comment">// 返回父亲，是最近一级的父亲: 亲爸爸，不管父亲有没有定位</span></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>offset 与 style 的区别</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * offset</span></span><br><span class="line"><span class="comment"> * 1、offset 可以得到任意样式表中的样式值</span></span><br><span class="line"><span class="comment"> * 2、offset 系列获得的数值是没有单位的</span></span><br><span class="line"><span class="comment"> * 3、offsetWidth 包含 padding+border+width</span></span><br><span class="line"><span class="comment"> * 4、offsetWidth 等属性是只读属性，只能获取不能赋值</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * style</span></span><br><span class="line"><span class="comment"> * 1、style 只能得到行内样式表中的样式值</span></span><br><span class="line"><span class="comment"> * 2、style.width 获得的是带有单位的字符串</span></span><br><span class="line"><span class="comment"> * 3、style.width 获得不包含 padding 和 border 的值</span></span><br><span class="line"><span class="comment"> * 4、style.width 是可读写属性，可以获取也可以赋值</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结: 想要获取元素大小位置，用 offset 更合适，想要给元素更改值，则需要用 style 改变</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2-13、元素可视区-client"><a href="#2-13、元素可视区-client" class="headerlink" title="2.13、元素可视区 client"></a>2.13、元素可视区 client</h5><ul>
<li>作用：<strong>动态</strong>的得到该元素的边框大小、元素大小</li>
<li>注意：返回的数值都不带单位</li>
<li>常用属性</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824203946.png"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824204133.png"> </p>
<h5 id="2-14、元素滚动-scroll"><a href="#2-14、元素滚动-scroll" class="headerlink" title="2.14、元素滚动 scroll"></a>2.14、元素滚动 scroll</h5><ul>
<li><p>作用：<strong>动态</strong>的得到该元素的大小、滚动距离</p>
</li>
<li><p>注意：返回的数值都不带单位，<strong>自身实际宽高</strong></p>
</li>
<li><p>常用属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824204207.png"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824203528.png"> </p>
</li>
</ul>
<h5 id="2-15、offset、client-和-scroll-总结"><a href="#2-15、offset、client-和-scroll-总结" class="headerlink" title="2.15、offset、client 和 scroll 总结"></a>2.15、offset、client 和 scroll 总结</h5><blockquote>
<p>区分记忆技巧：offset -&gt; client  -&gt; scroll，宽高内容，逐个减少</p>
</blockquote>
<ul>
<li>offsetWidth / Height：内容区域的宽高 + padding + 边框</li>
<li>clientWidth / Height：内容区域的宽高 + padding</li>
<li>scrollWidth / Height：内容区域的宽高（内容自身实际）</li>
</ul>
<blockquote>
<p>应用记忆技巧：位置（offset）、大小（client）和 距离（scroll）</p>
</blockquote>
<ul>
<li><p>offsetLeft / top：常用于获取元素的位置</p>
</li>
<li><p>clientWidth / Height：常用于获取元素大小</p>
</li>
<li><p>scrollLeft / top：常用于获取滚动距离</p>
</li>
</ul>
<blockquote>
<p><strong>注意：页面滚动的距离通过 window.pageX（Y）Offset  获得，不要和元素的混淆</strong></p>
</blockquote>
<h5 id="2-16、动画函数封装"><a href="#2-16、动画函数封装" class="headerlink" title="2.16、动画函数封装"></a>2.16、动画函数封装</h5><p>Js 动画原理：通过定时器 setInterval() 不断移动盒子位置</p>
<p>动画实现步骤：</p>
<ul>
<li><p>获得盒子当前位置</p>
</li>
<li><p>让盒子在当前位置加上 1 个移动距离</p>
</li>
<li><p>核心原理：移动距离固定：匀速动画，移动距离不固定且按特定算法：缓动动画</p>
</li>
<li><p>利用定时器不断重复这个操作</p>
</li>
<li><p>加一个结束定时器的条件</p>
</li>
<li><p>注意此元素需要添加定位，才能使用element.style.left</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// js 动画原理</span></span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (div.offsetLeft &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                <span class="comment">// 停止动画 本质是停止定时器</span></span><br><span class="line">                <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 匀速动画为例子</span></span><br><span class="line">            div.style.left = div.offsetLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        &#125;, <span class="number">30</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单封装</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;span&gt;&lt;/span&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 明确参数及功能</span></span><br><span class="line">        <span class="comment">// 简单动画函数封装obj目标对象 target 目标位置</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj, target</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (obj.offsetLeft &gt;= target) &#123;</span><br><span class="line">                    <span class="comment">// 停止动画 本质是停止定时器</span></span><br><span class="line">                    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">                obj.style.left = obj.offsetLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> span = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        <span class="comment">// 调用函数</span></span><br><span class="line">        animate(div, <span class="number">300</span>);</span><br><span class="line">        animate(span, <span class="number">200</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2-17、移动端"><a href="#2-17、移动端" class="headerlink" title="2.17、移动端"></a>2.17、移动端</h5><p>移动端特点：兼容性较好，不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果</p>
<ul>
<li><p>触屏事件：touch</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824203816.png"> </p>
</li>
<li><p>触摸事件对象：TouchEvent</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200824203853.png"> </p>
<p>注意：touches 是同时触摸屏幕的手指数列表，targetTouches 是触摸 DOM 元素的手指数列表，但如果两者侦听的是同一个元素，那么结果是一模一样的，所以 targetTouches 用的多一些</p>
</li>
<li><p>拖动元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、touchstart、touchmove、touchend 可以实现拖动元素</span></span><br><span class="line"><span class="comment"> * 2、当前手指的坐标值: targetTouches[0] 里面的 pageX 和 pageY</span></span><br><span class="line"><span class="comment"> * 3、拖动元素三步曲:</span></span><br><span class="line"><span class="comment"> *	(1)、触摸元素 touchstart: 获取手指初始坐标（e.targetTouches[0].pageX / Y），同时获得盒子原来的位置（this.offsetLeft / Top）</span></span><br><span class="line"><span class="comment"> *	(2)、移动手指 touchmove: 计算手指的滑动距离（e.targetTouches[0].pageX / Y - 手指初始坐标），并且移动盒子，移动后盒子的位置: 盒子原来的位置 + 手指的滑动距离</span></span><br><span class="line"><span class="comment"> *	(3)、离开手指 touchend</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault()</span></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// （1） 触摸元素 touchstart: 获取手指初始坐标，同时获得盒子原来的位置</span></span><br><span class="line">        <span class="comment">// （2） 移动手指 touchmove: 计算手指的滑动距离，并且移动盒子</span></span><br><span class="line">        <span class="comment">// （3） 离开手指 touchend</span></span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> startX = <span class="number">0</span>; <span class="comment">//获取手指初始坐标</span></span><br><span class="line">        <span class="keyword">var</span> startY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">0</span>; <span class="comment">//获得盒子原来的位置</span></span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line">        div.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//  获取手指初始坐标</span></span><br><span class="line">            startX = e.targetTouches[<span class="number">0</span>].pageX;</span><br><span class="line">            startY = e.targetTouches[<span class="number">0</span>].pageY;</span><br><span class="line">            x = <span class="built_in">this</span>.offsetLeft;</span><br><span class="line">            y = <span class="built_in">this</span>.offsetTop;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        div.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//  计算手指的移动距离： 手指移动之后的坐标减去手指初始的坐标</span></span><br><span class="line">            <span class="keyword">var</span> moveX = e.targetTouches[<span class="number">0</span>].pageX - startX;</span><br><span class="line">            <span class="keyword">var</span> moveY = e.targetTouches[<span class="number">0</span>].pageY - startY;</span><br><span class="line">            <span class="comment">// 移动我们的盒子 盒子原来的位置 + 手指移动的距离</span></span><br><span class="line">            <span class="built_in">this</span>.style.left = x + moveX + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.style.top = y + moveY + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            e.preventDefault(); <span class="comment">// 阻止屏幕滚动的默认行为</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>click 点击事件 300ms 延时</p>
</li>
<li><p>原因：移动端屏幕双击会缩放(double tap to zoom) 页面</p>
</li>
<li><p>解决方案：</p>
<p>1、禁用缩放</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;user-scalable=no&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>2、利用 touch事件 自己封装</p>
<p>3、使用 fastclick 插件</p>
</li>
</ul>
<h4 id="3、本地存储"><a href="#3、本地存储" class="headerlink" title="3、本地存储"></a>3、本地存储</h4><blockquote>
<p>特性</p>
</blockquote>
<ul>
<li>数据存储在用户浏览器中</li>
<li>设置、读取方便、甚至页面刷新不丢失数据</li>
<li>容量较大，sessionStorage 约 5M、localStorage 约 20M</li>
<li>只能存储字符串，可以将对象 JSON.stringify() 编码后存储</li>
</ul>
<blockquote>
<p>window.sessionStorage</p>
</blockquote>
<ul>
<li><p>生命周期：关闭浏览器窗口</p>
</li>
<li><p>在同一个窗口（页面）下数据可以共享</p>
</li>
<li><p>以键值对的形式存储使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储数据</span></span><br><span class="line">sessionStorage.setItem(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">sessionStorage.getItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">sessionStorage.removeItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空数据（所有都清除掉）</span></span><br><span class="line">sessionStorage.clear()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>window.localStorage</p>
</blockquote>
<ul>
<li><p>生命周期：永久生效，除非手动删除，否则关闭页面也会存在</p>
</li>
<li><p>可以多窗口（页面）共享（同一浏览器可以共享）</p>
</li>
<li><p>以键值对的形式存储使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储数据</span></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="built_in">localStorage</span>.getItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="built_in">localStorage</span>.removeItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空数据（所有都清除掉）</span></span><br><span class="line"><span class="built_in">localStorage</span>.clear()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4、JS-进阶"><a href="#4、JS-进阶" class="headerlink" title="4、JS 进阶"></a>4、JS 进阶</h4>

	<div class="row">
    <embed src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/pdf/JavaScript.pdf" width="100%" height="550" type="application/pdf">
	</div>




<p><strong>更多详情，请收藏本博主，持续更新……谢谢！</strong></p>
<p>当然，如果您觉得此篇对您有所帮助，想请博主喝杯咖啡，请点击下方按钮，打开您的手机扫一扫，感谢您对本博主的赏识，博主感激不尽！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>学习笔记</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之设计模式</title>
    <url>/JS%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>JS 是一门弱化的面向对象编程语言，但具备面向对象编程的思想，其中三大要素十分的重要。</p>
<p><strong>继承</strong></p>
<p>理解：儿子继承家产</p>
<p>特点：一个父类，是公共的，不仅仅服务于一个子类，即：一个父亲有多个孩子，这多个孩子均可以继承家产</p>
<p>好处：继承可以将公共方法抽离出来，提高复用，减少冗余，即：做富二代，你懂的</p>
<p><strong>封装</strong></p>
<p>ES6 暂时还不支持 public 等的关键字，所以想了解的请移步：TypeScript</p>
<p><strong>多态</strong></p>
<p>ES6 暂时还不支持 public 等的关键字，所以想了解的请移步：TypeScript</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p><strong>概念：将 new 操作单独封装</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要生产的产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">	    <span class="built_in">this</span>.name = name</span><br><span class="line">	&#125;</span><br><span class="line">	fn1() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;挣钱&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fn2() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;便利生活&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产该产品的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line">	create(name) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Product(name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ‘我’ 要做的事情</span></span><br><span class="line"><span class="keyword">let</span> creator = <span class="keyword">new</span> Creator()				<span class="comment">// 1、找到这么一家工厂</span></span><br><span class="line"><span class="keyword">let</span> p = Creator.create(<span class="string">&#x27;javascript&#x27;</span>)	 <span class="comment">// 2、告诉这家工厂，要生产的产品</span></span><br><span class="line"><span class="comment">// 利用这个生产出来的产品去挣钱等行为</span></span><br><span class="line">p.fn1()		<span class="comment">// 挣钱</span></span><br><span class="line">p.fn2()		<span class="comment">// 给生活带来便利</span></span><br></pre></td></tr></table></figure>

<p><strong>结合应用场景去理解</strong></p>
<p>jQuery 中的核心函数，不熟悉的可以去看我的另一篇笔记：<a href="https://guohaoqi.com/jQuery%E4%B9%8B%E5%9B%9E%E5%BF%86%E7%AF%87/">jQuery 之回忆篇</a>。我们一个深的体会就是：jQuery 的核心函数可以接收不同的参数，进而我们可以得到一个 jQuery 对象，我们可以基于 jQuery 这个对象，调用各种 jQuery 方法去实现我们的需求，是的，这就是库，操作呢也就是：调库，其实工厂模式的思想就是我们平时接触较多的库的封装，我们不需要关注库是怎么封装和实现的，我们需要知道的是这个库的各个方法的作用，这就需要去看相关库的文档，从而利用相关的方法去实现我们的需求。</p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript之数据结构与算法</title>
    <url>/JavaScript%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>开场白也不多说了，数据结构与算法这东西，说多了都是泪，干就完了！</p>
<h3 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h3><blockquote>
<p>Tips：官方的概念不做赘述</p>
</blockquote>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>理解：执行次数 == 时间，次数越多越复杂，反之越简单</p>
<p>表示：大 O 表示法</p>
<p>大 O 阶推导技巧：抽象法</p>
<ul>
<li><p><strong>用常数 1 取代运行时间中的所有加法常数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度记为：O(1)</span></span><br><span class="line"><span class="comment"> * 1 + 1 + 1 -&gt; 用常数 1 取代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>, n = <span class="number">100</span>	<span class="comment">// 执行 1 次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>	<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="built_in">console</span>.log(sum)	    <span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在修改后的运行次数函数中，只保留最高阶项，如果最高阶项存在且不是 1，则去除与这个项相乘的常数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度记为：O(n^2)</span></span><br><span class="line"><span class="comment"> * 实际的时间复杂度：n^2/2 + n/2</span></span><br><span class="line"><span class="comment"> * 	1、只保留最高阶项：去掉 n/2，得 n^2/2</span></span><br><span class="line"><span class="comment"> *	2、最高阶项存在且不是 1：去掉 1/2，得 n^2 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> i, j, n = <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sunny&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对数阶，主要是如下所示两种</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20206986694475.PNG"> </p>
</li>
</ul>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>理解：事先就开辟一片内存空间，存储好对应的结果值，就像 ASCLL 表，事先做好了，需要的时候做个结果对应就好了，其复杂度取决于所开辟的空间大小，即：程序运行所需要占据的内存大小</p>
<p>表示：大 O 表示法</p>
<h4 id="设计算法原则"><a href="#设计算法原则" class="headerlink" title="设计算法原则"></a>设计算法原则</h4><p>时间开销换取空间开销，还是反之，请君去思考了，但貌似<strong>时间开销才是主流</strong></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>特点：<strong>后进先出</strong></p>
<p>注意：JavaScript 中没有栈，但可以利用 Array 来模拟实现栈的所有功能</p>
<blockquote>
<p>常见操作</p>
</blockquote>
<p>入栈：push    出栈：pop    栈顶元素：stack[stack.length - 1]</p>
<blockquote>
<p>前端中与栈的联系</p>
</blockquote>
<p>函数调用堆栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> func1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    func2();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    func3();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func3 = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">func1();	<span class="comment">// 1 调用 2，2 调用 3 - 3 释放完 2，2 释放完 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>算法题</p>
</blockquote>
<p>【LeetCode - 20】有效的括号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery之回忆篇</title>
    <url>/jQuery%E4%B9%8B%E5%9B%9E%E5%BF%86%E7%AF%87/</url>
    <content><![CDATA[<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><blockquote>
<p>原生 JS</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>jQuery</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;hello world!&quot;);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;hello world!&quot;);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法 (推荐)</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;hello world!&quot;);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.第四种写法</span></span><br><span class="line">jQuery(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>原生 JS 与 jQuery 入口函数的区别</p>
<ul>
<li>原生 JS 和 jQuery 入口函数的<code>加载模式不同</code>：原生 JS 会等到 DOM 元素加载完毕，并且图片也加载完毕才会执行；jQuery 会等到 DOM 元素加载完毕,但不会等到图片也加载完毕就会执行</li>
<li>原生的 JS 如果编写了多个入口函数，后面编写的<code>会</code>覆盖前面编写的；jQuery 中编写多个入口函数，后面的<code>不会</code>覆盖前面的</li>
</ul>
<p><code>注意：$ 符合冲突问题解决方式</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 1：释放 $ 的使用权</span></span><br><span class="line"><span class="comment"> *	- 释放操作必须在编写其它 jQuery 代码之前编写</span></span><br><span class="line"><span class="comment"> *  - 释放之后就不能再使用 $，改为使用 jQuery</span></span><br><span class="line"><span class="comment"> *  - jQuery 原理 .noConflict();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jQuery.noConflict();</span><br><span class="line">jQuery(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello sunny&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 2：自定义一个访问符号，如：sunny</span></span><br><span class="line"><span class="keyword">var</span> sunny = jQuery.noConflict();</span><br><span class="line">sunny(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello sunny&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $ 函数执行</span></span><br><span class="line">$();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于原生普通函数调用执行，如: test()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可接收参数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、接收一个函数，即：入口函数</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、接收一个字符串</span></span><br><span class="line"><span class="comment">     *	- 2.1、接收一个字符串选择器，返回一个 jQuery 对象, 对象中保存了找到的 DOM 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> $box1 = $(<span class="string">&quot;.box1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log($box1);</span><br><span class="line">    <span class="comment">// 2.2、接收一个字符串代码片段，返回一个 jQuery 对象, 对象中保存了创建的 DOM 元素</span></span><br><span class="line">    <span class="keyword">var</span> $p = $(<span class="string">&quot;&lt;p&gt;我是段落&lt;/p&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log($p);</span><br><span class="line">    $box1.append($p);</span><br><span class="line">    <span class="comment">// 3、接收一个 DOM 元素，会被包装成一个 jQuery 对象返回</span></span><br><span class="line">    <span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;span&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(span);</span><br><span class="line">    <span class="keyword">var</span> $span = $(span);</span><br><span class="line">    <span class="built_in">console</span>.log($span);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="jQ-对象"><a href="#jQ-对象" class="headerlink" title="jQ 对象"></a>jQ 对象</h3><p>jQuery 对象是一个伪数组（有 0 到 length-1 的属性, 并且有 length 属性）</p>
<blockquote>
<p>jQ 对象转 DOM 对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、[index] 角标法</span></span><br><span class="line"><span class="keyword">var</span> v = $v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、.get(index) 获取角标法</span></span><br><span class="line"><span class="keyword">var</span> v = $v.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DOM 对象转 jQ 对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 DOM 对象以参数形式传递给 jQ 核心函数</span></span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;span&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> $span = $(span);</span><br></pre></td></tr></table></figure>

<h3 id="jQ-方法"><a href="#jQ-方法" class="headerlink" title="jQ 方法"></a>jQ 方法</h3><p>具体参考文档：<a href="https://jquery.cuishifeng.cn/">jQuery API</a></p>
<blockquote>
<p>常用静态方法</p>
</blockquote>
<p>each：遍历</p>
<p>map：遍历</p>
<p><strong>两者的区别：</strong></p>
<ul>
<li>each 静态方法默认的返回值就是，<code>遍历谁就返回谁</code>；map 静态方法默认的返回值是一个<code>空数组</code></li>
<li>each 静态方法<code>不支持</code>在回调函数中对遍历的数组进行处理；map 静态方法<code>可以在回调函数中通过 return 对遍历的数组进行处理</code>，然后<code>生成一个新的数组返回</code></li>
</ul>
<p>trim：去除字符串两端的空格</p>
<p>isWindow：判断传入的对象是否是 window 对象</p>
<p>isArray：判断传入的对象是否是真数组</p>
<p>isFunction：判断传入的对象是否是一个函数</p>
<p>holdReady：暂停 ready 执行</p>
<h3 id="jQ-选择器"><a href="#jQ-选择器" class="headerlink" title="jQ 选择器"></a>jQ 选择器</h3><p>具体参考文档：<a href="https://jquery.cuishifeng.cn/">jQuery API</a></p>
<h3 id="属性（节点）操作"><a href="#属性（节点）操作" class="headerlink" title="属性（节点）操作"></a>属性（节点）操作</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>属性：对象身上保存的变量就是属性</p>
<p>属性节点：HTML 标签中添加的属性就是属性节点</p>
<p>获取到 DOM 元素后，两者的形式：浏览器中找到对应 DOM 元素，展开看到的都是属性，在 attributes 属性中保存的所有内容都是属性节点</p>
<p><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/typora/20200801194475.PNG"> </p>
<p>属性和属性节点的区别：任何对象都有属性, 但是只有 DOM 对象才有属性节点</p>
<h4 id="原生-JS-操作"><a href="#原生-JS-操作" class="headerlink" title="原生 JS  操作"></a>原生 JS  操作</h4><p><strong>属性操作</strong></p>
<ul>
<li>赋值：对象.属性名称 = 值; 或者 对象[“属性名称”] = 值;</li>
<li>取值：对象.属性名称; 或者 对象[“属性名称”];</li>
</ul>
<p><strong>属性节点操作</strong></p>
<ul>
<li>赋值：DOM 元素.setAttribute(“属性名称”, “值”);</li>
<li>取值：DOM元素.getAttribute(“属性名称”);</li>
</ul>
<h4 id="jQuery-操作"><a href="#jQuery-操作" class="headerlink" title="jQuery 操作"></a>jQuery 操作</h4><p><strong>属性节点操作</strong></p>
<p>attr()：获取或者设置属性节点的值</p>
<p>可以传递一个参数，也可以传递两个参数</p>
<ul>
<li>如果传递一个参数，代表<code>获取</code>属性节点的值</li>
<li>如果传递两个参数，代表<code>设置</code>属性节点的值</li>
</ul>
<p>注意：</p>
<ul>
<li>如果是<code>获取</code>：无论找到多少个元素，都只会返回第一个元素指定的属性节点的值</li>
<li>如果是<code>设置</code>：找到多少个元素就会设置多少个元素</li>
<li>如果是<code>设置</code>：如果设置的属性节点不存在，那么系统会自动新增</li>
</ul>
<p>removeAttr()：删除属性节点</p>
<p>注意：会删除<code>所有</code>找到元素<code>指定的属性节点</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除的属性节点可以多个，用空格隔开</span></span><br><span class="line">$(<span class="string">&quot;span&quot;</span>).removeAttr(<span class="string">&quot;class name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>属性操作</strong></p>
<p>prop()：特点和 attr 方法一致</p>
<p>removeProp()：特点和 removeAttr 方法一致</p>
<p>注意：prop 方法既能够操作属性，还能操作属性节点</p>
<p><strong>官方推荐：在操作属性节点时，具有 true 和 false 两个属性的属性节点，如 checked，selected 或者 disabled 使用 prop()，其他的使用 attr()</strong></p>
<h3 id="CSS-操作"><a href="#CSS-操作" class="headerlink" title="CSS 操作"></a>CSS 操作</h3><h4 id="CSS-类样式操作"><a href="#CSS-类样式操作" class="headerlink" title="CSS 类样式操作"></a>CSS 类样式操作</h4><p>添加类样式：addClass(class)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加一个类，如果要添加多个, 多个类名之间用空格隔开即可</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).addClass(<span class="string">&quot;class1 class2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>删除类样式：removeClass(class)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除一个类，如果想删除多个, 多个类名之间用空格隔开即可</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).removeClass(<span class="string">&quot;class2 class1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>切换类样式：toggleClass(class)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有就删除, 没有就添加（切换 添加和删除类）</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).toggleClass(<span class="string">&quot;class2 class1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="CSS-样式操作"><a href="#CSS-样式操作" class="headerlink" title="CSS 样式操作"></a>CSS 样式操作</h4><p>设置样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、逐个设置</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;width&quot;</span>, <span class="string">&quot;100px&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;height&quot;</span>, <span class="string">&quot;100px&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、链式设置</span></span><br><span class="line"><span class="comment"> *  - 注意点: 链式操作如果大于 3 步, 建议分开，不然可阅读性差</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;width&quot;</span>, <span class="string">&quot;100px&quot;</span>).css(<span class="string">&quot;height&quot;</span>, <span class="string">&quot;100px&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、批量设置，传入一个对象进行</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).css(&#123;</span><br><span class="line">    width: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">    height: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">    background: <span class="string">&quot;red&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获取样式值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;background&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="文本值操作"><a href="#文本值操作" class="headerlink" title="文本值操作"></a>文本值操作</h3><h4 id="HTML-文本操作"><a href="#HTML-文本操作" class="headerlink" title="HTML 文本操作"></a>HTML 文本操作</h4><p>注意：html() 等效于原生的 innerHTML</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 HTML 文本</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).html(<span class="string">&quot;&lt;p&gt;我是段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 HTML 文本</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).html();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 HTML 文本</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).html(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="普通文本操作"><a href="#普通文本操作" class="headerlink" title="普通文本操作"></a>普通文本操作</h4><p>注意：text() 等效于原生的 innerText</p>
<p>用法同上</p>
<p>文本值操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置文本框值</span></span><br><span class="line">$(<span class="string">&quot;input&quot;</span>).val(<span class="string">&quot;请输入内容&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文本框值</span></span><br><span class="line">$(<span class="string">&quot;input&quot;</span>).val();</span><br></pre></td></tr></table></figure>

<h3 id="位置和尺寸操作"><a href="#位置和尺寸操作" class="headerlink" title="位置和尺寸操作"></a>位置和尺寸操作</h3><h4 id="尺寸相关"><a href="#尺寸相关" class="headerlink" title="尺寸相关"></a>尺寸相关</h4><p>元素的宽度（就是 width，不包括别的）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line">$(<span class="string">&quot;.father&quot;</span>).width();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">$(<span class="string">&quot;.father&quot;</span>).width(<span class="string">&quot;500px&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其它具体参考文档：<a href="https://jquery.cuishifeng.cn/">jQuery API</a></p>
<h4 id="位置相关"><a href="#位置相关" class="headerlink" title="位置相关"></a>位置相关</h4><p>元素<code>距离窗口的偏移位</code>，left 表示指定获取哪个方向的偏移位：offset()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line">$(<span class="string">&quot;.son&quot;</span>).offset().left;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">$(<span class="string">&quot;.son&quot;</span>).offset(&#123;</span><br><span class="line">    left: <span class="number">10</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>元素距离<code>定位元素</code>的偏移位：position()</p>
<p>注意：position方法只能获取不能设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line">$(<span class="string">&quot;.son&quot;</span>).position().left;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置，别的方式撒，如</span></span><br><span class="line">$(<span class="string">&quot;.son&quot;</span>).css(&#123;</span><br><span class="line">    left: <span class="string">&quot;10px&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="滚动相关"><a href="#滚动相关" class="headerlink" title="滚动相关"></a>滚动相关</h4><p><code>元素内部</code>滚动的偏移位</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line">$(<span class="string">&quot;.scroll&quot;</span>).scrollTop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">$(<span class="string">&quot;.scroll&quot;</span>).scrollTop(<span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<p><code>网页</code>滚动的偏移位</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取（注意点: 为了保证浏览器的兼容，获取网页滚动的偏移位需要按照如下写法）</span></span><br><span class="line">$(<span class="string">&quot;body&quot;</span>).scrollTop() + $(<span class="string">&quot;html&quot;</span>).scrollTop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置（注意点: 为了保证浏览器的兼容, 设置网页滚动偏移位的时候必须按照如下写法）</span></span><br><span class="line">$(<span class="string">&quot;html,body&quot;</span>).scrollTop(<span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<h3 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h3><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式 1 : 部分事件 jQuery 没有实现,所以不能添加</span></span><br><span class="line">事件源.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 2 : 所有 js 事件都可以添加</span></span><br><span class="line">事件源.on(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;);</span><br><span class="line">                             </span><br><span class="line"><span class="comment">// 方式 3 : 所有 js 事件都可以添加，并支持链式绑定</span></span><br><span class="line">最外层事件源.on(<span class="string">&quot;click&quot;</span>, <span class="string">&#x27;指定事件源&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式 1 : 移除该事件源上绑定的所有事件</span></span><br><span class="line">事件源.off();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 2 : 移除该事件源上绑定的具体事件，如 click</span></span><br><span class="line">事件源.off(<span class="string">&quot;click&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 3 : 移除该事件源上绑定的具体事件以及具体处理函数，如 click test1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello lnj&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">事件源.click(test1);</span><br><span class="line">事件源.off(<span class="string">&quot;click&quot;</span>, test1);</span><br></pre></td></tr></table></figure>

<h4 id="阻止事件冒泡和默认行为"><a href="#阻止事件冒泡和默认行为" class="headerlink" title="阻止事件冒泡和默认行为"></a>阻止事件冒泡和默认行为</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻止事件冒泡</span></span><br><span class="line"><span class="comment"> * 	- 方式 1 : return false</span></span><br><span class="line"><span class="comment"> *  - 方式 2 : event.stopPropagation()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$(<span class="string">&quot;.son&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻止默认行为</span></span><br><span class="line"><span class="comment"> * 	- 方式 1 : return false</span></span><br><span class="line"><span class="comment"> *  - 方式 2 : event.preventDefault()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$(<span class="string">&quot;a&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;弹出注册框&quot;</span>);</span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="事件自动触发"><a href="#事件自动触发" class="headerlink" title="事件自动触发"></a>事件自动触发</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">方式 一 : 事件源.trigger(<span class="string">&quot;对应事件&quot;</span>);</span><br><span class="line"></span><br><span class="line">方式 二 : 事件源.triggerHandler(<span class="string">&quot;对应事件&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：自动触发事件，可以传参，如：事件源.trigger(&quot;对应事件&quot;, &#x27;options&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>两者的区别</p>
<ul>
<li>trigger 会触发事件冒泡，triggerHandler 不会</li>
<li>trigger 会触发默认行为，triggerHandler 不会</li>
</ul>
<p><strong>注意：当事件源为 a 标签的时候，想利用 trigger 既触发事件冒泡又触发默认行为时，需要在 a 标签内部添加一个 span 标签，并把 span 作为事件源</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;span&quot;</span>).trigger(<span class="string">&quot;click&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>原理：利用 trigger 自动触发事件进行</p>
<p>需要满足两个条件</p>
<ul>
<li>事件必须是通过 on 绑定的</li>
<li>事件必须通过 trigger 来触发</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.son&quot;</span>).on(<span class="string">&quot;myClick&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;.son&quot;</span>).triggerHandler(<span class="string">&quot;myClick&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事件命名空间</p>
</blockquote>
<p>需要满足两个条件</p>
<ul>
<li>事件是通过 on 来绑定的</li>
<li>通过 trigger 触发事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zs 即为该点击事件的命名</span></span><br><span class="line">$(<span class="string">&quot;.son&quot;</span>).on(<span class="string">&quot;click.zs&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;click1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;.son&quot;</span>).on(<span class="string">&quot;click.ls&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;click2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// $(&quot;.son&quot;).trigger(&quot;click.zs&quot;);</span></span><br><span class="line">$(<span class="string">&quot;.son&quot;</span>).trigger(<span class="string">&quot;click.ls&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>利用 trigger 触发子元素带命名空间的事件，那么父元素带相同命名空间的事件也会被触发，而父元素没有命名空间的事件不会被触发</li>
<li>利用 trigger 触发子元素不带命名空间的事件，那么子元素所有相同类型的事件和父元素所有相同类型的事件都会被触发</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    $(<span class="string">&quot;.father&quot;</span>).on(<span class="string">&quot;click.ls&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;father click1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    $(<span class="string">&quot;.father&quot;</span>).on(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;father click2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    $(<span class="string">&quot;.son&quot;</span>).on(<span class="string">&quot;click.ls&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;son click1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// $(&quot;.son&quot;).trigger(&quot;click.ls&quot;); // 触发：3 1</span></span><br><span class="line">    $(<span class="string">&quot;.son&quot;</span>).trigger(<span class="string">&quot;click&quot;</span>);	<span class="comment">// 触发：3 1 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>隐式遍历：在 jQuery 中，如果通过核心函数找到的元素不止一个，那么在添加事件的时候，jQuery 会遍历所有找到的元素，给所有找到的元素添加事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第1个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第2个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第3个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>新增一个li<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 隐式遍历</span></span><br><span class="line"><span class="comment"> *	- 三个 li 都会被注册点击事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$(<span class="string">&quot;ul&gt;li&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="built_in">this</span>).html());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击 button 的时候，动态新增一个 li</span></span><br><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;ul&quot;</span>).append(<span class="string">&quot;&lt;li&gt;我是新增的li&lt;/li&gt;&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：当我们点击 li 1 2 3 的时候，发现都会有效，而点击 button 后新增的 li 时却无效，原因是新增的由于程序执行顺序并没有绑定上点击事件，导致点击无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决：采取事件委托的形式，给其父元素绑定点击事件，利用事件冒泡的原理</span></span><br><span class="line"><span class="comment"> * 	- 将 li 的点击事件委托给其父元素 ul</span></span><br><span class="line"><span class="comment"> *  - delegate 事件委派（不推荐）</span></span><br><span class="line"><span class="comment"> *  - on 也可以事件委派（推荐）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 不推荐，因为 3.0 版本废除了</span></span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).delegate(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="built_in">this</span>).html());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).on(<span class="string">&quot;click&quot;</span>, <span class="string">&quot;li&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="built_in">this</span>).html());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="移入移出事件"><a href="#移入移出事件" class="headerlink" title="移入移出事件"></a>移入移出事件</h4><ul>
<li><p>mouseover / mouseout</p>
<p>注意：子元素被移入移出<code>也会触发</code>父元素的事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.father&quot;</span>).mouseover(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;father被移入了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;.father&quot;</span>).mouseout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;father被移出了&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>mouseenter / mouseleave（推荐使用）</p>
<p>注意：子元素被移入移出<code>不会触发</code>父元素的事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.father&quot;</span>).mouseenter(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;father被移入了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;.father&quot;</span>).mouseleave(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;father被移出了&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>hover</p>
<p>两个参数时：第一个参数是处理函数，处理移入，第二个参数是处理函数，处理移出</p>
<p>一个参数时：是处理函数，同时处理移入和移出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个参数</span></span><br><span class="line">$(<span class="string">&quot;.father&quot;</span>).hover(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;father被移入了&quot;</span>);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;father被移出了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数</span></span><br><span class="line">$(<span class="string">&quot;.father&quot;</span>).hover(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;father被移入移出了&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><h4 id="基本动画"><a href="#基本动画" class="headerlink" title="基本动画"></a>基本动画</h4><p>显示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带参数</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).show();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带参数</span></span><br><span class="line"><span class="comment"> *	- 参数 1 : 该动画多少毫秒执行完成</span></span><br><span class="line"><span class="comment"> *  - 参数 2 : 动画执行完毕之后的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).show(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;显示动画执行完毕&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>隐藏</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带参数</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).hide();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数，同上</span></span><br></pre></td></tr></table></figure>

<p>切换</p>
<p>显示和隐藏动画之间的切换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带参数</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).toggle();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数，同上</span></span><br></pre></td></tr></table></figure>

<h4 id="滑动动画"><a href="#滑动动画" class="headerlink" title="滑动动画"></a>滑动动画</h4><p>展开：slideDown    |    收起：slideUp    |    切换：slideToggle</p>
<p>用法：同理基本动画</p>
<h4 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h4><p>淡入：fadeIn    |    淡出：fadeOut    |    切换：fadeToggle    |    淡入到：fadeTo</p>
<p>用法：同理基本动画</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 淡入到</span></span><br><span class="line"><span class="comment"> *	- 参数 1 : 该动画多少毫秒执行完成</span></span><br><span class="line"><span class="comment"> *  - 参数 2 : 淡入程度，一个 0 至 1 之间表示透明度的数字</span></span><br><span class="line"><span class="comment"> *  - 参数 2 : 动画执行完毕之后的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).fadeTo(<span class="number">1000</span>, <span class="number">0.2</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;淡入完毕&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h4><p>比较灵活，具体参考：<a href="https://jquery.cuishifeng.cn/animate.html">自定义动画文档</a></p>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>添加节点<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第1个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第2个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第3个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内部添加（插入）</p>
</blockquote>
<p>append(content)    |    节点内容.appendTo(“需要添加的位置”)</p>
<p>将元素添加到<code>指定元素内部的最后</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需添加的节点内容</span></span><br><span class="line"><span class="keyword">var</span> $li = $(<span class="string">&quot;&lt;li&gt;新增的li&lt;/li&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).append($li);</span><br><span class="line"><span class="comment">// append	|	appendTo : 仅仅写法不一样，推荐 append</span></span><br><span class="line">$li.appendTo(<span class="string">&quot;ul&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>prepend(content)    |    节点内容.prependTo(“需要添加的位置”)</p>
<p>将元素添加到<code>指定元素内部的最前面</code></p>
<p>用法同理，推荐：prepend</p>
<blockquote>
<p>外部添加（插入）</p>
</blockquote>
<p>after(content)    |    节点内容.insertAfter(“需要添加的位置”)</p>
<p>将元素添加到<code>指定元素外部的后面</code></p>
<p>用法同理，推荐：after</p>
<p>before(content)    |    节点内容.insertBefore(“需要添加的位置”)</p>
<p>将元素添加到<code>指定元素外部的前面</code></p>
<p>用法同理，推荐：before</p>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><ul>
<li>remove([expr])：删除指定元素，选中谁就删除谁，删除之后再重新添加，原有的事件无法响应</li>
<li>empty()：删除指定元素的内容和子元素，指定元素自身不会被删除（清空子元素和内容）</li>
<li>detach([expr])：同 remove，但利用 detach 删除之后再重新添加，原有事件可以响应</li>
</ul>
<h4 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h4><p>clone()：指定谁就复制谁，默认 false</p>
<p>参数：true / false</p>
<p>true：深复制，会复制元素，而且还会复制元素的事件</p>
<p>false：浅复制，会复制元素，不会复制元素的事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// true：深复制</span></span><br><span class="line"><span class="keyword">var</span> $li = $(<span class="string">&quot;li:first&quot;</span>).clone(<span class="literal">true</span>);</span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).append($li);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false：浅复制</span></span><br><span class="line"><span class="keyword">var</span> $li = $(<span class="string">&quot;li:first&quot;</span>).clone(<span class="literal">false</span>);</span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).append($li);</span><br></pre></td></tr></table></figure>

<h4 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h4><p>replaceWith(内容)    |    replaceAll(元素)</p>
<p>替换所有匹配的元素为指定的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内容</span></span><br><span class="line"><span class="keyword">var</span> $h6 = $(<span class="string">&quot;&lt;h6&gt;我是标题6&lt;/h6&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换内容</span></span><br><span class="line">$(<span class="string">&quot;h1&quot;</span>).replaceWith($h6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换元素</span></span><br><span class="line">$h6.replaceAll(<span class="string">&quot;h1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>更多详情，请收藏本博主，持续更新……谢谢！</strong></p>
<p>当然，如果您觉得此篇对您有所帮助，想请博主喝杯咖啡，请点击下方按钮，打开您的手机扫一扫，感谢您对本博主的赏识，博主感激不尽！</p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>敲码神器之VS Code</title>
    <url>/%E6%95%B2%E7%A0%81%E7%A5%9E%E5%99%A8%E4%B9%8BVS-Code/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>“欢迎使用”，打开 VS Code，你便会发现有这么个窗口弹出来，这是 VS Code 表示对你的欢迎！</p>
<p>同样，您能花您宝贵的时间，来看我这篇对 VS Code 的介绍，相信你也是热爱 VS Code 的，那么请放下耐心往下浏览吧!</p>
<blockquote>
<p>Tips：下载请访问<a href="https://code.visualstudio.com/">官方网址</a>进行下载，下载完双击安装，点击下一步、下一步即可完成安装（建议：安装路径选择非C盘的其它路径）</p>
</blockquote>
<p><img src="https://static001.geekbang.org/resource/image/58/4f/588bcd217ad7d2c5d18cbab0b1781a4f.png"></p>
<h3 id="快速上手-VS-Code"><a href="#快速上手-VS-Code" class="headerlink" title="快速上手 VS Code"></a>快速上手 VS Code</h3><h4 id="1、命令面板"><a href="#1、命令面板" class="headerlink" title="1、命令面板"></a>1、命令面板</h4><p>说明：VS Code 快捷键的主要交互界面</p>
<p>打开快捷键</p>
<ul>
<li><p>Windows：Ctrl + Shift + P</p>
</li>
<li><p>MacOS：Cmd + Shift + P</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/24/0d/2471149edc2c94a6745a34b5c917d00d.png"></p>
<p>作用：熟练使用命令面板，你就可以摆脱鼠标，完全通过键盘操作来完成全部编码工作（一点都不夸张哦~）</p>
<h4 id="2、界面概览"><a href="#2、界面概览" class="headerlink" title="2、界面概览"></a>2、界面概览</h4><p>说明：VS Code 默认界面里的不同部件的位置、名称和快捷键。</p>
<p>相关快捷键：</p>
<ul>
<li>文件资源管理器：Ctrl + Shift + E</li>
<li>跨文件搜索（全局搜索）：Ctrl + Shift + F</li>
<li>源代码管理：Ctrl + Shift + G</li>
<li>启动和调试：Ctrl + Shift + D</li>
<li>管理扩展：Ctrl + Shift + X</li>
<li>查看错误和警告：Ctrl + Shift + M</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/67/78/67025c889d9e28fecc7d4a71e3904c78.png"></p>
<h4 id="3、交互式演习场"><a href="#3、交互式演习场" class="headerlink" title="3、交互式演习场"></a>3、交互式演习场</h4><p>VS Code 官方提供的熟悉方式，由于全是英文的，有兴趣的可以自行了解哈<del>~</del></p>
<h4 id="4、命令行的使用"><a href="#4、命令行的使用" class="headerlink" title="4、命令行的使用"></a>4、命令行的使用</h4><p>命令行你应该不陌生，Win + R，输入 cmd，弹出的黑白框，没少玩过吧~</p>
<p>到了 VS Code，一个关键的词语你得记住了 <code>Code</code>，没错，时不时觉得很具有代表性，哈哈~可以试着通过 <code>code --help</code>打印出 VS Code 命令行所支持的所有参数，这里介绍几个常用的。</p>
<p><strong>code + 文件或者文件夹的地址</strong>，这样 VS Code 就会在一个新窗口中打开这个文件或文件夹</p>
<blockquote>
<p>例如：我们用 vue-cli 初始化一个 vue 项目的时候会提示 cd xxx 文件夹，然后 npm run serve，这个时候当你执行了 cd 命令，进入到了这个初始化项目文件目录的时候，就可以执行 <code>code .</code> 命令，这样就可以快速在一个新窗口打开这个项目了。</p>
</blockquote>
<p>当然，如果你希望使用已经打开的窗口来打开文件，可以在 <code>code</code> 命令后添加参数 <code>-r</code>来进行窗口的复用</p>
<p><img src="https://static001.geekbang.org/resource/image/6c/b9/6ca4986f77f1da58759801894d6cf8b9.gif"></p>
<p>你也可以使用参数 <code>-g &lt;file:line[:character]&gt;</code> 打开文件，然后滚动到文件中某个特定的行和列，比如输入 <code>code -r -g package.json:128</code>命令，你就可以打开 package.json 这个文件，然后自动跳转到 128 行。这个命令可以方便你从终端里快速地在 VS Code 里打开一个文件进行预览，一个特别常见的例子就是当我们使用脚本执行某个命令，这个命令告诉我们某个文件的某一行出现了错误，我们就能够快速定位了。</p>
<p><img src="https://static001.geekbang.org/resource/image/2b/30/2b0ac41fcf93cfb74dc4c2712b8ab630.gif"></p>
<p>VS Code 也可以用来比较两个文件的内容，你只需使用 <code>-d</code>参数，并传入两个文件路径，比如输入 <code>code -r -d a.txt b.txt</code>命令，就可以比较 a.txt 和 b.txt 两个文件的内容了。有了这个命令，你就可以既使用命令行运行脚本，也可以借助 VS Code 的图形化界面进行文件内容的对比了。</p>
<p><img src="https://static001.geekbang.org/resource/image/c7/d4/c76cf6fed94d1eb1722d949ee1e632d4.gif"></p>
<p>VS Code 命令行除了支持打开磁盘上的文件以外，也接受来自管道中的数据。这样你就可以将原本在命令行中展示的内容，实时地展示在 VS Code 里，然后在编辑器中搜索和修改。</p>
<blockquote>
<p>例如，你可以把当前目录下所有的文件名都展示在编辑器里，此时只需使用<code>ls | code -</code>命令。</p>
</blockquote>
<p><img src="https://static001.geekbang.org/resource/image/4b/3e/4b7b576d51156c4f80fd4957135ffe3e.gif"></p>
<p>另外，VS Code 命令行还能够管理插件，查看 VS Code 的运行情况，记录和分析 VS Code 运行性能，你也可以现在就开始小试牛刀，试试它的威力。</p>
<p><strong>更多详情，请收藏本博主，持续更新……谢谢！</strong></p>
<p>当然，如果您觉得此篇对您有所帮助，想请博主喝杯咖啡，请点击下方按钮，打开您的手机扫一扫，感谢您对本博主的赏识，博主感激不尽！</p>
<h3 id="快捷键进阶"><a href="#快捷键进阶" class="headerlink" title="快捷键进阶"></a>快捷键进阶</h3><h4 id="1、代码行编辑"><a href="#1、代码行编辑" class="headerlink" title="1、代码行编辑"></a>1、代码行编辑</h4><p>当前行的<code>下面</code>新开始一行：</p>
<ul>
<li>Windows：Ctrl + Enter</li>
<li>MacOS：Cmd + Enter</li>
</ul>
<p>当前行的<code>上面</code>新开始一行：</p>
<ul>
<li>Windows：Ctrl + Shift + Enter</li>
<li>MacOS：Cmd + Shift + Enter</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/b2/d1/b2d7a80ded072f62a19ebce6b9ecb8d1.gif"> </p>
<p>将当前行，或者当前选中的几行代码，在编辑器里上下移动</p>
<ul>
<li>Windows：Alt + 上下方向键</li>
<li>MacOS：Option + 上下方向键</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/25/be/25053dfebdb3117cb89604615bf355be.gif"> </p>
<p>如果你同时按住 <code>Shift</code> 键的话，那就可以复制这几行，然后粘贴到当前行的上面或者下面</p>
<ul>
<li>Windows：Alt + shift + 上下方向键</li>
<li>MacOS：Option + Shift + 上下方向键</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/d4/16/d4f9ae5ad3a0bb62e734386b7522ba16.gif"> </p>
<h4 id="2、编码相关"><a href="#2、编码相关" class="headerlink" title="2、编码相关"></a>2、编码相关</h4><p>添加注释：Ctrl + /，Cmd + / </p>
<p>代码格式化：Alt + Shift + F，Option + Shift + F</p>
<p>代码缩进：打开命令面板（快捷键：Cmd / Ctrl + Shift + P），搜索 <code>缩进</code>，然后使用 <code>重新缩进行</code> 将整个文档的缩进进行调整，但更多时候，你只需要运行 <code>重新缩进选中行</code> 来调整部分选中代码行的缩进</p>
<p>多光标创建：使用鼠标，在键盘上按住 <code>Option / Alt</code>，然后鼠标点在第二个 5 之前，那么第二个光标就创建好了</p>
<p><img src="https://static001.geekbang.org/resource/image/6e/f1/6e457c792615747787352aa92e6ae8f1.gif"> </p>
<h4 id="3、文件跳转"><a href="#3、文件跳转" class="headerlink" title="3、文件跳转"></a>3、文件跳转</h4><p>文件搜索快捷键：Ctrl / Cmd + Enter</p>
<p>模糊查询：Ctrl / Cmd + T，输入 <code># + 搜索关键字</code></p>
<p><img src="https://static001.geekbang.org/resource/image/37/7c/37ea953edce0e8d65c332498889f277c.gif"> </p>
<p>可以借助鼠标来完成跳转操作，我们还是把鼠标移动到示例代码的第五行 <code>foo</code> 上，然后按下 Ctrl / Cmd 键，这时候 <code>foo</code>下面出现了一个下划线，然后当我们按下鼠标左键，就跳转到了 <code>foo</code> 函数的定义处</p>
<p><img src="https://static001.geekbang.org/resource/image/2e/45/2e81558f17eb3390547e6f2af4af9045.gif"> </p>
<p>备注：此篇学习自吕鹏大佬的玩转 VS Code，如有侵权请告知删除，谢谢！</p>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>React 学习之旅</title>
    <url>/React-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于 React 是什么，我想我也不用多说了，学就完了，干就完了</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>关于 React 的安装，这里不做过多的累赘，请移步：<a href="https://react.docschina.org/docs/create-a-new-react-app.html">React 安装</a></p>
<h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li><p>node_modules：包管理文件</p>
</li>
<li><p>public：Html 入口文件 &amp;&amp; 资源文件</p>
</li>
<li><p>src：源码文件</p>
</li>
</ul>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="1、JSX-语法"><a href="#1、JSX-语法" class="headerlink" title="1、JSX 语法"></a>1、JSX 语法</h4><p><code>js</code> 语法 + <code>xml</code> 语法（可以理解为 HTML）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;hello react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;&gt;&lt;/&gt;: 作为 xml（html）语法解析</span></span><br><span class="line"><span class="comment"> * &#123; ... &#125;: 作为 js 语法解析 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="2、元素渲染"><a href="#2、元素渲染" class="headerlink" title="2、元素渲染"></a>2、元素渲染</h4><p>说白了就是，能看到实际效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注意：这里是 ()，而不是 &#123;&#125;</span></span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 需要放到函数内，才能得到 element</span></span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3、组件创建"><a href="#3、组件创建" class="headerlink" title="3、组件创建"></a>3、组件创建</h4><p>tips: 组件文件后缀名是 .js 或者 .jsx（有代码提示）</p>
<p>类 class 形式创建：Home.jsx</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 渲染函数</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> ( <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>学习 react<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>

<h4 id="4、props"><a href="#4、props" class="headerlink" title="4、props"></a>4、props</h4><p>props 的出现，使得组件可以进行传值，即组件可复用了</p>
<p><strong>注意：</strong>接收唯一带有数据的 “props”（代表属性）对象，且子组件不可以修改 props 的值，要修改也是去父组件修改</p>
<p><strong>父组件向子组件传值：父组件以标识属性的方式进行传值，子组件以 props 进行接收</strong></p>
<ul>
<li><p>父组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 引入子组件</span></span><br><span class="line"><span class="keyword">import</span> MyNav <span class="keyword">from</span> <span class="string">&#x27;./myNav&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 父组件定义传递数据</span></span><br><span class="line">    <span class="keyword">let</span> nav_1 = [<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;javascript&#x27;</span>, <span class="string">&#x27;c#&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> nav_2 = [<span class="string">&#x27;从&#x27;</span>, <span class="string">&#x27;入门&#x27;</span>, <span class="string">&#x27;到&#x27;</span>, <span class="string">&#x27;放弃&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;学习 react&lt;/h1&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 传递数据，可以是任意类型</span></span><br><span class="line"><span class="comment">           * title、nav，传递属性，子组件用于接收的标识属性</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;MyNav title=<span class="string">&quot;语言导航&quot;</span> nav=&#123;nav_1&#125; /&gt;</span><br><span class="line">        &lt;MyNav title=<span class="string">&quot;忠言导航&quot;</span> nav=&#123;nav_2&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNav</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 接收 title 属性标识的数据 */</span>&#125;</span><br><span class="line">        &lt;h3&gt;&#123;<span class="built_in">this</span>.props.title&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 接收 nav 属性标识的数据，并遍历</span></span><br><span class="line">            <span class="built_in">this</span>.props.nav.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#x27;index&#x27;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyNav</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>子组件向父组件传值：子组件通过调用 props 接收到的父级方法，以参数传递的形式向父组件进行传值</strong></p>
<ul>
<li><p>父组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 引入子组件</span></span><br><span class="line"><span class="keyword">import</span> MyNav <span class="keyword">from</span> <span class="string">&#x27;./myNav&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      text: <span class="string">&#x27;我是父组件数据&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 该方法用于传递到子组件，子组件接收调用，并向父组件传值</span></span><br><span class="line"><span class="comment">   * sunData: 子组件传递过来的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  handleText = <span class="function">(<span class="params">sunData</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      text: sunData</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="built_in">this</span>.state.text&#125;&lt;/p&gt;</span><br><span class="line">        &#123;<span class="comment">/* handleTexts: 传递给子组件的方法，用于子组件调用并向父组件传参 */</span>&#125;</span><br><span class="line">        &lt;MyNav handleTexts=&#123; <span class="built_in">this</span>.handleText &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNav</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      text: <span class="string">&#x27;我是子组件的数据&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * handleChangeTexts: 该方法用于子组件调用，实现子组件点击修改父组件 state 数据</span></span><br><span class="line"><span class="comment">   * handleTexts: 该方法为父组件传递过来的，子组件接收调用，并向父组件传递参数: this.state.text</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  handleChangeTexts = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.handleTexts(<span class="built_in">this</span>.state.text)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123; <span class="built_in">this</span>.handleChangeTexts &#125;&gt;修改父组件 state 数据&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyNav</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5、state"><a href="#5、state" class="headerlink" title="5、state"></a>5、state</h4><p>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件，即：<strong>State 是当前组件的</strong></p>
<p>定义位置：当前组件的 <strong>构造函数</strong> 中，即：<strong>constructor 中</strong></p>
<blockquote>
<p><strong>setState 的同步异步问题</strong></p>
<p><code>tips：setState 会引起视图重绘</code></p>
</blockquote>
<ul>
<li><p>在非可控的情况下是同步</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetStateDemo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击 count +1 按钮，加 1</span></span><br><span class="line">  handleButton() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="built_in">this</span>.state.count</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非可控的情况下是同步，点击一次</span></span><br><span class="line"><span class="comment">     * 页面显示：1</span></span><br><span class="line"><span class="comment">     * 控制台：0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      count: count+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;setState 是同步还是异步&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="built_in">this</span>.state.count&#125;&lt;/p&gt; </span><br><span class="line">        &lt;button onClick=&#123; <span class="built_in">this</span>.handleButton.bind(<span class="built_in">this</span>) &#125;&gt;count +<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> SetStateDemo</span><br></pre></td></tr></table></figure>
</li>
<li><p>在可控的情况下是异步</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetStateDemo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写法一：</span></span><br><span class="line">  <span class="comment">// 点击 count +1 按钮，加 1</span></span><br><span class="line">  <span class="comment">// handleButton() &#123;</span></span><br><span class="line">    <span class="comment">// let count = this.state.count</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在可控的情况下是异步，点击一次</span></span><br><span class="line"><span class="comment">     * 页面显示：1</span></span><br><span class="line"><span class="comment">     * 控制台：1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;</span></span><br><span class="line">    <span class="comment">//   count: count+1</span></span><br><span class="line">    <span class="comment">// &#125;, () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(this.state.count)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写法二：promise async await</span></span><br><span class="line">  <span class="keyword">async</span> handleButton() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="built_in">this</span>.state.count</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      count: count+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.setStateAsync(&#123;<span class="attr">count</span>: count+<span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// promise 处理异步</span></span><br><span class="line">  setStateAsync(state) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(state, resolve)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;setState 是同步还是异步&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="built_in">this</span>.state.count&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleButton.bind(<span class="built_in">this</span>)&#125;&gt;count +<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> SetStateDemo</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6、生命周期函数"><a href="#6、生命周期函数" class="headerlink" title="6、生命周期函数"></a>6、生命周期函数</h4><ul>
<li><code>componentWillMount</code>：在组件渲染之前执行</li>
<li><code>componentDidMount</code>：在组件渲染之后执行</li>
<li><code>shouldComponentUpdate</code>：返回 <code>true</code> 和 <code>false</code>，<code>true</code> 代表允许改变，<code>false</code> 代表不允许改变</li>
<li><code>componentWillUpdate</code>：数据在改变之前执行 ( <code>state</code>，<code>props</code> )</li>
<li><code>componentDidUpdate</code>：数据修改完成 (<code>state</code>，<code>props</code> )</li>
<li><code>componentWillReveiceProps</code>：<code>props</code> 发生改变执行</li>
<li><code>componentWillUnmount</code>：组件卸载前执行</li>
</ul>
<p>贴图</p>
<h4 id="7、条件渲染"><a href="#7、条件渲染" class="headerlink" title="7、条件渲染"></a>7、条件渲染</h4><p>React 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 <code>if</code> 或者 条件运算符 去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI</p>
<p>常见应用</p>
<ul>
<li>根据条件进行视图切换，如：未登录 切换到 登陆</li>
<li>做缺省值，如: 数据未加载完成，提示 “数据还在加载中…”</li>
</ul>
<h4 id="8、列表-amp-key"><a href="#8、列表-amp-key" class="headerlink" title="8、列表 &amp; key"></a>8、列表 &amp; key</h4><p>起因：数据量一旦变的庞大，层次结构变得复杂的时候，整个渲染就会变慢，绑定 key 也是为了解决这个问题</p>
<p><strong>key 的概念和作用</strong></p>
<p>前面提到 <code>setState</code> 会引起视图的<code>重绘</code>，因为你一个 <code>state</code> 的改变可能引起整个数据结构的改变（牵一发而动全身），有数组或者对象等遍历型数据的时候，<strong>外层包裹一个 <code>key</code> 属性，<code>唯一标识</code>，如果数据的索引未发生改变，UI 不会重绘，只有发生变化的部分会重绘</strong>，这样就可以使得整体的一个性能得到优化提升</p>
<h4 id="9、表单"><a href="#9、表单" class="headerlink" title="9、表单"></a>9、表单</h4><p>受控组件：表单内的 value 值是通过 state 进行管理的（表单数据较少情况下，使用频率高）</p>
<blockquote>
<p><strong>Tips:</strong> 因为 <code>state</code> 的数据只能是通过 <code>setState</code> 进行修改的，所以需要绑定对应的  <code>onChange</code> 事件去进行操作</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormDemo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">			<span class="comment">// 表单的 value 值</span></span><br><span class="line">            value:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 表单提交事件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    handleSubmit = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 操作 state value 值改变的 change 事件处理函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    onChangeHandler = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            value: e.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;form onSubmit=&#123;<span class="built_in">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;text&quot;</span> value=&#123; <span class="built_in">this</span>.state.value &#125; onChange=&#123; <span class="built_in">this</span>.onChangeHandler &#125;/&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;/input&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FormDemo</span><br></pre></td></tr></table></figure>

<p>非受控组件：表单内的 value 值通过操作 DOM 的形式进行管理（表单数据较多，处理较多的情况下）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefsForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">		<span class="comment">// 定义多个不同的 ref 进行标识操作</span></span><br><span class="line">        <span class="built_in">this</span>.username = React.createRef();</span><br><span class="line">        <span class="built_in">this</span>.password = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clickHandler = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123;</span><br><span class="line">		<span class="comment">// 进行对应的 ref 操作</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username.current.value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.password.current.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123; <span class="built_in">this</span>.username &#125;/&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123; <span class="built_in">this</span>.password &#125;/&gt;</span><br><span class="line">				&#123; <span class="comment">/* 非受控组件：这里就只需要定义一个处理事件去操作 */</span> &#125;</span><br><span class="line">                &lt;button onClick=&#123; <span class="built_in">this</span>.clickHandler &#125;&gt;提交&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RefsForm</span><br></pre></td></tr></table></figure>

<p><code>refs and the DOM</code>：以 refs 的方式进行操作 DOM（尽量避免，少使用）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefsAndDOM</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">		<span class="comment">// 1、创建 refs，</span></span><br><span class="line">        <span class="built_in">this</span>.myRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 3、访问 ref: this.ref 名称.current</span></span><br><span class="line"><span class="comment">		 * current: 被访问当前节点属性对象</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="built_in">this</span>.myRef.current.style.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">				&#123; <span class="comment">/* 2、通过 ref 属性附加到 React 元素 */</span> &#125;</span><br><span class="line">                &lt;div ref=&#123; <span class="built_in">this</span>.myRef &#125;&gt;</span><br><span class="line">                    Hello</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RefsAndDOM</span><br></pre></td></tr></table></figure>

<h4 id="10、状态提升"><a href="#10、状态提升" class="headerlink" title="10、状态提升"></a>10、状态提升</h4><p>前面学习了 <code>父子组件传值</code> ，那么简单点说，就是兄弟组件之间以父组件进行建立联系、通信</p>
<p>具体详情，请异步 <a href="https://react.docschina.org/docs/lifting-state-up.html">官方文档</a></p>
<h4 id="11、组合-VS-继承"><a href="#11、组合-VS-继承" class="headerlink" title="11、组合 VS 继承"></a>11、组合 VS 继承</h4><p>组合：为了考虑到组件更好的复用性，采取 <code>组件套组件</code> 的形式，实现组件的复用</p>
<p>被套组件内容读取形式：<code>this.props.children</code></p>
<p><strong>官方说：能用 组合 不用 继承</strong>，所以继承介绍的少</p>
<h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h3><p>官方文档（英文）：<a href="https://reactrouter.com/web/guides/quick-start">https://reactrouter.com/web/guides/quick-start</a></p>
<p>对于路由这东西，多查查文档会比较好</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux 是 JavaScript 状态容器（说白了就是数据仓库，管理数据的），让人觉得一脸懵逼的 <a href="https://www.redux.org.cn/">中文文档</a></p>
<ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save-dev redux</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers/counters&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、创建 store 仓库（主函数中）</span></span><br><span class="line"><span class="comment"> *  - 方式：createStore(&#x27;参数是一个函数&#x27;)</span></span><br><span class="line"><span class="comment"> * subscribe：监听数据的改变</span></span><br><span class="line"><span class="comment"> *  - 参数：Function</span></span><br><span class="line"><span class="comment"> * getState：获取到 state 数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、对应组件中定义事件并分发 action</span></span><br><span class="line"><span class="comment"> * onIncrement: 加 1 事件</span></span><br><span class="line"><span class="comment"> * onIncrement: 减 1 事件</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * dispatch：store 的方法，分发 action，触发 state 的变化（唯一途径）</span></span><br><span class="line"><span class="comment"> *  - 参数：action，是一个描述应用变化的普通对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reder = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;App </span><br><span class="line">      onIncrement = &#123; <span class="function">() =&gt;</span> store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;INCREMENT&quot;</span> &#125;)&#125;</span><br><span class="line">      onDecrement = &#123; <span class="function">() =&gt;</span> store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;DECREMENT&quot;</span> &#125;)&#125;</span><br><span class="line">      value = &#123; store.getState() &#125;</span><br><span class="line">    /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reder();</span><br><span class="line">store.subscribe(reder)</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">        &#123;<span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 4、子组件接收并触发事件</span></span><br><span class="line"><span class="comment">          */</span>&#125;</span><br><span class="line">        &lt;h1&gt;&#123; <span class="built_in">this</span>.props.value &#125;&lt;/h1&gt;</span><br><span class="line">        &lt;button onClick=&#123; <span class="built_in">this</span>.props.onIncrement &#125;&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123; <span class="built_in">this</span>.props.onDecrement &#125;&gt;<span class="number">-1</span>&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、定义 action.type，不同的类型做不同的操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>state 仓库中所存储的数据状态（数据）</span></span><br><span class="line"><span class="comment"> *  - state = 0：数据初始化（ES6 写法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>action 改变数据状态（数据）的方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>action.type 不同的值可以做不同的修改</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * INCREMENT：代表类型操作为 + 1</span></span><br><span class="line"><span class="comment"> * DECREMENT：代表类型操作为 - 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = <span class="number">0</span>,action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;INCREMENT&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;DECREMENT&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h3><p><strong>更多详情，请收藏本博主，持续更新……谢谢！</strong></p>
<p>当然，如果您觉得此篇对您有所帮助，想请博主喝杯咖啡，请点击下方按钮，打开您的手机扫一扫，感谢您对本博主的赏识，博主感激不尽！</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>React</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题汇总</title>
    <url>/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h3 id="主流框架"><a href="#主流框架" class="headerlink" title="主流框架"></a>主流框架</h3><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p><strong>更多详情，请收藏本博主，持续更新……谢谢！</strong></p>
<p>当然，如果您觉得此篇对您有所帮助，想请博主喝杯咖啡，请点击下方按钮，打开您的手机扫一扫，感谢您对本博主的赏识，博主感激不尽！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
</search>
