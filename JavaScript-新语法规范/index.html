<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="博客, Web前端, 影视, 娱乐, 游戏, 生活, 情感" />
   
  <meta name="description" content="集技术与娱乐于一体的博客天地" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    JavaScript 新语法规范 |  集技术与娱乐于一体的博客天地
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/favicon/20200815223509.png" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="浩淇的博客" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-JavaScript-新语法规范"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  JavaScript 新语法规范
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/JavaScript-%E6%96%B0%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/" class="article-date">
  <time datetime="2020-09-06T06:14:17.000Z" itemprop="datePublished">2020-09-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">16.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">67 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JavaScript 新语法规范，从最初的 <code>ES3</code> 到 <code>ES4</code> 及现在所一直保持的 <code>ES5</code> 规范，发现其中还存在很多问题。就针对发现的一些问题，做了新语法规范的改进，也就是现在的 <code>ES6</code> 及 <code>ES7/8/9</code> 甚至 <code>ES11</code>。下面是关于我对新语法规范学习的一些总结，如果有什么好的建议或者发现一些不好、错误的地方，还希望各位大佬在下方的评论区留言，谢谢！</p>
<p>学习总结过程的代码是基于 <a target="_blank" rel="noopener" href="https://gitee.com/sunny-store/javascript-new-standard">Gitee 码云仓库</a> 进行管理的，有需要的可以自行提取，可以的话，请顺便点个 <code>star</code>，谢谢！</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>全局作用域和私有作用域，这两个作用域是我们玩 JavaScript 的人都知道的，那么 <code>ES6</code> 的到来，新增加了一个概念叫<code>块级作用域</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;全局变量 a = &#x27;</span> + a)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;全局变量 a = &#x27;</span> + a)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;test 函数作用域内部变量 b = &#x27;</span> + b)</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">4</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;可以访问到全局变量 a = &#x27;</span> + a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;可以访问到变量 c = &#x27;</span> + c)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;不能访问到变量 d = &#x27;</span> + d)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果</span></span><br><span class="line"><span class="comment"> * 全局变量 a = 1</span></span><br><span class="line"><span class="comment"> * 可以访问到全局变量 a = 1</span></span><br><span class="line"><span class="comment"> * test 函数作用域内部变量 b = 2</span></span><br><span class="line"><span class="comment"> * 全局变量 a = 1</span></span><br><span class="line"><span class="comment"> * 可以访问到变量 c = 3</span></span><br><span class="line"><span class="comment"> * Uncaught ReferenceError: d is not defined</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以知道，全局变量 <code>a</code> 在任何地方都可以被访问到，函数内部变量 <code>b</code> 和 <code>c</code> 在函数内部作用域中都可以被访问到，这也正是我们所熟悉的全局作用域和私有作用域，没毛病。那么变量 <code>d</code> 被访问的时候为什么就被报错了呢？</p>
<p>相信大家都注意到了，变量 <code>d</code> 是被 <code>let</code> 进行声明定义的，这也就是我们即将要说的 <code>块级作用域</code>，顾名思义，就是含有<code>块</code>的概念，这个块指的就是 <code>&#123;&#125;</code> 大括号，大括号内的作用域就是称为块级作用域。</p>
<p>我们发现，上述代码中，if()<code>&#123;...&#125;</code> 内的变量仍然可以被其大括号外部访问到，所以块级作用域的出现也正是为了弥补 JS 的这个缺陷，用 let 进行变量声明定义，就可以形成一个块级作用域，正如上述代码中的那样，变量 d 无法被访问到。</p>
<blockquote>
<p>Tips：let 声明定义的变量也没有变量提升的概念</p>
</blockquote>
<p>全局作用域、私有作用域和块级作用域都说到了，那么剩下的就是<code>动态作用域</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">test.bind(&#123; <span class="attr">a</span>: <span class="number">10</span> &#125;)()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> * 10</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>所谓动态作用域其实就是他的作用域不固定，我们可以通过一些方式，利用 <code>this</code> 指向，通过 <code>bind</code> 的方式改变 this 的指向，从而形成动态作用域。上述代码中，第一次输出结果 1，是因为 this 指向的是全局 window，输出结果 10，是因为 test.bind 将 this 指向了 { a: 10 } 这个对象，从而输出结果 10。</p>
<h4 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h4><p>关于 let 前面讲过了挺多，这里做以下总结：</p>
<ul>
<li>let 声明的变量具有块级作用域的概念；</li>
<li>let 声明的变量没有变量提升的概念；</li>
<li>let 声明的变量名不能重复；</li>
<li>let 声明的全局变量不能用全局对象的属性来访问。</li>
</ul>
<p>const 除了具备上述 let 的特点之外，<code>const 用于定义常量</code>，这是 const 独有的特点。</p>
<blockquote>
<p>Tips：另外就是 let 和 var 均可以先声明后赋值，但 const 不行。</p>
</blockquote>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>举个例子，我们平时想要将一个数组中的某一项拿到，需要对数组进行变量，以索引的方式进行取值，比较麻烦，而解构赋值便很好的解决了这个问题。<strong>解构赋值，咬文嚼字一下就是将一个结构进行解析，解析出来的值再进行赋给对应的变量。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)	<span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以发现，等号两边的结构是一样的，都是数组，呈对应关系。等号右边便是要进行结构的 “东西” ，这个 “东西” 目前是一个数组，那么解构完了后，我们需要一个同样对应的 “东西” 去接收解构出来的细碎的小物品，一个一个的对应起来，这也就是解构赋值，其中 <code>a 对应 1，即 a = 1，b 对应 2，即 b = 2，c 对应 3，即 c = 3</code>。 下面再来看几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, [c, d]] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d)	<span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>a 对应 1，即 a = 1，b 对应 2，即 b = 2</p>
<p>因为 [c, d] 对应 [3, 4]，所以 c 对应 3，即 c = 3，d 对应 4，即 d = 4</p>
<blockquote>
<p>Tips：到来这里，有没有感觉像以前做数学题~哈哈</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, [c]] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)	<span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>a 对应 1，即 a = 1，b 对应 2，即 b = 2</p>
<p>[c] 对应 [3, 4]，因为左边只有一个接收的，所以我们只接收右边的第一个，得出 c 对应 3，即 c = 3，而右边的 4 没有对应的，所以保留。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)	<span class="comment">// 1 2 [3, 4]</span></span><br></pre></td></tr></table></figure>

<p>a 对应 1，即 a = 1，b 对应 2，即 b = 2</p>
<p>因为 c 对应 [3, 4]，所以 c  = [3, 4]，c 的值是一个数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d)	<span class="comment">// 1 2 [3, 4] undefined</span></span><br></pre></td></tr></table></figure>

<p>同理，一一对应，没得对应的自然就是 undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d = <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d)	<span class="comment">// 1 2 [3, 4] 6</span></span><br></pre></td></tr></table></figure>

<p>同理一一对应，左边的 d 给了初值了，右边又有对应关系，那自然是覆盖了啦</p>
<p>既然数组可以，那么对象呢？一起来看看~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;sunny&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = user</span><br><span class="line"><span class="built_in">console</span>.log(name, age)	<span class="comment">// sunny 20</span></span><br><span class="line"><span class="keyword">let</span> &#123; age, name &#125; = user</span><br><span class="line"><span class="built_in">console</span>.log(name, age)	<span class="comment">// sunny 20</span></span><br></pre></td></tr></table></figure>

<p>从上述代码中发现，对象也是可以解构赋值的，而且它们的对应关系是<strong>根据 key 属性进行对应的，之前数组是通过 下标，即通过顺序进行对应的</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;sunny&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: uname, <span class="attr">age</span>: uage &#125; = user</span><br><span class="line"><span class="built_in">console</span>.log(uname, uage)	<span class="comment">// sunny 20</span></span><br></pre></td></tr></table></figure>

<p>既然我们知道了，对象的解构是通过 key 属性进行对应解构的，那么就可以利用 key 进行对对应的属性起别名，如上所示。</p>
<p>数组，对象都可以，那么类似数组的<strong>字符串</strong>可不可以呢？答案<strong>是可以的</strong>，<strong>其操作和思想和数组差不多，可以参考数组的解构赋值</strong>。</p>
<p>了解了这么多，总结一下：<strong>解构赋值，就是左边的结构对应右边的结构，左边是接收方，右边是赋予方，接收方少于赋予方，那么就是按需解构赋值；一样就是完全解构赋值，多于就是贪得无厌，对应不到的就是 undefined</strong>。</p>
<p>常见应用场景：</p>
<ul>
<li><p>默认值赋初值：定义数组某项赋初值，函数形参赋初值，函数返回值解构赋值等</p>
</li>
<li><p>异步数据请求 json 数据解构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;hello&quot;, &quot;b&quot;: &quot;world&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment">// JSON.parse(json): 把字符串转换成对应对象</span></span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = <span class="built_in">JSON</span>.parse(json)</span><br><span class="line"><span class="built_in">console</span>.log(a, b)	<span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>对于数组，我想大家再熟悉不过了，操作数组的基础就是对数组的遍历，而遍历数组的方式有很多，其中不乏传统的遍历方式，更多的是结合实际问题而做出的改进方式，也就是 ES6 新增的方式，下面一起来了解下，传统的遍历方式和 ES6 新特性下的遍历方式。</p>
<p>定义一个数组：<code>let arr = [1, 2, 3, 4, 5]</code>，下面分别以不同的方式对其进行遍历操作</p>
<h4 id="ES5-方式"><a href="#ES5-方式" class="headerlink" title="ES5 方式"></a>ES5 方式</h4><ul>
<li><p><strong>for 循环</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>forEach()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.forEach(function(currentValue, index, arr), thisValue)</span></span><br><span class="line"><span class="comment"> * function(currentValue, index, arr): 回调函数【必传】</span></span><br><span class="line"><span class="comment"> *  - currentValue: 当前元素【必须】</span></span><br><span class="line"><span class="comment"> *  - index: 当前元素的索引值【可选】</span></span><br><span class="line"><span class="comment"> *  - arr: 当前元素所属的数组对象【可选】</span></span><br><span class="line"><span class="comment"> * thisValue: 传递给函数的值一般用 &quot;this&quot; 值，如果这个参数为空，&quot;undefined&quot; 会传递给 &quot;this&quot; 值。【可选】</span></span><br><span class="line"><span class="comment"> * 注意: forEach() 对于空数组是不会执行回调函数的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem, index, array)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>for 循环</code> 和 <code>forEach()</code> 的区别：<strong>for 循环支持 break 和 continue，而 forEach() 不支持，即 forEach() 中途不能跳出循环</strong>。</p>
<ul>
<li><p><strong>map()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.forEach(function(currentValue, index, arr), thisValue)</span></span><br><span class="line"><span class="comment"> * function(currentValue, index, arr): 同上</span></span><br><span class="line"><span class="comment"> * thisValue: 同上</span></span><br><span class="line"><span class="comment"> * 注意: map() 对于空数组是不会执行回调函数的，map() 不会改变原始数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  value += <span class="number">1</span></span><br><span class="line">  <span class="comment">// console.log(value)</span></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>map()</code> 和 <code>forEach()</code> 的区别：<strong>forEach() 只是简单的遍历，而 map() 会遍历数组中的每一个元素，然后根据这个回调函数进行回调操作，将我们需要的返回值以一个新数组的形式返回，原数组不变</strong>。</p>
<ul>
<li><p><strong>filter()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.filter(function(currentValue,index,arr), thisValue): 参数介绍同上</span></span><br><span class="line"><span class="comment"> * 注意： filter() 不会对空数组进行检测，filter() 不会改变原始数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> result = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(value)</span></span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>filter()</code> 的特点：<strong>从遍历项中，利用回调函数对遍历项进行过滤筛选操作，符合条件的项以一个新数组的形式返回，原数组不变</strong>。</p>
<ul>
<li><p><strong>some()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.some(function(currentValue,index,arr),thisValue): 参数介绍、注意同上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> result = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(value)</span></span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>some()</code> 的特点：<strong>some() 方法会依次执行数组的每个元素，如果有一个元素满足条件，则返回 true , 剩余的元素不会再执行检测；如果没有满足条件的元素，则返回 false，返回的是一个布尔值，原数组不变</strong>。</p>
<ul>
<li><p><strong>every()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.every(function(currentValue,index,arr), thisValue): 参数、注意介绍同上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> result = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(value)</span></span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>every()</code> 的特点：<strong>every() 方法会依次执行数组的每个元素，如果有一个元素不满足条件，则直接返回 false , 剩余的元素不会再执行检测；如果所有的元素都满足条件，则返回 true，返回的是一个布尔值，原数组不变</strong>。</p>
<p><strong>所以：some() 方法强调的是个体，every() 方法强调的是整体</strong></p>
<ul>
<li><p><strong>reduce()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</span></span><br><span class="line"><span class="comment"> * function(total,currentValue, index,arr): 回调函数【必传】</span></span><br><span class="line"><span class="comment"> *  - total: 上一次调用回调函数的返回值，当然第一次调用的时候，即相当于初始值【必传】</span></span><br><span class="line"><span class="comment"> *  - currentValue: 当前元素【必须】</span></span><br><span class="line"><span class="comment"> *  - currentIndex: 当前元素的索引值【可选】</span></span><br><span class="line"><span class="comment"> *  - arr: 当前元素所属的数组对象【可选】</span></span><br><span class="line"><span class="comment"> * initialValue: 传递给函数的初始值【可选】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比如遍历 arr 实现求和操作</span></span><br><span class="line"><span class="comment"> *  - 0: 相当于 initialValue，用于 &#x27;和（sum）&#x27; 的起始值，如果不传，起始值就是 1</span></span><br><span class="line"><span class="comment"> * 到了第二次：pre 的值就是返回值，这个返回值源于上一次累加的结果，即 prev + cur -&gt; 0 + 1 -&gt; 返回 1</span></span><br><span class="line"><span class="comment"> * 依此类推...</span></span><br><span class="line"><span class="comment"> * 最后返回，最后累加的值，即计算结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="built_in">console</span>.log(prev)</span><br><span class="line">  <span class="comment">// 0 1 3 6 8</span></span><br><span class="line">  <span class="keyword">return</span> prev + cur</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现数组的去重</span></span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(prev) // []: 起始值，空数组</span></span><br><span class="line">  prev.indexOf(cur) === -<span class="number">1</span> &amp;&amp; prev.push(cur)</span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>for in</strong>：一般<strong>不用于</strong>遍历数组，会出现将数组原型上定义的方法也同时遍历出来，及各种问题（一般用于遍历对象）</p>
</li>
</ul>
<h4 id="ES6-方式"><a href="#ES6-方式" class="headerlink" title="ES6 方式"></a>ES6 方式</h4><ul>
<li><p><strong>find()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * array.find(function(currentValue, index, arr),thisValue)</span></span><br><span class="line"><span class="comment"> * 参数、注意同上 forEach</span></span><br><span class="line"><span class="comment"> * 返回值：返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> res = arr.find(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">8</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, res)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>findIndex()</strong></p>
<p>该方法同 <code>find()</code> 类似，区别在于 <code>findIndex()</code> 返回的是符合测试条件的第一个<code>数组元素索引</code>，如果没有符合条件的则返回  <code>-1</code> 。</p>
</li>
<li><p><strong>for of</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历获得数组的每一项 - 直接法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历获得数组的每一项 - 间接法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历获得数组的每一项索引值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历获得数组的每一项及其索引值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, item] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h4><p>伪数组是<code>有长度</code>，<code>能遍历</code>，<code>不能直接调用数组的 API</code> 的数组</p>
<p>伪数组特征：</p>
<ul>
<li><p>按照索引形式存储数据（索引是非负的整数）</p>
</li>
<li><p>具备一个 length 属性</p>
</li>
</ul>
<p>伪数组形式：</p>
<ul>
<li><p>arguments，于 ES6 中废除</p>
</li>
<li><p>document.querySelectorAll(‘img’)</p>
</li>
<li><p>{ 0: ‘a’, 1: ‘b’, length: ‘5’}</p>
</li>
</ul>
<h4 id="ES6-扩展"><a href="#ES6-扩展" class="headerlink" title="ES6 扩展"></a>ES6 扩展</h4><blockquote>
<p>伪数组转换成真正的数组</p>
</blockquote>
<ul>
<li><p><strong>Array.from(object（或需要转换的伪数组）, [遍历函数], [当前元素的 this 指向])</strong></p>
</li>
<li><p>作用：生成一个新数组或者将一个伪数组转换成真正的数组</p>
</li>
<li><p>应用：一般用于伪数组转换成真数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个伪数组</span></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;es6&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;es7&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;es8&#x27;</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike)</span><br><span class="line">arr.push(<span class="string">&#x27;es9&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>新数组生成方式及其方式对应的应用</p>
</blockquote>
<p>我们都知道，生成一个新数组的方式有很多种方式，传统的 <code>new Array()</code> 构建方式，当我们传入的参数只有一个的时候，代表的是构建生成一个只有长度的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<p>而传入的值有多个的时候，那么就是具有长度，并且每一项都有值的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<p>但往往第一种情况不是我们想要的，所以第二种方式就出来了</p>
<ul>
<li><p><strong>Array.of([N个数据，’,’号隔开])</strong></p>
</li>
<li><p>作用：生成指定数据项的数组</p>
</li>
<li><p>应用：将多个数据项拼接成新的数组</p>
</li>
<li><p>注意：会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个数据</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个数据</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&#x27;sunny&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123;<span class="attr">name</span>: <span class="string">&#x27;sunny&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当然，还有第三种方式，就是进行<code>填充</code></p>
<ul>
<li><p><strong>Array.fill(被填充的元素,  [ start ], [ end ])</strong></p>
</li>
<li><p>说明：start 和 end: 指定 开始位置 和 结束位置范围内的数，替换成被填充的元素；不指定则所有项替换成 被填充的元素</p>
</li>
<li><p>注意：会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// arr.fill(&#x27;sunny&#x27;, 1, 3)</span></span><br><span class="line">arr.fill(<span class="number">0</span>)	<span class="comment">// 全部替换</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>替换数组的某些元素</p>
</blockquote>
<ul>
<li><p><strong>arr.copyWithin(指定替换元素的起始位置,  [ 指定读取元素开始位置 ],  [ 指定读取元素停止位置 ])</strong></p>
</li>
<li><p>说明：替换的内容就是 <strong>读取元素开始到结束位置之间的内容</strong></p>
</li>
<li><p>注意：会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">1</span>, <span class="number">3</span>))	<span class="comment">// 1 4 5 4 5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>检测（查询）数组内是否包含某项</p>
</blockquote>
<p><code>ES5</code> 中做法是利用 <code>indexOf()</code> 进行检测，<code>ES6</code> 中利用 <code>includes()</code> 进行检测</p>
<ul>
<li><p><strong>arr.indexOf(需要查找的元素，[ 指定开始查找的位置（合法取值：0 到 stringObject.length - 1）])</strong></p>
</li>
<li><p>说明：检测（查找）有则返回对应元素所在的索引，无则返回 -1</p>
</li>
<li><p>注意：无法检测 NaN</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">NaN</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">NaN</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>arr.includes(需要查找的元素, [ 指定开始查找的位置（默认 0，支持负数）])</strong></p>
</li>
<li><p>说明：检测（查找）有则返回 true，无则返回 false，如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索</p>
</li>
<li><p>注意：可以检测 NaN</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>注意：这两种方法都只能用于检测基本数据类型，不能检测引用数据类型</code></p>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>对于函数的重要性，我这里就不做过多的赘述了，我们常常利用函数进行封装一些我们想要处理的功能，这时候在 ES5 中，常常有个点是必须要考虑的，那就是函数的参数，比如哪些是必传的，哪些是可选的，然后进行一些列处理，等等操作。而在 ES6 中，其新特性为我们提供了很多便利。</p>
<blockquote>
<p>函数的默认值</p>
</blockquote>
<p>假设我们要封装一个方法，这个方法有个参数是必传的，另一个是可选的，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面的参数传递中，我只传了一个实参，那么输出的结果就是：hello undefined，因为 y 的值没有传嘛，所以 y 就是一个可选的参数，就需要做处理，ES5 中处理方式呢，就是这样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  y = y || <span class="string">&#x27;world&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断一些 y 的值有没有传，有的话就将传递给 y 的实参赋值给 y，不然就是取它的默认值 world，而假如我们传递给 y 的是 0 呢，0 是一个 false 的布尔值含义，所以 y 还是会被赋值默认值 world，这样我们在封装函数的时候就增加了思考量，所以 ES6 针对这一问题，给出了新的赋值默认值的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y = <span class="string">&#x27;world&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;hello&#x27;</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>一看上面的代码，相比之前 ES5 的处理方式而言，就简便很多了，直接给 y 一个默认值，有传递实参就是取该实参的值，没有就是取默认值，就不需要像 ES5 中那样的做法去做判断之类的操作。除了<code>代码简洁</code>，你还会发现它的<code>代码可阅读性很强</code>，一眼看去就可以看出哪些参数是必传的，哪些是可选的。另外就是当你后期想要对这个函数进行优化的时候，省去一些参数，那么这些默认的很方便就可以进行简洁优化！ </p>
<p><strong>注意：ES6 中这样处理函数参数默认值，这默认值必须位于所有形参的最后面</strong></p>
<blockquote>
<p>实参与形参巧用解构赋值</p>
</blockquote>
<p>关于解构赋值，前面已经说的很清楚了，所以这里也不做过多的赘述，形参与实参之间传递形成一种对应关系，进行解构赋值。</p>
<blockquote>
<p>length 属性</p>
</blockquote>
<p>length ，当你看到这个，第一想到的是不是数组的长度，其实这里的 length 不是指的数组的长度，而是 <strong>函数必传参数的个数，也称函数未指定默认值参数的个数</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y = <span class="number">2</span>, z = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.length)	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>很显然，未指定默认值的参数就是 x，所以输出 1，如果都指定默认值，那就是输出 0。</p>
<blockquote>
<p>尾逗号</p>
</blockquote>
<p>尾逗号是 ES8 中在函数的参数后面新增一个逗号，作用就是 git 仓库协同开发的过程中，使得代码的改动体现的更友好</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    a, </span></span></span><br><span class="line"><span class="function"><span class="params">    b, </span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符，顾名思义它是个运算符，表现形式是 <code>...</code> 三个点，相信你已经意思到这个点的含义了，没错，就是扩展！作用就是：<strong>把数组或类数组展开成用逗号隔开的值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c)	<span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">foo(...arr)</span><br></pre></td></tr></table></figure>

<p>从上面的例子中会发现，是不是有点解构赋值的感觉呢，其实不是，解构赋值要求两边的结构完全一样，但此时的结构并不一样，但 a，b，c 仍旧可以输出对应的值，这正是因为，在进行参数传递的时候，<code>...arr</code> 将数组 arr 的值展开了，那么这样的好处可以帮助我们做些什么事呢？最常见的可以说就是数组的合并了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment">// 传统 ES5 的做法</span></span><br><span class="line"><span class="comment">// Array.prototype.push.apply(arr1, arr2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的做法</span></span><br><span class="line">arr1.push(...arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)	<span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>因为 push，只能 push 单个值，所以借助展开运算符很方便的就可以进行数组的合并。当然这个并不仅仅适用于数组，试试看把一个字符串展开会是什么样呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(...str)	<span class="comment">// s u n n y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [...str]</span><br><span class="line"><span class="built_in">console</span>.log(arr)	<span class="comment">// [&quot;s&quot;, &quot;u&quot;, &quot;n&quot;, &quot;n&quot;, &quot;y&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面的结果是不是让你理解了之前说的：把数组或类数组展开成用逗号隔开的值~~</p>
<p>那么既然有扩展，那会不会有组合呢？是的，是有的，它叫 <code>rest 参数</code>，它的作用就是<strong>把逗号隔开的值组合成一个数组</strong>。下面我们来看一个例子，实现任意数的求和。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的方式 - arguments（ES6 已废除）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    sum += item</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>))		<span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))	<span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的方式 - from</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="comment">// from 将 arguments 伪数组转换成真数组</span></span><br><span class="line">  <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    sum += item</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的方式 - rest</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(args)</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  args.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    sum += item</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>从上面的方式中你会发现，是不是最后一种方式最简单、最实用呢，这也是 rest 的含义，不管你传递多少个参数，我都给你转成数组，注意是真正的数组哦，那么剩下的就是对数组进行操作了。所以这也是 rest 的一个应用场景之一：<strong>对于不确定参数的处理</strong>，下面再来看一个，部分参数确定，部分不确定的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)		<span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(args)		<span class="comment">// [2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>对于参数 x 是确定的，但剩下的是不确定的，那么把不确定的参数就是丢给 <code>...</code> 形成一个数组去处理，聪明的你应该很快就会想到，rest 是不是可以和解构赋值配合使用呢？是的，请看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, ...y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x)	<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(y)	<span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>所以，<strong>扩展运算符与 rest 参数互为逆运算</strong>，具体使用还是得结合具体的场景。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在 ES5 中，我们定义函数有两种形式，分别是具名函数和匿名函数，具体形式相信不用我多说了，这里主要说下两者的注意项：</p>
<ul>
<li>具名函数的调用没有位置限制（一般是全局声明，有需求的地方调用）</li>
<li>匿名函数调用需要在其声明之后</li>
</ul>
<p>ES6 中对函数存在的一些问题做了改进，具体形式就是箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>一个很形象的点就是它的那个箭头，你可以这样简单的理解：<strong>箭头左边的是参数，右边的是函数体</strong>，箭头函数就是匿名函数的改造版</p>
<p>箭头函数简化的几个点：（我的建议是：不省略，统一代码风格）</p>
<ul>
<li><p>函数体只有一条语句的时候，大括号可以省略</p>
</li>
<li><p>函数的参数只有一个参数的时候，括号可以省略</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function"><span class="params">x</span> =&gt;</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>箭头函数与普通函数的区别：</p>
<ul>
<li><strong>箭头函数是匿名函数，不能作为构造函数，不能使用 new 关键字，自然也就没有原型对象</strong></li>
<li><strong>箭头函数不绑定 arguments，取而代之的是用 rest 参数</strong></li>
<li><strong>箭头函数不绑定 this（没有 this），会捕获其所在的上下文的 this 值（箭头函数外层的作用域 this），作为自己的 this 值，任何方法都改变不了其指向</strong></li>
</ul>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性的简洁写法"><a href="#属性的简洁写法" class="headerlink" title="属性的简洁写法"></a>属性的简洁写法</h4><p>其实对于属性的简洁写法就一句话：<strong>key value 同名可只写其中一个</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">24</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name,	<span class="comment">// name: name</span></span><br><span class="line">    age		<span class="comment">// age: age</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<h4 id="方法的简洁写法"><a href="#方法的简洁写法" class="headerlink" title="方法的简洁写法"></a>方法的简洁写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// ES5 写法</span></span><br><span class="line">  study_1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在学习&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ES6 写法</span></span><br><span class="line">  study_2 () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在学习&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<p>其实还是你习惯那种写法就使用哪种写法</p>
<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>属性名表达式什么意思呢，就是：<strong>对象的属性变量（表达式）化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;school&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)	<span class="comment">// &#123;school: &quot;sunny&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看出，对象 obj 的属性 s，经过 <code>[ ]</code> 使得属性 s 变量化解析，所以得出上面的结果</p>
<h4 id="新增-Api"><a href="#新增-Api" class="headerlink" title="新增 Api"></a>新增 Api</h4><h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>作用：判断两个值是否严格相等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">2</span>, <span class="string">&#x27;2&#x27;</span>))	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>严格相等，意思就是<strong>数值和类型</strong>上都要相等，上述代码中，数字 2 和 字符串 2 肯定是不严格相等的，那么这个时候你肯定会想起 <code>===</code> ，三等也是严格相等，那么两者有什么区别呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>))	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>)			<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>))		<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === -<span class="number">0</span>)				<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>其实也说不上什么区别，就是对于有些特殊值的情况下严等的结果会不一样</p>
<p><strong>注意：两个对象即使内容一样，但它们是不相等的，原因是每一个对象都有自己的堆内存空间</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;sunny&#x27;</span>,</span><br><span class="line">  age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;sunny&#x27;</span>,</span><br><span class="line">  age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(obj1, obj2)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p>说到这个方法之前，我们前面有说到扩展运算符，但基本都是应用于数组中，其实对象也是可以的，只不过对象不能脱离对象本质展开出来，展开出来后要么直接用 { } 内部接收要么内部接收后赋值给另一个对象或变量，所以表面上看起来，好似没什么作用与改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  b: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(...x)  	// 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; ...x &#125;)	<span class="comment">// &#123;a: 3, b: 4&#125;</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; ...x &#125;</span><br><span class="line"><span class="built_in">console</span>.log(y)			<span class="comment">// &#123;a: 3, b: 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>那么真的就没什么用吗？其实是有的，从它的表现上来看，实现了<strong>对象的浅克隆</strong></p>
<p><strong>Object.assign() 方法主要是用于对象和合并，Object.assign(目标对象，…源对象)，返回目标对象</strong></p>
<p><strong>注意：同名的属性会进行覆盖，源对象覆盖目标对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  b: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y = &#123;</span><br><span class="line">  c: <span class="number">5</span>,</span><br><span class="line">  a: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(y, x)</span><br><span class="line"><span class="built_in">console</span>.log(y)	<span class="comment">// &#123;c: 5, a: 3, b: 4&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h4><p>对于对象的遍历，直接上方式吧，没啥可多说的，let obj = { name: ‘sunny’, age: 24 }</p>
<ul>
<li><p><strong>for in</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>下面的方式均是将<code>对象转数组</code>再对数组进行遍历，从而实现对对象的遍历</p>
<ul>
<li><p><strong>Object.keys()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Object.getOwnPropertyNames()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Reflect.ownKeys( 目标对象 )</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="扩展-—-对象深浅克隆"><a href="#扩展-—-对象深浅克隆" class="headerlink" title="扩展 — 对象深浅克隆"></a>扩展 — 对象深浅克隆</h4><p>对象深浅克隆也称对象深浅拷贝，其实说白了就是 copy 一份和原来一模一样的东西出来</p>
<p>目的：<strong>可能某个操作会导致原对象的结构或数据改变，但是我们并不想原对象的结构或数据发生改变，就只好复制一个与原对象一模一样的出来操作了</strong></p>
<p>如下：一个对象中的属性值，并不一定是基本的数据类型，还可能是数组，对象，正则等等，obj1 对象中，属性名 c 的值，又是一个对象，其中对象中 x 的值还可能是一个对象，这就是所谓的多维对象或者多维数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">100</span>,</span><br><span class="line">  b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  c: &#123;</span><br><span class="line">    x: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  d: <span class="regexp">/^\d+$/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浅拷贝（克隆）：只克隆第一层，即：只克隆 obj1 层，对于属性名 c 值这层或更深层不克隆</strong></p>
<p><strong>深拷贝（克隆）：全克隆</strong></p>
<blockquote>
<p>实现方式</p>
</blockquote>
<ul>
<li><p>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝实现方式 - 1</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1 &#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝实现方式 - 2</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.assign(obj2, obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝实现方式 - 3</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj1.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  obj2[key] = obj1[key]</span><br><span class="line">  <span class="comment">// 将 obj1 第一层拷贝（克隆）到 obj2 中</span></span><br><span class="line">  <span class="comment">// 那么实现深拷贝（克隆），那边对内层的对象再次进行该操作，便实现了深克隆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝实现方式 - 1</span></span><br><span class="line"><span class="comment"> *  - JSON.stringify(obj1) 将对象转换成字符串格式对象</span></span><br><span class="line"><span class="comment"> *  - JSON.parse() 字符串格式对象再变成 对象格式</span></span><br><span class="line"><span class="comment"> * 弊端：</span></span><br><span class="line"><span class="comment"> *  - 通过 JSON.stringify() 方法将对象转换成字符串，如果该对象中的属性名的值有</span></span><br><span class="line"><span class="comment"> *  - 函数、日期格式和正则等的数据值，那么会出现一些问题（即不可实现）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.stringify(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// &#123;&quot;a&quot;:100,&quot;b&quot;:[1,2,3],&quot;c&quot;:&#123;&quot;x&quot;:10&#125;,&quot;d&quot;:&#123;&#125;&#125;</span></span><br><span class="line">obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1))</span><br><span class="line"><span class="built_in">console</span>.log(obj2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝实现方式 - 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objDeedClone</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保证 obj 是一个对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测正则</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测时间日期格式</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * obj.constructor 保证传入的对象或者实例指向当前传入的 obj</span></span><br><span class="line"><span class="comment">   * 即：克隆的结果和之前保持相同的所属类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="keyword">new</span> obj.constructor()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj1.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObj[key] = obj1[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = objDeedClone(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h3><h4 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h4><p>对于<code>类</code>这个概念相信大家都很清楚，我也不过多的去赘述了。这是个面向对象编程的时代，虽然 JavaScript 是<code>基于对象</code>编程的语言，但基本不过多的去深究的话，是可以理解成面向对象编程的语言的，那么它在传统 <code>ES5</code> 中的体现是怎样的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类：其实就是构造函数</span></span><br><span class="line"><span class="comment"> *   - 首字母一般大写，区别于普通函数</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> *   - 可以传：如，name, age 等</span></span><br><span class="line"><span class="comment"> *   - 也可以不传：这样内部属性的值就是写死的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实例属性：如下</span></span><br><span class="line"><span class="comment">   *   - 构造函数内部通过 this 定义</span></span><br><span class="line"><span class="comment">   *   - 通过 实例对象 进行获取调用</span></span><br><span class="line"><span class="comment">   *   - 不能通过 构造函数名 获取调用</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  People.count++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态属性：如下</span></span><br><span class="line"><span class="comment"> *  - 构造函数外部通过 构造函数名 定义</span></span><br><span class="line"><span class="comment"> *  - 通过 构造函数名 获取调用</span></span><br><span class="line"><span class="comment"> *  - 不能通过 实例对象 获取调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">People.count = <span class="number">0</span></span><br><span class="line"><span class="comment">// 静态方法：同理静态属性</span></span><br><span class="line">People.getCount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age) <span class="comment">// undefined，因为静态方法的 this 指向当前的构造函数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;当前共有&#x27;</span> + People.count + <span class="string">&#x27;个人&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法：同理实例属性，不过一般实例方法定义在构造函数外部的原型上</span></span><br><span class="line">People.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this) // 实例方法的 this 指向的是实例对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> People(<span class="string">&#x27;sunny&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line">p1.showName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> People(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p2)</span><br><span class="line">p2.showName()</span><br><span class="line"><span class="built_in">console</span>.log(People.count)</span><br><span class="line">People.getCount()</span><br></pre></td></tr></table></figure>

<p>了解了类这个概念和形式，那么在面向对象编程中，还有个很重要的点就是<code>继承</code>，在 ES5 中对继承的实现方式也有很多种，下面介绍三种主要的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;名字是:&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造函数继承</p>
</blockquote>
<p>当我们 new 出 Dog 这个实例对象的时候，将通过 call 方法，将 Dog 的 this 传递到父类，让<strong>父类中的实例对象指向 Dog 这个实例对象</strong>。</p>
<p><code>理解：</code>Animal 找到了失散多年的一个儿子 Dog，那么 Dog 自然就可以用父亲的东西了</p>
<ul>
<li><p><strong>子类只能继承父类的属性</strong>，不能继承父类的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// name 属性是从父类那继承而来的</span></span><br><span class="line">  Animal.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="comment">// 子类特有属性 color</span></span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> d1 = <span class="keyword">new</span> Dog(<span class="string">&#x27;wangcai&#x27;</span>, <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(d1)</span><br><span class="line">d1.showName()	<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>原型继承</p>
</blockquote>
<p>Dog 的原型指向 Animal 的实例化对象，Dog 原型的构造函数指回 Dog</p>
<p>不理解的请自行补习 <code>原型及原型链</code> 相关的知识</p>
<ul>
<li><p><strong>子类只能继承父类的方法</strong>，不能继承父类的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dog 的原型指向 Animal 的实例化对象</span></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="comment">// Dog 原型的构造函数指回 Dog</span></span><br><span class="line">Dog.prototype.constuctor = Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d1 = <span class="keyword">new</span> Dog(<span class="string">&#x27;wangcai&#x27;</span>, <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(d1)</span><br><span class="line">d1.showName() <span class="comment">// 名字是：undefined</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>组合继承</p>
</blockquote>
<p>组合继承，顾名思义就是构造函数继承和原型继承的结合方式，这样就可以实现<strong>属性和方法都可以继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数继承</span></span><br><span class="line">  Animal.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line">Dog.prototype.constuctor = Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d1 = <span class="keyword">new</span> Dog(<span class="string">&#x27;wangcai&#x27;</span>, <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"><span class="comment">// 两者结合：组合继承</span></span><br><span class="line"><span class="built_in">console</span>.log(d1)</span><br><span class="line">d1.showName()</span><br></pre></td></tr></table></figure>

<p>了解了 ES5 对类和继承的相关概念和形式后，你的感觉是什么呢？这个就因人而异了，下面我们来看看 <code>ES6</code> 新特性中关于类与继承的概念和形式</p>
<p><code>ES6</code> 中提供了一个关键字 <code>class</code> 来帮助我们轻松定义一个类，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  showName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法：static 关键字进行声明，但是调用还是和之前 ES5 方式一样</span></span><br><span class="line">  <span class="keyword">static</span> getCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态属性：定义方式和调用方式同 ES5 一样</span></span><br><span class="line">People.count = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> People(<span class="string">&#x27;sunny&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="built_in">console</span>.log(People.count)</span><br><span class="line"><span class="built_in">console</span>.log(People.getCount())</span><br></pre></td></tr></table></figure>

<p>看起来有没有感觉很清爽呢，是的，其实这就是 ES6 带来的便利，也就是语法糖，但是 <strong>ES6 并不支持定义静态方法那样去定义定义静态属性，静态属性的定义和调用还是和之前 ES5 一样，静态方法虽然可以通过 static 关键字进行那样定义，但是调用方式还是和 ES5 一样</strong></p>
<p>当然 ES6 提供的关键字 class 不仅仅是提供定义类带来了便利，还提供了 <code>get</code> 和 <code>set</code>。<strong>get 声明一个属性是只读的，要对其进行赋值需要通过 set 进行</strong>，所以通过 get 和 set 可以进行一些业务逻辑操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为避免 set 设置值时候出现的死循环而引入的新属性</span></span><br><span class="line">    <span class="built_in">this</span>._sex = -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  get sex () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._sex === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;male&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>._sex === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;female&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  set sex (val) &#123;</span><br><span class="line">    <span class="comment">// this.sex = val // 会造成死循环，设置值就会触发 set，不断设置不断触发，就死循环了</span></span><br><span class="line">    <span class="keyword">if</span> (val === <span class="number">0</span> || val === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>._sex = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> People(<span class="string">&#x27;sunny&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="comment">// 对 sex 实例属性进行赋值，触发 set 设置值</span></span><br><span class="line">p1.sex = <span class="number">5</span></span><br><span class="line"><span class="comment">// 读取 sex 属性的值，触发 get 进行读取 </span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sex)</span><br></pre></td></tr></table></figure>

<p>通过上述例子，我们可以发现，<strong>通过 get 和 set ，我们可以对其声明的属性进行一些逻辑业务操作，注意点：最后调用的属性还是 get 和 set 声明的属性（如：sex），而新引入的属性（如：_sex）是为了解决 set 赋值出现死循环的问题而引入的，所以当你希望你在设置属性和获取属性的时候，希望有一些业务逻辑操作，而不是直接去获取和设置的时候，就需要把这个属性声明一个 get 和 set</strong></p>
<p>那么在继承上呢？<code>ES6</code> 提供了个关键字 <code>extends</code> 很方便的实现了<code>继承</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, age, company</span>) &#123;</span><br><span class="line">    <span class="comment">// 继承父类的 name age</span></span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">    <span class="built_in">this</span>.company = company</span><br><span class="line">  &#125;</span><br><span class="line">  showCompany () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.company)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c1 = <span class="keyword">new</span> Coder(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;sunny&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c1)</span><br><span class="line">c1.showName()</span><br><span class="line">c1.showCompany()</span><br><span class="line">c1.sex = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(c1.sex)</span><br><span class="line"><span class="built_in">console</span>.log(Coder.getCount())</span><br></pre></td></tr></table></figure>

<p>通过上述方式我们可以发现，子类对父类的继承是完全继承的，但是要注意的就是，<strong>静态属性的定义和获取调用还是和 ES5 一样，而静态方法的定义采取 static 关键字，获取调用还是和 ES5 一样</strong> </p>
<p>其中关于 <strong>super 关键字</strong>的注意事项，请参考阮一峰大佬写的 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#super-%E5%85%B3%E9%94%AE%E5%AD%97"><strong>ES6 入门教程</strong></a></p>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>我们都知道 JavaScript 原始数据类型一共有 Number、String、Boolean、null、undefined、Object（Array 和 function 都属于对象）六种，而 ES6 中又增加了一位新成员 <code>Symbol</code>，<strong>表示的是独一无二的，并不是对象，可以理解为不重复的 “字符串”</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line"><span class="built_in">console</span>.log(s2)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>独一无二嘛，肯定 s1 和 s2 不相等，所以为了区别 s1 和 s2，可以为 Symbol 添加描述：以字符串的形式传入给 Symbol()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)	<span class="comment">// Symbol(&#x27;foo&#x27;)</span></span><br><span class="line"><span class="built_in">console</span>.log(s2)	<span class="comment">// Symbol(&#x27;bar&#x27;)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>添加了描述的 Symbol，输出的也是带描述的 Symbol，这样我们就可以知道具体是哪个值，不仅输出上可以看出，字面上也可以看出。</p>
<p><strong>注意：当传入的描述是一个对象的时候，Symbol 会调用 toString 方法将对象转换成字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;imooc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(obj)</span><br><span class="line"><span class="built_in">console</span>.log(s)	<span class="comment">// Symbol([object, object])</span></span><br></pre></td></tr></table></figure>

<p>其实 Symbol 还是有为 true 的时候</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>当用 Symbol.for 去声明一个 Symbol 的时候，并所添加的描述一致的时候，所声明的 Symbol 是一样的</strong>，原因就是：以这样的方式声明的 Symbol 是一个全局的 Symbol，当你再次以 Symbol.for 去声明的时候，它首先会去全局环境下找是否有声明过这样描述的 Symbol，如果有那么你再次声明的会指向前面声明的，所以它们是一样的。（<strong>和定义位置无关，以这种方式定义的 Symbol 就是一个全局环境下的</strong>）</p>
<ul>
<li><p><strong>Symbol.keyFor</strong></p>
<p>作用：返回一个已经 <code>全局登记</code> 的 Symbol 描述</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2)) <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>常见应用场景</strong></p>
</blockquote>
<ul>
<li><p><strong>把 Symbol 作为当前对象的 key，以保证当前的 key 并不冲突</strong> </p>
<p>我们都知道，一个对象的属性是唯一的、不重复的，当我们用一个对象来存储一个班级信息的时候，班级可能存在同名但是信息不同的两个人，这样就会导致后定义的那个人就会把前一个同名的人的信息覆盖（属性和值），这样不就少了一个人嘛</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stu1 = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="keyword">const</span> stu2 = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="keyword">const</span> grade = &#123;</span><br><span class="line">  [stu1]: &#123; <span class="attr">address</span>: <span class="string">&#x27;yyy&#x27;</span>, <span class="attr">tel</span>: <span class="string">&#x27;222&#x27;</span> &#125;,</span><br><span class="line">  [stu2]: &#123; <span class="attr">address</span>: <span class="string">&#x27;zzz&#x27;</span>, <span class="attr">tel</span>: <span class="string">&#x27;333&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(grade)	<span class="comment">// &#123;李四: &#123; address: &#x27;zzz&#x27;, tel: &#x27;333&#x27; &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stu1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> stu2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> grade = &#123;</span><br><span class="line">  [stu1]: &#123; <span class="attr">address</span>: <span class="string">&#x27;yyy&#x27;</span>, <span class="attr">tel</span>: <span class="string">&#x27;222&#x27;</span> &#125;,</span><br><span class="line">  [stu2]: &#123; <span class="attr">address</span>: <span class="string">&#x27;zzz&#x27;</span>, <span class="attr">tel</span>: <span class="string">&#x27;333&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(grade) <span class="comment">// &#123;Symbol(李四): &#123;…&#125;, Symbol(李四): &#123;…&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(grade[stu1])	<span class="comment">// &#123;address: &quot;yyy&quot;, tel: &quot;222&quot;&#125; 一样可以获取对象的 value</span></span><br><span class="line"><span class="built_in">console</span>.log(grade[stu2])	<span class="comment">// &#123;address: &quot;zzz&quot;, tel: &quot;333&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对属性进行隐藏，保护属性（只是一定程度上）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;guohaoqi&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>[sym] = <span class="string">&#x27;guohaoqi.com&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>[sym]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="string">&#x27;sunny&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>对 user 进行遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)	<span class="comment">// name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(user)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)	<span class="comment">// name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现 for in 和 for of 都无法遍历出 Symbol(‘guohaoqi’) 属性，在一定程度上起到了 <code>保护 / 隐藏</code> 的作用</p>
<p>但如果只要 Symbol(‘guohaoqi’) 属性，可以采用 <code>Object.getOwnPropertySymbols</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.getOwnPropertySymbols(user)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)	<span class="comment">// Symbol(guohaoqi)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者都要的话可以采用 <code>for of</code> 结合 <code>Reflect.ownKeys()</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(user)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)	<span class="comment">// name Symbol(guohaoqi)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消除重复字符串，降低代码耦合度</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span></span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Triangle&#x27;</span>:</span><br><span class="line">      area = <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Circle&#x27;</span>:</span><br><span class="line">      area = <span class="number">2</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(<span class="string">&#x27;Triangle&#x27;</span>))	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>消除 ‘Triangle’ 和 ‘Circle’ 后的改进代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  triangle: <span class="built_in">Symbol</span>(),</span><br><span class="line">  circle: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span> (<span class="params">shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span></span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.triangle:</span><br><span class="line">      area = <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> shapeType.circle:</span><br><span class="line">      area = <span class="number">2</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArea(shapeType.triangle))	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>改进后的代码显然没有出现一个字符串</p>
</li>
</ul>
<h3 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h3><p>Set 和 Map 都是 ES6 新引入的新型数据结构，特点都是：<strong>存储的值都是唯一的，不重复的</strong></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><blockquote>
<p><strong>常用 API</strong></p>
</blockquote>
<ul>
<li><p>添加：<code>add</code> 、删除：<code>delete</code> 和 清空：<code>clear</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">s.add(<span class="string">&#x27;sunny&#x27;</span>).add(<span class="string">&#x27;es&#x27;</span>)	<span class="comment">// 添加，支持链式操作</span></span><br><span class="line">s.delete(<span class="number">2</span>)	<span class="comment">// 删除某个值</span></span><br><span class="line">s.clear()	<span class="comment">// 清空</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否有哪个值：<code>has</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.has(<span class="string">&#x27;sunny&#x27;</span>))	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当前 Set 有多少个值：size</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.size)	<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历：之前学到的用于遍历数组的方式，对 Set 基本都适用</p>
<p>注意：<strong>Set 中键和值是一样的</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如：</span></span><br><span class="line"><span class="comment"> * set.keys(): 读取所有的 key 值</span></span><br><span class="line"><span class="comment"> * set.values(): 读取所有的 value 值</span></span><br><span class="line"><span class="comment"> * set.entries(): 读取所有的 key value 值</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>常见应用</strong></p>
</blockquote>
<ul>
<li><p>数组去重 和 合并去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并去重</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([...arr1, ...arr2])</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 结构 -&gt; array 结构的两种方式</span></span><br><span class="line"><span class="built_in">console</span>.log([...s])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(s))</span><br></pre></td></tr></table></figure>
</li>
<li><p>求交集 和 差集</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2)</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1.filter(<span class="function"><span class="params">item</span> =&gt;</span> s2.has(item)))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(result))	<span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2)</span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1.filter(<span class="function"><span class="params">item</span> =&gt;</span> !s2.has(item)))</span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2.filter(<span class="function"><span class="params">item</span> =&gt;</span> !s1.has(item)))</span><br><span class="line"><span class="built_in">console</span>.log([...arr3, ...arr4])	<span class="comment">// [1, 5, 6]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="扩展-WeakSet"><a href="#扩展-WeakSet" class="headerlink" title="扩展 - WeakSet"></a>扩展 - WeakSet</h4><p><code>特点：</code></p>
<ul>
<li><strong>WeakSet 只能存储对象，不能存储数字、字符串之类的</strong></li>
<li><strong>Set 常见的 API ，WeakSet 也适用，如：add，delete，has</strong></li>
<li><strong>WeakSet 不能被遍历，是一种弱引用，所以不存在垃圾回收机制</strong></li>
</ul>
<p><code>弱引用：</code><strong>相当于对 WeakSet 的引用，它不会被计入垃圾回收机制，所以不存在垃圾回收机制，所以适用于临时存放一些对象，这些对象被销毁，WeakSet 对这些对象的引用也会消失</strong></p>
<p><code>垃圾回收机制：</code><strong>计数的回收机制，假如定义一个变量，刚定义的时候结果是 0，这个值被引用一次结果就会 +1，依此类推，只要这个值结果不为 0，垃圾回收机制就不会回收这个值，也就是不会释放当前这个内存空间</strong></p>
<p><code>注意：</code><strong>因为只能存储对象，对象是引用类型，每一个对象都有自己独立开辟的空间，所以删除的时候需要注意删除对应的对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line">ws.add(<span class="number">1</span>)	<span class="comment">// Invalid value used in weak set 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  age: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">ws.add(obj1)</span><br><span class="line">ws.add(obj2)</span><br><span class="line"><span class="comment">// ws.delete(obj1)</span></span><br><span class="line"><span class="built_in">console</span>.log(ws)	<span class="comment">// WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ws.has(obj2)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map 也是类似对象一样的新型数据结构，但比对象更简洁</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>常用 API</strong></p>
</blockquote>
<ul>
<li><p>设置值、获取值和删除值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置值 set( key, value )</span></span><br><span class="line">m.set(obj, <span class="string">&#x27;es&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取值 get( key )</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(obj))</span><br><span class="line"><span class="comment">// 删除值 delete( key )</span></span><br><span class="line">m.delete(obj)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取值的数量 和 查询值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;imooc&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">5</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 获取值的数量</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size)</span><br><span class="line"><span class="comment">// 查询值</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历</p>
<p>同 Set，但 <strong>Map 的 key 和 value 是可以不一样的</strong>，但遍历方式基本一样</p>
<p>注意：<strong>用 forEach 遍历的时候，key 和 value 的顺序是相反的，其它的是正常的</strong>，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(value, key))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>常见应用：传统对象的应用场景，Map 都适用</strong></p>
</blockquote>
<h4 id="扩展-WeekMap"><a href="#扩展-WeekMap" class="headerlink" title="扩展 - WeekMap"></a>扩展 - WeekMap</h4><p><strong>基本同 WeakSet，WeekMap 不支持 clear() 方法和 size() 方法，同样也不支持遍历，其 key 必须是一个引用类型</strong></p>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><h4 id="UniCode"><a href="#UniCode" class="headerlink" title="UniCode"></a>UniCode</h4><p>UniCode 是一种很神奇的编码，可以表示很多类型的字符，ES6 对 UniCode 进行了进一步的加强，加强点主要是对 <code>码点</code> 进行了改进和加强，传统的码点是有一定范围的：<code>0000 ~ ffff</code>，超出这个范围就会出错，转换成一个不认识的符号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：\u&#123;对应码点值&#125;	<span class="comment">// 这样的好处就是，这样这个码点就不仅仅局限于那个范围了</span></span><br></pre></td></tr></table></figure>

<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串，这个在项目中用的非常的多，相比传统的字符串拼接，学了这个后，你会发现这个方便多了</p>
<p>模板字符串：用反引号去替换传统的单引号和双引号</p>
<blockquote>
<p>直接换行</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str4 = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;2&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;3&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="built_in">console</span>.log(str4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;3&lt;/li&gt;</span></span><br><span class="line"><span class="comment">// &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure>

<p>试想一下，上面这个，如果你用 + 去做字符串拼接，要写的多罗嗦，还容易出错</p>
<blockquote>
<p>含有变量或者表达式：**${ 变量名 或 表达式 }**</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">14</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">&#x27;ES&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str5 = <span class="string">`我的年龄是:<span class="subst">$&#123;a + b&#125;</span>,我在学<span class="subst">$&#123;c&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(str5)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>嵌套模板</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isLargeScreen = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> class2 = <span class="string">`icon icon-<span class="subst">$&#123;isLargeScreen() ? <span class="string">&#x27;big&#x27;</span> : <span class="string">&#x27;small&#x27;</span>&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(class2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>带标签的模板字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo(1, 2, 3, 4)</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">24</span></span><br><span class="line">foo<span class="string">`这是<span class="subst">$&#123;name&#125;</span>,他的年龄是<span class="subst">$&#123;age&#125;</span>岁`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;这是&quot;, &quot;,他的年龄是&quot;, &quot;岁&quot;, raw: Array(3)]</span></span><br><span class="line"><span class="comment">// sunny</span></span><br><span class="line"><span class="comment">// 24</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>很显然，输出结果，一方面给我们转换成了数组，另一方面变量部分做了对应输出，所以这种带标签的模板字符串，会做对应转换和输出，<strong>以变量为基准，变量前后的会按序转变为数组的项，而对应变量则输出对应的值，并且其中还包含一个 raw，这是原始字符串</strong></p>
<h4 id="新-API"><a href="#新-API" class="headerlink" title="新 API"></a>新 API</h4><ul>
<li><p><strong>String.fromCodePoint()</strong></p>
<p>作用：将对应 uniCode 码点转换成对应字符返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)) <span class="comment">// ES5: 超过范围的不能识别</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)) <span class="comment">// ES6: 超过范围的仍可识别</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>String.prototype.includes()</strong></p>
<p>作用：类似 ES5 中的 indexOf，查找对应字符串中是否包含某字符，包含返回 true，否则返回 false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">&#x27;su1&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>String.prototype.startsWith() 和 String.prototype.endsWith()</strong></p>
<p>作用：前者表示该字符串以什么字符开头，后者表示以什么字符结尾</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">&#x27;su&#x27;</span>))	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&#x27;unn&#x27;</span>))	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>String.prototype.repeat()</strong></p>
<p>作用：让指定字符串重复多少次，进行拼接返回一个新字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="comment">// 5：表示重复 5 此</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.repeat(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr)	<span class="comment">// sunnysunnysunnysunnysunn</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="字符串遍历器接口"><a href="#字符串遍历器接口" class="headerlink" title="字符串遍历器接口"></a>字符串遍历器接口</h4><p>其实就是用 for of 去遍历字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="string">&#x27;sunny&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h3><p>关于正则，其实没什么好说和需要注意的，需要了解更多的可以前往阮一峰大佬的 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/regex">正则的扩展</a></p>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><p>关于数值，其实没什么好说和需要注意的，需要了解更多的可以前往阮一峰大佬的 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/number">数值的扩展</a></p>
<p>幂运算符</p>
<p>ES7 新增了一个幂运算符：<code>**</code>，等同于 Math.pow()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 底数，10 指数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> ** <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h3 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h3><p>待更新</p>
<h3 id="异步解决方案"><a href="#异步解决方案" class="headerlink" title="异步解决方案"></a>异步解决方案</h3><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 是一个 ES6 中提出的异步解决方案，比如可以避免解决异步操作出现的回调地狱问题，从而更优雅的编写异步代码，下面来看下它的基本使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise 的精髓在于状态管理</span></span><br><span class="line"><span class="comment"> * resolve: 异步操作执行成功的回调函数</span></span><br><span class="line"><span class="comment"> * reject: 异步操作执行失败的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sunny&#x27;</span>)</span><br><span class="line">        <span class="comment">// 符合某个条件，判断调用成功与否</span></span><br><span class="line">        <span class="comment">// if(...)&#123;</span></span><br><span class="line">        <span class="comment">//     resolve()</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     reject()</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// resolve(&#x27;成功&#x27;)</span></span><br><span class="line">        reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行成功，resolve() 的进一步操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行失败，reject() 的进一步操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise 是一个构造函数，需要通过 new 关键字进行实例化操作，并且支持 <code>链式编程</code>，即 <code>.then</code> 的链式调用，其中 .then 也有两个参数，第一个是：<strong>resolve() 异步操作执行成功的回调函数所进行的进一步操作，并且可以进行参数传递，如上述的 resolve(‘成功’)，.then 的第一个参数函数接收，并 res 接收入参，从而进行进一步的处理</strong>，第二个同理，<strong>reject()</strong> 的相关处理。</p>
<p>假如我有一个需求，需要实现 省 | 市 | 县 的联动，那么就可以借助 Promise 的链式操作来实现，new Promise 包裹第一个异步操作，执行 省 的选取，将选取的省，如 湖南省，作为参数传递给 .then 进行该省下的 市 级进行选取，同理县级操作，这样就保证了异步的按需顺序执行</p>
<p>当然，<strong>new Promise 包裹第一个异步操作是立即执行的</strong>，如下的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"><span class="comment">// 1 2 5 3</span></span><br></pre></td></tr></table></figure>

<p>我们假设 new Promise 里包裹的是一个异步操作且该操作会执行成功，所以自然不会走 reject() -&gt; err =&gt; { console.log(‘4’) }，但 .then 中的回调操作不会立即执行，需要等 resolve() 执行回调成功后执行，所以输出的结果是：1 2 5 3，具体的详细原因可以去了解 JavaScript 的线程机制和宏任务、微任务以及同步异步相关的操作。</p>
<blockquote>
<p>Promise 的三种状态</p>
</blockquote>
<ul>
<li><p>进行中（pending）：异步操作正在执行中的状态</p>
</li>
<li><p>成功（fulfilled）：异步操作执行结果为成功的状态</p>
</li>
<li><p>失败（rejected）：异步操作执行结果为失败的状态</p>
</li>
</ul>
<p><strong>注意：Promise 状态是不可逆的，并且是不可改变的，取决于当前的异步操作</strong></p>
<blockquote>
<p>Promise 解决（改写）回调深渊</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：一定要记得 return 一个 new Promise 进行操作</span></span><br><span class="line"><span class="comment"> * 原因：不然就是对一个空 Promise 对象进行，也就是 “脱链”，从而达不到想要的效果</span></span><br><span class="line"><span class="comment"> * 失败状态的处理：.catch 去做统一捕获处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    ajax(<span class="string">&#x27;static/a.json&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a成功&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        ajax(<span class="string">&#x27;static/b.json&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b成功&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        ajax(<span class="string">&#x27;static/c.json&#x27;</span>, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;c成功&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise 静态方法</p>
</blockquote>
<ul>
<li><p>resolve 和 reject</p>
<p>含义：当没有 Promise 实例的时候，对于相关异步结果分开操作，返回 Promise 实例进行 .then 操作</p>
<p>返回：Promise 对象，使得当我们没有 Promise 实例的时候，仍然可以调用它的实例方法，如 .then 等</p>
<p>接收：可以接收字符串等可被 Promise 对象解析的参数，也可以是一个<code>Promise</code>对象，或者是一个 thenable</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 异步操作成功</span></span><br><span class="line">            resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 异步操作失败 return &#x27;fail&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">false</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>all</p>
<p>含义：当<code>所有</code>异步操作都执行成功后才会执行 .all 这个静态方法，如果哪怕有一个失败，都不会执行 .all</p>
<p>返回：返回一个 Promise 实例</p>
<p>接收：一个数组（由多个 Promise 实例组成的数组）或别的可迭代对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">        resolve(<span class="string">&#x27;1成功&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// resolve(&#x27;2成功&#x27;)</span></span><br><span class="line">        reject(<span class="string">&#x27;2失败&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">        resolve(<span class="string">&#x27;3成功&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)	<span class="comment">// 成功，会执行并输出：[ &quot;1成功&quot;, &quot;2成功&quot;, &quot;2成功&quot; ]</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)	<span class="comment">// 失败，不会执行输出，进入 reject 或者 catch</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实际应用场景：多张图片全部上传成功提示用户 - 上传成功</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgArr = [<span class="string">&#x27;1.jpg&#x27;</span>, <span class="string">&#x27;2.jpg&#x27;</span>, <span class="string">&#x27;3.jpg&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> promiseArr = []</span><br><span class="line">imgArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    promiseArr.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 图片上传的操作</span></span><br><span class="line">        resolve()</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all(promiseArr).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 插入数据库的操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;图片全部上传完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>race</p>
<p>介绍：使用基本同 all，区别在于，race 只要有一个异步是成功，那么就认为整体的状态是成功的，相反只要有一个异步是失败，那么就认为整体的状态是失败的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实际应用场景：加载图片</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载图片，可能有的成功，也有的可能失败</span></span><br><span class="line"><span class="comment"> * 设定一个超时，如：2s 内为成功，超过 2s 为失败，显示加载超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(img)</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = <span class="string">&#x27;http://www.xxx.com/xx.jpg&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="string">&#x27;图片请求超时&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([getImg(), timeout()]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p>Generator 是一种异步解决方案，但它不同于其它的异步解决方案，它可以让你的程序在执行的过程中<code>暂停</code>。</p>
<p>Generator 的两个特征：*<em>1、带有 * ，2、带有 yield 关键字*</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用 foo 这个函数的时候，你会发现控制台并没有打印输出 i 的值，这就是 Generator 的特点，需要手动的去调用执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = foo()</span><br><span class="line"><span class="built_in">console</span>.log(f.next())	<span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next())	<span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next())	<span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.next())	<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过手动调用 f.next() 方法，输出的结果是生成器的迭代器对象，value 值表示输出的是当前的值，done: false 表示的是当前是否执行完，这里是未执行完</p>
<p>注意点：<strong>1、Generator 不能作为构造器函数使用；2、yield 只能在 Generator 函数内去使用</strong></p>
<p>关于 yield 关键字和 next() 函数的联系</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span>(x + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span>(y / <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">12</span>)) <span class="comment">// y = 2 * 12，所以：z = 24 / 3 = 8</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">13</span>)) <span class="comment">// z = 13 x = 5 42</span></span><br></pre></td></tr></table></figure>

<p>next() 调用会去执行 yield 关键字后面的代码，所以是 6，很好理解，那么第二次调用 next()，(yield(x + 1)) 的值是多少呢？这个时候就是关键的地方了，next() 是可以进行传参的，参数对应的就是上一次 yield 关键字执行表达式返回的结果，而这里并没有传参，所以是 NaN，而传递参数的就是上述的结果，认知上可能存在很多的不一样，习惯就好了</p>
<p>通过 Generator 函数对异步操作进行管控</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建XMLHttpRequest对象</span></span><br><span class="line">    <span class="keyword">var</span> xmlhttp</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        xmlhttp = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兼容早期浏览器</span></span><br><span class="line">        xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、发送请求</span></span><br><span class="line">    xmlhttp.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line">    xmlhttp.send()</span><br><span class="line">    <span class="comment">// 3、服务端响应</span></span><br><span class="line">    xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState === <span class="number">4</span> &amp;&amp; xmlhttp.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(xmlhttp.responseText)</span><br><span class="line">            <span class="comment">// console.log(obj)</span></span><br><span class="line">            callback(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    ajax(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 一步一步的执行</span></span><br><span class="line">        getData.next(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request 三次调用 三次结果 按照我们想要的顺序执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">yield</span> request(<span class="string">&#x27;static/a.json&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">yield</span> request(<span class="string">&#x27;static/b.json&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">    <span class="keyword">let</span> res3 = <span class="keyword">yield</span> request(<span class="string">&#x27;static/c.json&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getData = gen()</span><br><span class="line">getData.next()</span><br></pre></td></tr></table></figure>

<h4 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h4><p>async / await 是 ES8 中新增的异步解决方案，相比之前的 Promise 和 Generator 来说，语义化更好，代码更简洁</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;sunny&#x27;</span> 	<span class="comment">// 相当于 Promise.resolve(&#x27;sunny&#x27;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo())	<span class="comment">// Promise &#123;&lt;resolved&gt;: &#x27;sunny&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>既然是异步解决方案，那么它又是怎么解决异步问题的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个异步操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 不传递参数</span></span><br><span class="line">            <span class="comment">// console.log(1)</span></span><br><span class="line">            <span class="comment">// resolve()</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 传递参数</span></span><br><span class="line">            resolve(<span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// await 后跟一个异步操作</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不传递参数</span></span><br><span class="line">    <span class="comment">// await timeout()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递参数</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> timeout()</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()	<span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

<p>在 async 函数内部声明一个 await 关键字，意思就是：等后面的异步代码执行完再执行后面的代码，其实这就是 Generator 的语法糖</p>
<p>当然，每一个异步操作不可能全是成功的，失败的处理方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// resolve(&#x27;success&#x27;)</span></span><br><span class="line">            reject(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// async 函数返回的是一个 Promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> timeout()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以可以结合 Promise 的实例方法进行解决</span></span><br><span class="line">foo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以其实，往往更多的时候，async / await 是结合 Promise 去解决一些异步问题的，像请求数据，应该就是最常见的异步操作，可以使用 Axios 等基于 Ajax 封装的库进行，因为像这样的库返回的也是 Promise，所以操作起来会很方便</p>
<blockquote>
<p>async / await 特点</p>
</blockquote>
<ul>
<li>async 函数返回的是一个 Promise 对象</li>
<li>await 关键字一定要使用在 async 函数内部</li>
</ul>
<h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h3><p>迭代器是一种接口机制，为各种不同的数据结构提供统一访问的机制，主要给 for of 进行，其实说白了就是：不支持遍历的数据结构，让其可遍历</p>
<p>我们先回忆一下上面的 Generator，有说到调用 next() 方法，输出的结果是生成器的迭代器对象，那么我们来实现一下这个</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nextIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; arr.length ? &#123;</span><br><span class="line">                value: arr[nextIndex++],</span><br><span class="line">                done: <span class="literal">false</span></span><br><span class="line">            &#125; : &#123;</span><br><span class="line">                value: <span class="literal">undefined</span>,</span><br><span class="line">                done: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = makeIterator([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br></pre></td></tr></table></figure>

<p>通过上述的实现，我们可以看出，<strong>遍历器对象的本质就是一个指针对象</strong></p>
<p>上述对于数组 [‘a’, ‘b’, ‘c’] 而言，本身就是可迭代（遍历）的，那么它为什么可遍历呢？</p>
<p>一般我们对于一种数据结构，看其是否可遍历，主要是看其是否具有 <code>Symbol.iterator</code> ，只要你当前这个对象中 Symbol 有这个，就说明是可遍历的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> c <span class="keyword">of</span> courses</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">// 固定写法</span></span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br><span class="line"><span class="built_in">console</span>.log(it.next())</span><br></pre></td></tr></table></figure>

<p>所以，对于数组这种结构，它自带这个 Symbol.iterator，也就是说它自身遵循了 iterator 这个协议，自然可遍历</p>
<p>常见遵循了 iterator 这个接口协议的数据结构</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>arguments 伪数组</li>
<li>DOM 对象（NodeList）</li>
</ul>
<p>所以想让一种不可遍历的数据结构变成可遍历的，就得让他遵循 iterator 这个接口协议，即这个 Tips</p>
<blockquote>
<p>Tips</p>
<p>可迭代协议：是否具有 Symbol.iterator，有 -&gt; 可迭代，无 -&gt; 不可迭代</p>
<p>迭代器协议：当前结构必须符合：return { next(){ return{value, done} }}，见上述实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可遍历数据结构</span></span><br><span class="line"><span class="keyword">let</span> courses = &#123;</span><br><span class="line">    allCourse: &#123;</span><br><span class="line">        frontend: [<span class="string">&#x27;ES&#x27;</span>, <span class="string">&#x27;小程序&#x27;</span>, <span class="string">&#x27;Vue&#x27;</span>, <span class="string">&#x27;React&#x27;</span>],</span><br><span class="line">        backend: [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;SpringBoot&#x27;</span>],</span><br><span class="line">        webapp: [<span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;IOS&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变成可遍历</span></span><br><span class="line">courses[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遵循可迭代协议 Symbol.iterator</span></span><br><span class="line">    <span class="keyword">let</span> allCourse = <span class="built_in">this</span>.allCourse</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Reflect</span>.ownKeys(allCourse)</span><br><span class="line">    <span class="comment">// 遵循迭代器协议 return &#123; next()&#123; return&#123;value, done&#125; &#125;&#125;</span></span><br><span class="line">    <span class="keyword">let</span> values = []</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!values.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (keys.length) &#123;</span><br><span class="line">                    values = allCourse[keys[<span class="number">0</span>]]</span><br><span class="line">                    keys.shift()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: !values.length,</span><br><span class="line">                value: values.shift()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历测试</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> courses) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么要这样做？很简单，降低代码的耦合度，使得代码的公用性和可维护性更好</p>
<p>扩展 - Generator 实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 Generator 实现的好处，Generator 帮我们实现了 next()，具备了 value 和 done</span></span><br><span class="line">courses[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> allCourse = <span class="built_in">this</span>.allCourse</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Reflect</span>.ownKeys(allCourse)</span><br><span class="line">    <span class="keyword">let</span> values = []</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!values.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys.length) &#123;</span><br><span class="line">                values = allCourse[keys[<span class="number">0</span>]]</span><br><span class="line">                keys.shift()</span><br><span class="line">                <span class="keyword">yield</span> values.shift()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">yield</span> values.shift()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> courses) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块化-Module"><a href="#模块化-Module" class="headerlink" title="模块化 Module"></a>模块化 Module</h3><p>至于模块化是什么，它解决了什么问题，我这里就不做过多赘述了，这里主要是针对 ES6 的模块化规范</p>
<p>导出模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 1 - 逐个导出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 导出常量（变量同理）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="string">&#x27;sunny&#x27;</span></span><br><span class="line"><span class="comment">// 导出方法（函数）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br><span class="line"><span class="comment">// 导出对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;es&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;obj&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 2 - 统一导出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> &#123; a, b, sum, obj, People &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 3 - export default 单个导出和统一导出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; a, b, sum, obj, People &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 4 - export default 导出 与 export 导出结合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> str = <span class="string">&#x27;sunny&#x27;</span></span><br></pre></td></tr></table></figure>

<p>导入模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 1 和 2，接收方式</span></span><br><span class="line"><span class="comment"> * 逗号分隔多个模块</span></span><br><span class="line"><span class="comment"> * as: 起别名，突破注意点 1 的限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; a <span class="keyword">as</span> aa, b, sum, obj, People &#125; <span class="keyword">from</span> <span class="string">&#x27;模块路径&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 3，接收方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> aa <span class="keyword">from</span> <span class="string">&#x27;模块路径&#x27;</span>	<span class="comment">// 单个</span></span><br><span class="line"><span class="keyword">import</span> mod <span class="keyword">from</span> <span class="string">&#x27;模块路径&#x27;</span>	<span class="comment">// 统一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出形式 4，接收方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> add, &#123; str &#125; <span class="keyword">from</span> <span class="string">&#x27;模块路径&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意点</p>
<ul>
<li>使用 export 关键字导出一个模块的时候，导入的模块名要和导出的模块名需要一致，如：b</li>
<li>使用了 as 关键字进行起别名，那么原来的名字就不能用了，如：aa</li>
<li>使用 export default 导出，导入的模块名要和导出的模块名不需要一致，导入的时候，模块名规范命名即可</li>
<li>使用 export default 导出，export default 一个文件内只能使用一次（出现一次）</li>
</ul>
<p><strong>更多详情，请收藏本博主，持续更新……谢谢！</strong></p>
<p>当然，如果您觉得此篇对您有所帮助，想请博主喝杯咖啡，请点击下方按钮，打开您的手机扫一扫，感谢您对本博主的赏识，博主感激不尽！</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://guohaoqi.com/JavaScript-%E6%96%B0%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/Vue-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Vue 学习之旅
          
        </div>
      </a>
    
    
      <a href="/%E6%95%B2%E7%A0%81%E7%A5%9E%E5%99%A8%E4%B9%8BVS-Code/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">敲码神器之VS Code</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "nqTjGNH3IPE7vyHbootbImu2-gzGzoHsz",
    app_key: "KPI8f1gujwzTmjIS27I0IoBv",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "说说你的看法吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020
        By 浩淇
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/mypic/20200816113944.jpeg" alt="浩淇的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://sunny-store.gitee.io">友链</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/dasan/20200808144729.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/HaoQiSpace/cdn/dasan/20200808144741.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>